<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-13T11:35:32+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用二叉查找树来进行查找]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/13/ios43/"/>
    <updated>2016-02-13T11:18:43+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/13/ios43</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>虽然二分法的查找速度快（O(log2n)）,但是有局限条件，就是查找的序列必须有序。  <br/>
除此之外，我们还可以利用二叉查找树来进行查找，如果它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树,查找时间的时间复杂度为O(log2n)；但是如果他的结点都集中于某一边，则查找时间的复杂度可能会变为O(n)。</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct treeNode {
    int val;
    int position;
    treeNode* left;
    treeNode* right;
    treeNode(int val,int position){
        this-&gt;val = val;
        this-&gt;position = position;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    }
};


class BinarySearchTree {
    treeNode* root = nullptr;

    void add(int value,int position,treeNode* node){
        if (node==nullptr) {
            throw "树为空";
        }

        if (value == node-&gt;val) {
            return;
        }else if(value &lt; node-&gt;val){
            if (node-&gt;left==nullptr) {
                node-&gt;left = new treeNode(value,position);
            }else{
                add(value, position, node-&gt;left);
            }
        }else{
            if (node-&gt;right==nullptr) {
                node-&gt;right = new treeNode(value,position);
            }else{
                add(value, position, node-&gt;right);
            }
        }
    }

    int search(int keyValue,treeNode* node){
        if (node==nullptr) {
            return -1;
        }else if(keyValue &lt; node-&gt;val){
            return search(keyValue, node-&gt;left);
        }else if(keyValue &gt; node-&gt;val){
            return search(keyValue, node-&gt;right);
        }else{
            return node-&gt;position;
        }
    }
    public:

    /**
     *添加结点
     **/
    void add(int value,int position){
        if (root==nullptr) {
            root = new treeNode(value,position);
        }else{
            add(value, position, root);
        }
    }

    /**
     *搜索
     **/
    int search(int keyValue){
        return search(keyValue, root);
    }

};

int main(int argc, const char * argv[]) {

    int a[] = {4,6,3,5,7,2,9,8,10};
    BinarySearchTree* tree = new BinarySearchTree();
    for (int i=0; i&lt;9; i++) {
        tree-&gt;add(a[i], i);
    }

    for (int i=0; i&lt;20; i++) {
        cout&lt;&lt;tree-&gt;search(i)&lt;&lt;endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的DFS遍历(非递归)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/11/ios41/"/>
    <updated>2016-02-11T13:54:08+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/11/ios41</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>递归是利用函数压栈实现，如果我们要将递归的写法转化为非递归写法，自然需要利用栈来实现。</p>

<h2>二叉树的实现</h2>

<p>代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct treeNode {
    int val;
    int position;
    treeNode* left;
    treeNode* right;
    treeNode(int val,int position){
        this-&gt;val = val;
        this-&gt;position = position;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    }
};


class BinarySearchTree {
    treeNode* root = nullptr;

    void add(int value,int position,treeNode* node){
        if (node==nullptr) {
            throw "树为空";
        }

        if (value == node-&gt;val) {
            return;
        }else if(value &lt; node-&gt;val){
            if (node-&gt;left==nullptr) {
                node-&gt;left = new treeNode(value,position);
            }else{
                add(value, position, node-&gt;left);
            }
        }else{
            if (node-&gt;right==nullptr) {
                node-&gt;right = new treeNode(value,position);
            }else{
                add(value, position, node-&gt;right);
            }
        }
    }
public:
    /**
     *添加节点
     **/
    void add(int value,int position){
        if (root==nullptr) {
            root = new treeNode(value,position);
        }else{
            add(value, position, root);
        }
    }

};
</code></pre>

<h2>前序遍历非递归写法</h2>

<p>代码如下：</p>

<pre><code class="C++">    /**
     *前序遍历
     **/
    void pre_order(){
        treeNode* currentNode = root;
        std::stack&lt;treeNode*&gt; stack;
        while (currentNode||!stack.empty()) {
            if (currentNode) {
                std::cout&lt;&lt;currentNode-&gt;val&lt;&lt;std::endl;
                stack.push(currentNode);
                currentNode = currentNode-&gt;left;
            }else{
                currentNode = stack.top();
                stack.pop();
                currentNode = currentNode-&gt;right;
            }
        }


    }
</code></pre>

<h2>中序遍历非递归写法</h2>

<p>代码如下：</p>

<pre><code class="C++">    /**
     *中序遍历
     **/
    void mid_order(){
        treeNode* currentNode = root;
        std::stack&lt;treeNode*&gt; stack;
        while (!stack.empty()||currentNode) {
            if (currentNode) {
                stack.push(currentNode);
                currentNode = currentNode-&gt;left;
            }else{
                currentNode = stack.top();
                stack.pop();
                std::cout&lt;&lt;currentNode-&gt;val&lt;&lt;std::endl;
                currentNode = currentNode-&gt;right;
            }
        }

    }
</code></pre>

<h2>后序遍历非递归写法</h2>

<p>代码如下：</p>

<pre><code class="C++">    /**
     *后序遍历
     **/
    void back_order(){
        treeNode* currentNode = root;
        treeNode* lastVisitNode = nullptr;
        std::stack&lt;treeNode*&gt; stack;

        while (currentNode) {
            stack.push(currentNode);
            currentNode = currentNode-&gt;left;
        }
        while (!stack.empty()) {
            currentNode = stack.top();
            stack.pop();
            if (currentNode-&gt;right==nullptr||currentNode-&gt;right==lastVisitNode) {
                std::cout&lt;&lt;currentNode-&gt;val&lt;&lt;std::endl;
                lastVisitNode = currentNode;
            }else{
                stack.push(currentNode);
                currentNode = currentNode-&gt;right;
                while (currentNode) {
                    stack.push(currentNode);
                    currentNode = currentNode-&gt;left;
                }
            }
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的DFS遍历(递归)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/11/ios40/"/>
    <updated>2016-02-11T13:40:04+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/11/ios40</id>
    <content type="html"><![CDATA[<h2>二叉(搜索)树的实现</h2>

<p>代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct treeNode {
    int val;
    int position;
    treeNode* left;
    treeNode* right;
    treeNode(int val,int position){
        this-&gt;val = val;
        this-&gt;position = position;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    }
};


class BinarySearchTree {
    treeNode* root = nullptr;

    void add(int value,int position,treeNode* node){
        if (node==nullptr) {
            throw "树为空";
        }

        if (value == node-&gt;val) {
            return;
        }else if(value &lt; node-&gt;val){
            if (node-&gt;left==nullptr) {
                node-&gt;left = new treeNode(value,position);
            }else{
                add(value, position, node-&gt;left);
            }
        }else{
            if (node-&gt;right==nullptr) {
                node-&gt;right = new treeNode(value,position);
            }else{
                add(value, position, node-&gt;right);
            }
        }
    }
public:
    /**
     *添加节点
     **/
    void add(int value,int position){
        if (root==nullptr) {
            root = new treeNode(value,position);
        }else{
            add(value, position, root);
        }
    }

};
</code></pre>

<h2>先序遍历</h2>

<p>代码如下：</p>

<pre><code class="C++">    void DFSTravel(treeNode* node){
        if (node==nullptr) {
            return;
        }else{
            //前序遍历
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
            DFSTravel(node-&gt;left);
            DFSTravel(node-&gt;right);           
        }
    }
</code></pre>

<h2>中序遍历</h2>

<p>代码如下：</p>

<pre><code class="C++">    void DFSTravel(treeNode* node){
        if (node==nullptr) {
            return;
        }else{
           //中序遍历
            DFSTravel(node-&gt;left);
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
            DFSTravel(node-&gt;right);           
        }
    }
</code></pre>

<h2>后序遍历</h2>

<p>代码如下：</p>

<pre><code class="C++">    void DFSTravel(treeNode* node){
        if (node==nullptr) {
            return;
        }else{           
            //后序遍历
            DFSTravel(node-&gt;left);
            DFSTravel(node-&gt;right);
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第n个丑数]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/08/ios38/"/>
    <updated>2016-02-08T14:07:50+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/08/ios38</id>
    <content type="html"><![CDATA[<h2>前言：</h2>

<p><code>1.</code> 何为丑数？  <br/>
丑数，就是只含有2、3、5三个因子的正整数。  <br/>
<code>2.</code> 如何让判断丑数？  <br/>
一个数先被2整除，直到不能被2整除，再被3整除，直到不能被3整除，再被5整除，直到不能被5整除，除到最后如果只剩下1则为丑数，否则不为丑数  <br/>
<code>3.</code> 判断丑数代码实现如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
class Solution {
public:
    bool isUgly(int num) {
          if (num==0) {
            return false;
        }else if(num==1){
            return true;
        }else{

            int tmp = num;
            while (tmp%2 == 0) {
                tmp = tmp/2;
            }
            while (tmp%3 == 0) {
                tmp = tmp/3;
            }
            while (tmp%5 == 0) {
                tmp = tmp/5;
            }
            if (tmp==1) {
                return true;
            }else{
                return false;
            }

        }
    }
};
</code></pre>

<h2>问题要求：</h2>

<p>例如1, 2, 3, 4, 5, 6, 8, 9, 10, 12 为前10个丑数，求第n个丑数</p>

<h2>做法：</h2>

<p><code>1.</code> 我们可以利用队列来帮助我们解决问题，首先我们需要3个队列q2、q3、q5，这三个队列分别存储能被2、3、5整除的整数；  <br/>
<code>2.</code> 1为第一个丑数，我们用p来记录当前的丑数，求第n个丑数，则循环n-1次以下操作：首先2*p、3*p、5*p分别插入q2、q3、q5队列，取各个队头元素获取他们之中的最小值，该最小值也是该次循环的丑数，再判断各个队头元素是否与这个最小值相等，如果相等则出队，再将该最小值赋值为p；  <br/>
<code>3.</code> 循环结束，p就是第n个丑数；</p>

<h2>代码实现：</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
class Solution {
public:
    int min1(int a,int b){
        return a&lt;b?a:b;
    }

    int nthUglyNumber(int n) {
        if (n&lt;=0) {
            return -1;
        }else if (n==1) {
            return 1;
        }else{
            queue&lt;int&gt; q2;
            queue&lt;int&gt; q3;
            queue&lt;int&gt; q5;
            int i = 1;
            int p = 1;
            while (i&lt;n) {
                q2.push(p*2);
                q3.push(p*3);
                q5.push(p*5);
                int min2 = q2.front();
                int min3  = q3.front();
                int min5 = q5.front();
                int min = min1(min1(min2, min3), min5);
                if (min2==min) {
                    q2.pop();
                }
                if (min3==min) {
                    q3.pop();
                }
                if (min5==min) {
                    q5.pop();
                }
                p = min;
                i++;
            }
            return p;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    Solution* s = new Solution();
    cout&lt;&lt;s-&gt;nthUglyNumber(4)&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[路径简化问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/08/ios37/"/>
    <updated>2016-02-08T13:15:41+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/08/ios37</id>
    <content type="html"><![CDATA[<h2>要求：</h2>

<p>给定一个UNIX风格的全路径，简化它，例如：  <br/>
“/home/”  =>  &ldquo;/home&rdquo;  <br/>
&ldquo;/a/./b/../../c/&rdquo;  =>  &ldquo;/c&rdquo;</p>

<h2>做法：</h2>

<p><code>1.</code> &ldquo;."指的是当前目录，&rdquo;..&ldquo;指的是上级目录，"cd / &rdquo; 则是返回根目录；  <br/>
<code>2.</code> 初始化一个vector1，我们将这个全路径按 “/” 分割，存储在vector1里；  <br/>
<code>3.</code> 然后初始化另一个vector2，遍历这个vector1，遇到文件夹，则将它添加到vector2的尾部，遇到 &ldquo;..&rdquo; 则删除vector2的尾部的元素，如遇到 “” 或 “ . ” 则跳过继续遍历，根据这个特点，也可以用栈来实现；  <br/>
<code>4.</code> 最后将vector2输出，拼接字符串；</p>

<h2>代码实现：</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
class Solution {
public:
    void spilt(const char* str,const char* deli,vector&lt;string&gt;* ve,int n){
        char tmp[n+1];
        snprintf(tmp, sizeof(tmp), str);
        ve-&gt;clear();
        char* gg;
        char* p  = strtok_r(tmp, deli, &amp;gg);
        while (p!=NULL) {
            ve-&gt;push_back(p);
            p = strtok_r(NULL, deli, &amp;gg);
        }


    }

    string simplifyPath(string path) {
        vector&lt;string&gt; ve;
        vector&lt;string&gt; newVe;
        //字符串转化为char*
        const char* str = path.c_str();
       spilt(str, "/", &amp;ve,(int)path.length());
        int n = (int)ve.size();
        for (int i = 0; i&lt;n; i++) {
            if (ve[i]==""||ve[i]==".") {
                continue;
            }else{
                if (ve[i]=="..") {
                    if (!newVe.empty()) {
                        newVe.pop_back();
                    }
                }else{
                    newVe.push_back(ve[i]);
                }

            }
        }
        if (newVe.empty()) {
            return "/";
        }else{
            int m = (int)newVe.size();
            string newStr = "";
            for (int i=0; i&lt;m; i++) {
                newStr = newStr+"/"+newVe[i];
            }

            return newStr;
        }
    }
};


int main(int argc, const char * argv[]) {
    Solution* s = new Solution();
    cout&lt;&lt;s-&gt;simplifyPath("///HSGambA/..///DLCkPZxIAWDX/iIQIncFWSaMLG/././RVOlTgYl/NnTHKiAVWVCPCARqna///lxbPdAlgTC/eXBfVOBuPbBRb/////iy///../gE/MoNMalkJgUChQbXuRogz/./../FkR/././././GtP///./..///CAiQtMuRub/xOcs/RtEkqhqCLZAkCzdX/////SNMEIs/cyneqrDxUosUhcGAB/bPHrLgioq/./HhFgLUjEFrg/nKlbXBRicXjxNBLD/.///.///LIUAUsBU/kTqEWZYpIdRRxDV/////pLjoiqd/mMgSebGPyZ/./VQAErxTVbJtFGJ/wyeOwQUEwz/../.././//d/../../qmYZmdXO///liGrmA/.././../Cc///tOLsCMtVJcDDKcuPM///./fywuWZOHnln/UjepoOdc/CVSRAwOielKl/../ExXI/SYsxkdfeRHPuRZhsRrQc/./RxruFyUPeisM/../uyGh/EjJsGlCLKMpnzS/SYoyFtsznGK/./mnbKK/../SLAKsHcouXPKSQwJa/./../NPn/kHeVSrDVVfhv/P/../CSXZeqLgJOLbyZZNiJGa/L///AOldPsSFIZqKKixZQ/evwGyGJhoKvvyot/pWtiAkFrvnLTbZZT/EkKrRJyXmNoUWCDr/qHgRjqETRtMfrX/WZxvvGRWclANrbuLuu///xBOFLDmoQtYQhjK/../MCRZBSWX/IYshVeeYGeHEPAsDYDp///pNnHlXfOQCVJu/../Ux/../HFaPOmbhjNq/OXRFgVU/uxMsClzPA/./cPlqKKvZNAQKzwFL///uvKKsZoHjZArQQ/DJruUeMYHMlhKPkFMy/NqdCweXujNHGJTL/tjhFFsOMeXWlNeDJjf/EeWUzIHmqfS/.././DDmiy///.././EqjhEiYgVbHo/NTvBQ/././//../nMzJgmVGcMlZgTQhwC/.///MXtPzGrZEB/WynGrD/////../PidAvghpCyxRYQRKaZEF/../mtoy//")&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
