<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-19T15:22:33+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[图的表达]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/19/ios53/"/>
    <updated>2016-02-19T14:45:57+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/19/ios53</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>图的表达有两种方式实现，一种是利用邻接矩阵，一种是利用邻接表。  <br/>
<code>1.</code> 利用邻接矩阵：利用一个二维数组来储存图结点的数据，数组的下标对应结点的编号，值代表结点之间的权值；  <br/>
<code>2.</code> 利用邻接表：实际上是利用一维数组和链表来实现的，链表用来存储某个结点到其他结点的路径，链表的第一个元素为到本结点的路径，数组用来储存各个链表；</p>

<h2>比较</h2>

<p>我们将图的结点个数设为V，图的路径个数设为E。  <br/>
用第一种方式实现，它的空间复杂度为O(V<sup>2</sup>)；  <br/>
用第二种方式实现，它的空间复杂度为O(V*E)。  <br/>
所以当图里面的路径比较稀疏用第二种方式实现，如果比较密集，则两种都可以。</p>

<h2>代码实现</h2>

<h4>利用邻接矩阵实现</h4>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;vector&gt;
using namespace std;

class Graphic {
private:
    std::vector&lt;std::vector&lt;int&gt;&gt; g;

public:
    Graphic(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;g):g(g){

    }
};

int main(int argc, const char * argv[]) {
    vector&lt;vector&lt;int&gt;&gt; g =
    \{\{0,0,1,1\},\{0,0,1,1\},\{0,1,0,0\},\{0,1,1,0\}\};

    Graphic gr(g);
    return 0;
}
</code></pre>

<h4>利用邻接表实现</h4>

<pre><code class="C++">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;

/**
 * 图路径
 * dest_id 目的结点的ID
 * weight 路径权值
 **/
struct edge_node {
    int dest_id;
    int weight;

    edge_node(int id,int weight)
    :dest_id(id),weight(weight){

    }

};

class Graph {

    std::vector&lt;std::list&lt;edge_node&gt;&gt; ad_vector;

public:
    Graph(int n)
    :ad_vector(n){

    }

    /**
     * 添加图路径
     **/
    void add_edge(int source,int dist,int weight){
        edge_node new_eage(dist,weight);
        ad_vector[source].push_back(new_eage);
    }

    /**
    * 打印所有路径
    **/
    void dump(){
        for (int i=0; i&lt;ad_vector.size(); i++) {
            for (auto pos = ad_vector[i].begin(); pos!=ad_vector[i].end(); pos++) {
                std::cout&lt;&lt;"edge from "&lt;&lt;i&lt;&lt;" to "&lt;&lt;pos-&gt;dest_id;
                std::cout&lt;&lt;" weight: "&lt;&lt;pos-&gt;weight&lt;&lt;std::endl;
            }
        }
    }
};

int main(int argc, const char * argv[]) {
    Graph g(4);
    g.add_edge(0, 1, 1);
    g.add_edge(0, 3, 1);
    g.add_edge(1, 2, 1);
    g.add_edge(1, 3, 1);
    g.add_edge(3, 2, 1);
    g.dump();
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最长回文字符串]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/14/ios50/"/>
    <updated>2016-02-14T22:36:55+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/14/ios50</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个字符串，求它的最长回文子字符串</p>

<h2>做法</h2>

<p>最长回文字符串的长度可能为奇数，也可能为偶数，所以我们可以假定这两种情况来求。我们采用中间拓展法来获取回文子串：由一个字符向它的左右两边拓展，当左右相等时继续拓展，当不等时停止拓展，记录此时的长度n，获得一个n长度的回文子串。然后对下一个字符继续用中间拓展法。当遍历完字符串所有字符后，选取长度最大的回文子串。</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;string&gt;
using namespace std;
class Solution {
public:
    string longestPalindrome(string s) {
        int n = (int)s.length();
                if (n==1) {
            return s;
        }
        //记录最长的回文子串长度
        int max = 0;
        int maxLeft = 0;
        int maxRight = 0;
        for(int i=0;i&lt;n;i++){
            //假定回文子串的长度为奇数
            int start = i-1;
            int end = i+1;
            int len = 1;
            int left = start;
            int right = end;
            while (start&gt;=0&amp;&amp;end&lt;n) {
                if (s[start]==s[end]) {
                    len = len+2;
                    left = start;
                    right = end;
                    start--;
                    end++;
                }else{
                    break;
                }
            }
            if (len&gt;max) {
                max = len;
                maxLeft = left;
                maxRight = right;
            }
            //假定回文子串的长度为偶数
            start = i;
            end = i+1;
            len = 0;
            left = start;
            right = end;
            while (start&gt;=0&amp;&amp;end&lt;n) {
                if (s[start]==s[end]) {
                    len = len+2;
                    left = start;
                    right = end;
                    start--;
                    end++;
                }else{
                    break;
                }
            }
            if (len&gt;max) {
                max = len;
                maxLeft = left;
                maxRight = right;
            }
        }
        return s.substr(maxLeft,maxRight-maxLeft+1);
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断是否是回文字符串]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/14/ios49/"/>
    <updated>2016-02-14T13:41:59+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/14/ios49</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>判断是否是回文字符串</p>

<h2>做法</h2>

<p>先将字符串转化为小写字符串，接着初始化一个头指针和尾指针，遍历字符串，遍历的时候注意字符是否是‘1’~‘9’或‘a’~&lsquo;z'，如果不是就跳过遍历。如果头尾指针遍历到的字符不同就返回false，否则继续遍历。</p>

<h2>代码实现</h2>

<pre><code class="C++">
#include &lt;iostream&gt;
using namespace::std;
class Solution {
public:

    /**
    * 判断是否是1~9或a~b之中的字符
    **/
    bool isNormalChar(char c){
        if (('a'&lt;=c&amp;&amp;c&lt;='z')||('0'&lt;=c&amp;&amp;c&lt;='9')) {
            return true;
        }
        return false;
    }

    bool isPalindrome(string s) {
        if (s.length()&lt;=1) {
            return true;
        }
        //将字符串中的大写转化为小写
        transform(s.begin(), s.end(), s.begin(),::tolower);
        int n = (int)s.length();
        int i = 0;
        int j = n-1;
        while (i&lt;j) {
            if (s[i]==s[j]) {
                i++;
                j--;
            }else{
                if (!isNormalChar(s[i])) {
                    i++;
                }else if(!isNormalChar(s[j])){
                    j--;
                }else{
                    return false;
                }
            }
        }
        return true;
    }
};
int main(int argc, const char * argv[]) {
    Solution* s = new Solution();
    cout&lt;&lt;s-&gt;isPalindrome("ab")&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断是否是回文数字]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/14/ios48/"/>
    <updated>2016-02-14T12:07:13+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/14/ios48</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>什么是回文？  <br/>
回文就是正着读、反着读都一样的字符串，例如：“心连心”、“abccba”、“bcdcb”、“123321” 这些都是回文。</p>

<h2>要求</h2>

<p>判断一个数字是否是回文数字</p>

<h2>做法</h2>

<p>判断数字的每一位是否对称</p>

<h2>代码如下</h2>

<pre><code class="C++">
#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;
class Solution {
public:
    /**
    *计算数字的位数
    **/
    int wei(int x){
        int count = 0;
        while (x&gt;0) {
            x = x/10;
            count++;
        }
        return count;
    }

    /**
    *   判断
    **/
    bool isPalindrome(int x) {
        if (x&lt;0) {
            return false;
        }
        if (x&gt;=0&amp;&amp;x&lt;10) {
            return true;
        }else{
            int n = wei(x);
            int t = (int)pow(10,n-1);
            int tmp = x;
            int half = n/2;
            for(int i=0;i&lt;half;i++){
                if (x/t%10==tmp%10) {
                    t = t/10;
                    tmp = tmp/10;
                }else{
                    return false;
                }
            }
            return true;
        }
    }
};

int main(int argc, const char * argv[]) {
    Solution* s =  new Solution();
    cout&lt;&lt;s-&gt;isPalindrome(1221)&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断一颗树是否是平衡二叉树]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/14/ios47/"/>
    <updated>2016-02-14T11:21:07+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/14/ios47</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>判断一个树是否是平衡二叉树，何为平衡二叉树，就是它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>

<h2>做法</h2>

<p>由要求可看出判断一颗树是否是平衡二叉树的依据就是每个节点的左右子树的高度(深度)差的绝对值不超过1，那么我们可以通过计算节点的深度来判断，那如何计算节点的深度呢？我们发现树有个特点就是父节点的深度是子节点深度的最大值加1，由这个特点，我们可以计算节点的深度</p>

<h2>代码如下</h2>

<p>我提供两种代码思路</p>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;


  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };

class Solution {
public:

    /**
     *方法一
     * 传统方法，计算每个节点的深度判断，时间复杂度为O(n^2)
     **/
    int depth(TreeNode* node){
        if (node==nullptr) {
            return 0;
        }else if(!node-&gt;left&amp;&amp;!node-&gt;right){
            return 1;
        }
        else{
            int leftD = depth(node-&gt;left);
            int rightD = depth(node-&gt;right);
            return 1+(leftD&gt;rightD?leftD:rightD);
        }
    }
    bool isBalanced(TreeNode* root) {
        if (root==nullptr) {
            return true;
        }else{
            int leftD = depth(root-&gt;left);
            int rightD = depth(root-&gt;right);
            if (abs(leftD-rightD)&gt;1) {
                return false;
            }else{
                return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);
            }
        }
    }

    /**
     *方法二
     * 边计算深度边判断，时间复杂度为O(n)
     **/
    int depth2(TreeNode* node){
        if (node==nullptr) {
            return 0;
        }else{
            int leftD = depth2(node-&gt;left);
            int rightD = depth2(node-&gt;right);
            if (leftD==-1||rightD==-1||abs(leftD-rightD)&gt;1) {
                return -1;
            }else{
                return (leftD&gt;rightD?leftD:rightD)+1;
            }
        }
    }
    bool isBanlanced2(TreeNode* root){
        if (root==nullptr) {
            return true;
        }else{
            if (depth2(root)==-1) {
                return false;
            }else{
                return true;
            }
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
