<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-24T21:04:01+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Word Ladder]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/23/ios59/"/>
    <updated>2016-02-23T17:06:59+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/23/ios59</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定两个字符串，一个为起始字符串，一个为终点字符串，以及一个字典，求起始字符串转化为终点字符串的最短路径,返回转化路径的长度。</p>

<h4>具体要求：</h4>

<p>1、一次只能变换一个单词；  <br/>
2、转化过程出现的单词必须是字典里的。</p>

<h4>例子：</h4>

<p>beginWord = “hit”  <br/>
endWord = “cog”  <br/>
dictionary = [&ldquo;hot&rdquo;,&ldquo;dot&rdquo;,&ldquo;dog&rdquo;,&ldquo;lot&rdquo;,&ldquo;log&rdquo;]  <br/>
transformation："hit"->&ldquo;hot&rdquo;->&ldquo;dot&rdquo;->&ldquo;dog&rdquo;->&ldquo;cog&rdquo;  <br/>
return its length 5</p>

<h2>做法</h2>

<p>既然要求最短，我们可以借助图BFS的思想来解决这个问题，这个问题可以转化为图的源最短路径问题，虽然解题过程中没有用到图，但用到图的思想。
从源字符串出发，先遍历完当前字符串可能变化的情况，如果还没变成终点字符串，则继续下一层遍历，直到可以变成终点字符串，返回转化步数。如果所有情况都遍历完了还不能变成终点字符串，则返回0。</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
using namespace std;
/**
 * 记录源字符串转化当前字符串的路径
 * word 当前字符串
 * pre 前驱字符串
 * isVisited 当前字符串是否被访问
 * size 源字符串转化为当前字符串的过程经过的字符串的个数，即转化步数
 **/

struct Node {
    string word;
    string pre;
    bool isVisited;
    int size;
    Node(string word)
    :word(word),isVisited(false),size(0){

    }
};

class Solution {
public:
    int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList) {
        unordered_map&lt;string, Node*&gt; word_map;
        for (auto pos = wordList.begin(); pos!=wordList.end(); pos++) {
            Node* node = new Node(*pos);
            word_map[*pos] = node;
        }
        Node* begin = new Node(beginWord);
        begin-&gt;isVisited = true;
        begin-&gt;size = 1;
        word_map[beginWord] = begin;

        Node* end = new Node(endWord);
        word_map[endWord] = end;

        queue&lt;Node*&gt; queue;
        queue.push(word_map[beginWord]);
        while (!queue.empty()) {
            Node* current_node = queue.front();
            queue.pop();
            //遍历字符串每一个位置
            for (int i = 0; i&lt;current_node-&gt;word.length(); i++) {
                for (char j = 'a'; j&lt;='z'; j++) {
                    string word = current_node-&gt;word;
                    //替换字符，word变成一个新字符串
                    word[i] = j;
                    if (word==endWord) {
                        word_map[word]-&gt;size = current_node-&gt;size+1;
                        return word_map[word]-&gt;size;
                    }
                    else if (word_map.count(word)==1&amp;&amp;word_map[word]-&gt;isVisited==false) {
                        word_map[word]-&gt;isVisited = true;
                        word_map[word]-&gt;pre = current_node-&gt;word;
                        word_map[word]-&gt;size = current_node-&gt;size+1;
                        queue.push(word_map[word]);
                    }
                }
            }
        }
        return 0;
    }
};

int main(int argc, const char * argv[]) {
    unordered_set&lt;string&gt; wordList = {"hot","dot","dog","lot","log"};
    Solution s;
    cout&lt;&lt;s.ladderLength("hit", "cog", wordList)&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中的map和unordered_map]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/23/ios58/"/>
    <updated>2016-02-23T16:08:04+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/23/ios58</id>
    <content type="html"><![CDATA[<h1>map</h1>

<h2>简介</h2>

<p>映射表（Map）容器是一个按特定顺序存储以键值对组合而成的元素的关联容器。</p>

<h2>类模板</h2>

<pre><code class="C++">// &lt;map&gt;
template &lt; class Key,
    class T,
    class Compare = less&lt;Key&gt;,
    class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt;
&gt; class map
</code></pre>

<h3>模板参数</h3>

<p><code>1.</code> key：主键的类型；  <br/>
<code>2.</code> T：被映射的值得类型；  <br/>
<code>3.</code> Compare：一个二元谓词，以两个元素的主键为参数返回一个 bool 值。  <br/>
<code>4.</code> Alloc：容器内部用来管理内存分配及释放的内存分配器的类型。这个参数是可选的，它的默认值是 std::allocator<T>，这个是一个最简单的非值依赖的（Value-independent）内存分配器。</p>

<h2>详细说明</h2>

<p>在一个映射表容器中，主键通常被用来排序及唯一标志一个元素，而被映射的值保存了与该主键关联的内容。主键与被映射值的类型可以不同，在模板内部，这两种类型合并绑定成成员类型 value_type。由上述描述可知，value_type 是一个双元组类型（Pair type），具体定义如下：</p>

<pre><code class="C++">typedef pair&lt;const Key, T&gt; value_type;
</code></pre>

<p>map 容器中的所有元素都是按由类型为 Compare 的比较对象指定的严格弱序规则排序的。  <br/>
在用主键访问单个元素时，map 容器通常比 unordered_map 容器低效，但 map 容器允许按顺序直接对某个子集进行迭代。  <br/>
map 容器通常被实现为一个二叉搜索树（及其变型），该数据结构具有对数据自动排序的功能。  <br/>
在所有关联容器中，map 容器唯一具有的一个特点：实现了直接访问操作符（operator[]），使得可以直接访问被映射的值。  <br/>
map 容器支持双向迭代。</p>

<h2>相关函数使用说明</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;
struct Node {
    int id;
    int val;
    Node(int id,int val)
    :id(id),val(val){

    }
};

struct compare{
    bool operator()(const Node &amp;a,const Node &amp;b)const{
        return a.val&lt;b.val;
    }
};

bool operator&lt;(const Node &amp;a,const Node &amp;b){
    return a.val&lt;b.val;
}

int main(int argc, const char * argv[]) {
    cout&lt;&lt;"初始化一个map，有序的，默认是升序"&lt;&lt;endl;
    map&lt;string,int&gt; test_map;



    cout&lt;&lt;"添加数据方式一,插入key值一样的pair，不会改变原本pair"&lt;&lt;endl;
    test_map.insert(pair&lt;string, int&gt;("a",2));
    test_map.insert(pair&lt;string, int&gt;("b",3));
    test_map.insert(pair&lt;string, int&gt;("d",4));
    test_map.insert(pair&lt;string, int&gt;("c",6));


    cout&lt;&lt;"添加数据方式二,可以通过[]来修改key对应的值"&lt;&lt;endl;
    test_map["a"] = 2;
    test_map["b"] = 3;
    test_map["d"] = 4;
    test_map["c"] = 6;

    cout&lt;&lt;"传入key值删除元素"&lt;&lt;endl;
    test_map.erase("a");

    cout&lt;&lt;"map的大小"&lt;&lt;endl;
    cout&lt;&lt;test_map.size()&lt;&lt;endl;

    cout&lt;&lt;"遍历map"&lt;&lt;endl;
    for (auto pos = test_map.begin(); pos!=test_map.end(); pos++) {
        cout&lt;&lt;"key:"&lt;&lt;pos-&gt;first&lt;&lt;" value:"&lt;&lt;pos-&gt;second&lt;&lt;endl;
    }
    cout&lt;&lt;endl;

    cout&lt;&lt;"计算key为d的元素个数，为1即有，为0即没有"&lt;&lt;endl;
    if(test_map.count("d")==1){
        cout&lt;&lt;"find d"&lt;&lt;endl;
    }else{
        cout&lt;&lt;"no find"&lt;&lt;endl;
    }

    cout&lt;&lt;"寻找key为d的元素，若找到的返回对象元素的迭代器，否则返回最后一个元素的迭代器"&lt;&lt;endl;
    if (test_map.find("d")!=test_map.end()) {
        cout&lt;&lt;"find d value is "&lt;&lt;test_map.find("d")-&gt;second&lt;&lt;endl;
    }else{
        cout&lt;&lt;"no find"&lt;&lt;endl;
    }

    cout&lt;&lt;"自定义类型的map,需要重新compare函数或者重载&lt;运算符，其他用法参照上面"&lt;&lt;endl;
    map&lt;Node, int, compare&gt; node_map;

    //需要重载&lt;运算符，系统默认的compare是less
    //map&lt;Node, int&gt; node_map;
    Node n1(1,2);
    Node n2(3,1);
    Node n3(4,5);

    node_map.insert(pair&lt;Node, int&gt;(n1,1));
    node_map.insert(pair&lt;Node, int&gt;(n2,2));
    node_map.insert(pair&lt;Node, int&gt;(n3,3));

    for (auto pos = node_map.begin(); pos!=node_map.end(); pos++) {
        cout&lt;&lt;"Node value is "&lt;&lt;pos-&gt;second&lt;&lt;endl;
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>

<h1>unordered_map</h1>

<h2>简介</h2>

<p>无序映射表（Unordered Map）容器是一个存储以键值对组合而成的元素的关联容器，容器中的元素无特别的次序关系。该容器允许基于主键地快速检索各个元素</p>

<h2>类模板</h2>

<pre><code class="C++">// &lt;unordered_map&gt;
template &lt; class Key,
    class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = equal_to&lt;Key&gt;,
    class Alloc = allocator&lt; pair&lt;const Key,T&gt; &gt;
&gt; class unordered_map;
</code></pre>

<h3>模板参数</h3>

<p><code>1.</code> key：主键类型；  <br/>
<code>2.</code>  T：被映射的值的类型；  <br/>
<code>3.</code> Hash：一元谓词，以一个 Key 类型的对象为参数，返回一个基于该对象的 size_t 类型的唯一值；  <br/>
<code>4.</code> Pred：二元谓词，以两个 Key 类型的对象为参数，返回一个 bool 值，如果第一个参数等价于第二个参数，该 bool 值为 true，否则为 false。默认为 std::equal_to；  <br/>
<code>5.</code> Alloc：容器内部用来管理内存分配及释放的内存分配器的类型。这个参数是可选的，它的默认值是 std::allocator<T>，这个是一个最简单的非值依赖的（Value-independent）内存分配器。</p>

<h2>详细说明</h2>

<p>在一个 unordered_map 容器中，主键通常被用来唯一标志（Uniquely identify）一个元素，而被映射的值保存了与该主键关联的内容。主键与被映射值的类型可以不同，在模板内部，这两种类型合并绑定成成员类型 value_type。由上述描述可知，value_type 是一个双元组类型（Pair type），具体定义如下：</p>

<pre><code class="C++">typedef pair&lt;const Key, T&gt; value_type;
</code></pre>

<p>在 unordered_map 内部，元素不会按任何顺序排序，而是通过主键的 hash 值将元素分组放置到各个槽（Bucket，也可译成“桶”）中，这样就能通过主键快速地访问各个对应的元素（平均耗时为一个常量，即时间复杂度为 O(1)）。  <br/>
在访问容器中的某个元素时，unordered_map 容器比 map 容器高效，而在迭代容器元素的某个子集时，前者比后者稍微低效了一点。  <br/>
unordered_map 实现了直接访问操作符（operator[]），使得可以通过主键（Key value）直接访问被映射的值（Mapped value）。  <br/>
unordered_map 容器支持正向迭代。</p>

<h2>相关函数说明</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;
struct Node {
    int id;
    int val;
    Node(int id,int val)
    :id(id),val(val){

    }
};

struct hash_func{
    size_t operator()(const Node &amp;n)const{
        return n.id*99+n.val;
    }
};

struct equal_to_func{
    bool operator()(const Node &amp;a,const Node &amp;b)const{
        return a.id==b.id&amp;&amp;a.val==b.val?true:false;
    }
};

int main(int argc, const char * argv[]) {
    Node n1(1,2);
    Node n2(3,1);
    Node n3(4,5);


    cout&lt;&lt;"初始化一个unordered_map"&lt;&lt;endl;
    unordered_map&lt;string, int&gt; test_unordered_map;
    test_unordered_map["a"] = 1;
    test_unordered_map["b"] = 2;
    test_unordered_map["c"] = 3;
    cout&lt;&lt;"遍历unordered_map"&lt;&lt;endl;
    for (auto pos = test_unordered_map.begin(); pos!=test_unordered_map.end(); pos++) {
        cout&lt;&lt;"key:"&lt;&lt;pos-&gt;first&lt;&lt;" value:"&lt;&lt;pos-&gt;second&lt;&lt;endl;
    }
    cout&lt;&lt;endl;

    cout&lt;&lt;"初始化一个自定义类型unordered_map，需要重写hash函数和pred函数"&lt;&lt;endl;
    unordered_map&lt;Node, int,hash_func,equal_to_func&gt; node_unordered_map;
    node_unordered_map[n1] = 1;
    node_unordered_map[n2] = 2;
    node_unordered_map[n3] = 3;
    cout&lt;&lt;"遍历node_unordered_map"&lt;&lt;endl;
    for (auto pos = node_unordered_map.begin(); pos!=node_unordered_map.end(); pos++) {
        cout&lt;&lt;"key id:"&lt;&lt;pos-&gt;first.id&lt;&lt;" value:"&lt;&lt;pos-&gt;second&lt;&lt;endl;
    }
    cout&lt;&lt;endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Sum问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/22/ios57/"/>
    <updated>2016-02-22T21:20:53+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/22/ios57</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个数组和一个目标数，在数组里查找两个数，这两个数之和等于目标数，返回这两个数的下标。  <br/>
例如：nums = [2,7,11,15],target = 9  <br/>
     return [0,1]</p>

<h2>做法</h2>

<p>遍历数组，利用hash表存储这个数组，键为数组元素，值为数组下标。遍历过程中，如果hash表内存在(target-当前元素),则找到sum为target的两个数。  <br/>
这种做法的时间复杂度为O(n)。</p>

<h2>代码实现</h2>

<pre><code class="C++">class Solution {
public:
     vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; result;
        unordered_map&lt;int, int&gt; hash_map;
        for (int i=0; i&lt;nums.size(); i++) {
            if (hash_map.count(nums[i])==0) {
                hash_map.insert(unordered_map&lt;int, int&gt;::value_type(nums[i],i));

            }
            if (hash_map.count(target-nums[i])==1) {
                int index = hash_map.find(target-nums[i])-&gt;second;
                if (i&lt;index) {
                    result.push_back(i);
                    result.push_back(index);
                }else if(i&gt;index){
                    result.push_back(index);
                    result.push_back(i);
                }
            }
        }
        return result;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中的set和unordered_set]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/22/ios56/"/>
    <updated>2016-02-22T20:28:12+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/22/ios56</id>
    <content type="html"><![CDATA[<h1>set</h1>

<h2>简介</h2>

<p>集合（Set）容器是一个按特定顺序存储唯一元素的关联容器。</p>

<h2>类模板</h2>

<pre><code class="C++">template &lt; class T,
           class Compare = less&lt;T&gt;,
           class Alloc = allocator&lt;T&gt; &gt;
&gt; class set;
</code></pre>

<h3>模板参数</h3>

<p><code>1.</code> T：元素的类型。  <br/>
<code>2.</code> Compare：一个二元谓词，以两个元素为参数返回一个 bool 值。(比较函数)  <br/>
<code>3.</code> Alloc：容器内部用来管理内存分配及释放的内存分配器的类型。这个参数是可选的，它的默认值是 std::allocator<T>.</p>

<h2>详细说明</h2>

<p>在一个集合中，元素的值同时可以用来标志对应的元素（即值是自身的主键），每个值必须是唯一的。主键是不可修改的，因此在 set 中的元素不能被逐个修改（所有元素保持恒定），但是可以删除某个元素或插入新的元素。  <br/>
set 容器中的所有元素都是按由类型为 Compare 的比较对象指定的严格弱序规则排序的。  <br/>
在用主键访问单个元素时，set 容器通常比 unordered_set 容器低效，但 set 容器允许按顺序直接对某个子集进行迭代。  <br/>
set 容器通常被实现为一个二叉搜索树（及其变型），该数据结构具有对数据自动排序的功能。
支持双向迭代</p>

<h2>相关函数使用说明</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
using namespace std;
struct Node {
    int val;
    int id;
    Node(int id,int val)
    :val(val),id(id){

    }
};



bool operator&lt;(const Node&amp; a,const Node &amp;b)
{
    return a.val&lt;b.val;
}


int main(int argc, const char * argv[]) {
    cout&lt;&lt;"初始化一个set"&lt;&lt;endl;
    set&lt;int&gt; test_set = {2,3,19,8,6,7};

    cout&lt;&lt;"删除一个元素"&lt;&lt;endl;
    test_set.erase(19);

    cout&lt;&lt;"遍历set里面的元素"&lt;&lt;endl;
    for (auto pos = test_set.begin(); pos!=test_set.end(); pos++) {
        cout&lt;&lt;*pos&lt;&lt;" ";
    }
    cout&lt;&lt;endl;

    cout&lt;&lt;"查找元素的个数，如果为1就是找到，为0就是找不到"&lt;&lt;endl;
    if (test_set.count(5)==1) {
        cout&lt;&lt;"have find"&lt;&lt;endl;
    }else{
        cout&lt;&lt;"no find"&lt;&lt;endl;
    }

    cout&lt;&lt;"查找元素的迭代器，找不到则返回最后一个元素的迭代器，找得到就返回元素的迭代器"&lt;&lt;endl;
    if (test_set.find(5)!=test_set.end()) {
        cout&lt;&lt;"have find"&lt;&lt;endl;
    }else{
        cout&lt;&lt;"no find"&lt;&lt;endl;
    }

    cout&lt;&lt;"有效元素个数"&lt;&lt;endl;
    cout&lt;&lt;test_set.size()&lt;&lt;endl;

    cout&lt;&lt;"自定义类型的set，默认是less函数(&lt;),所以必须重载&lt;操作符,其他用法跟标准的set一样"&lt;&lt;endl;
    Node n1(1,5);
    Node n2(2,3);
    Node n3(3,9);
    set&lt;Node&gt; node_set;
    node_set.insert(n1);
    node_set.insert(n2);
    node_set.insert(n3);
    cout&lt;&lt;"遍历自定义类型set里面的元素"&lt;&lt;endl;
    for (auto pos = node_set.begin(); pos!=node_set.end(); pos++) {
        cout&lt;&lt;pos-&gt;id&lt;&lt;" ";
    }
    cout&lt;&lt;endl;
    return 0;
}
</code></pre>

<h1>unordered_set</h1>

<h2>简介</h2>

<p>无序集合（Unordered Set）容器是一个存储唯一元素的关联容器，容器中的元素无特别的次序关系。该容器允许基于值地快速元素检索。</p>

<h2>类模板</h2>

<pre><code class="C++">// &lt;unordered_set&gt;
template &lt; class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = equal_to&lt;Key&gt;,
    class Alloc = allocator&lt;Key&gt;
&gt; class unordered_set;
</code></pre>

<h3>模板参数</h3>

<p><code>1.</code> Key：元素的类型。  <br/>
<code>2.</code> Hash：一元谓词，以一个 Key 类型的对象为参数，返回一个基于该对象的 size_t 类型的唯一值（哈希函数）。  <br/>
<code>3.</code> Pred：二元谓词，以两个 Key 类型的对象为参数，返回一个 bool 值，如果第一个参数等价于第二个参数，该 bool 值为 true，否则为 false。默认为 std::equal_to。      <br/>
<code>4.</code> Alloc：容器内部用来管理内存分配及释放的内存分配器的类型。这个参数是可选的，它的默认值是 std::allocator<T>。</p>

<h2>详细说明</h2>

<p>在一个 unordered_set 容器中，元素的值同时可以用来标志对应的元素（即值是自身的主键），每个值必须是唯一的。主键是不可修改的，因此在 unordered_set 中的元素不能被逐个修改（所有元素保持恒定），但是可以删除某个元素或插入新的元素。  <br/>
在 unordered_set 内部，元素不会按任何顺序排序，而是通过元素值的 hash 值将元素分组放置到各个槽（Bucket，也可译成“桶”）中，这样就能通过元素值快速地访问各个对应的元素（平均耗时为一个常量，即时间复杂度为 O(1)）。  <br/>
在访问容器中的某个元素时，unordered_set 容器比 set 容器高效，而在迭代容器元素的某个子集时，前者比后者稍微低效了一点。  <br/>
unordered_set 容器支持正向迭代</p>

<h2>相关函数说明</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;

using namespace std;
struct Node {
    int val;
    int id;
    Node(int id,int val)
    :val(val),id(id){

    }
};

struct node_hash_fun{
    size_t operator()(const Node &amp;n)const{
        return n.id*50+n.val;
    }
};

struct node_equal_fun{
    bool operator()(const Node &amp;n,const Node&amp;m)const{
        return n.id==m.id&amp;&amp;n.val==m.val?true:false;
    }
};


int main(int argc, const char * argv[]) {
    cout&lt;&lt;"相当于java的hashSet,里面存放的元素是无序的,其他用法跟set大同小异"&lt;&lt;endl;
    unordered_set&lt;int&gt; test_unordered_set = {2,5,3,6,7,1,9,0};

    cout&lt;&lt;"遍历unordered_set"&lt;&lt;endl;
    for (auto pos = test_unordered_set.begin(); pos!=test_unordered_set.end(); pos++) {
        cout&lt;&lt;*pos&lt;&lt;" ";
    }
    cout&lt;&lt;endl;

    Node n1(1,5);
    Node n2(2,3);
    Node n3(3,9);
    cout&lt;&lt;"自定义类型unordered_set，必须重载hash_func和==操作符,其他用法跟标准的unordered_set一样"&lt;&lt;endl;   unordered_set&lt;Node,node_hash_fun,node_equal_fun,allocator&lt;Node&gt;&gt; node_unordered_set;
    node_unordered_set.insert(n1);
    node_unordered_set.insert(n2);
    node_unordered_set.insert(n3);

    cout&lt;&lt;"遍历自定义类型unordered_set"&lt;&lt;endl;
    for (auto pos = node_unordered_set.begin(); pos!=node_unordered_set.end(); pos++) {
        cout&lt;&lt;(*pos).id&lt;&lt;" ";
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图单源最短路径问题(Dijkstra算法)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/19/ios55/"/>
    <updated>2016-02-19T15:36:10+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/19/ios55</id>
    <content type="html"><![CDATA[<h2>算法思路</h2>

<p><code>1.</code> 图用邻接表表达（ <a href="http://caixindong.github.io/blog/2016/02/19/ios53/">http://caixindong.github.io/blog/2016/02/19/ios53/</a> ），每个图结点都储存一个值，记录源结点到结点的距离，一开始初始化为不可达，即距离设置为无穷大，而源结点的值为0，因为源结点到源结点的距离为0；  <br/>
<code>2.</code> 从源结点开始，遍历从源结点出发的所有路径，某结点可达，它的值更新为源结点的值加上之间路径的值，不可达的结点保持原来的值；      <br/>
<code>3.</code> 从那些未遍历的结点中取值最小的结点作为下一个遍历的结点；      <br/>
<code>4.</code> 遍历从当前遍历结点出发的所有路径，某结点可达，比较当前遍历结点的值加上路径值的和与某结点的值的大小，哪个小就更新为哪个值；
<code>5.</code> 继续从那些未遍历的结点中取值最小的结点作为下一个遍历的结点，继续步骤4的做法，直到所有结点都被遍历。</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include "graph.hpp"
#include &lt;climits&gt;
#include &lt;queue&gt;
using namespace std;
/**
 * 用于记录图结点数据
 * id   结点id
 * dist 源结点到当前结点的最短距离
 * prev 最短路径的前一个结点
 * processed 是否遍历过
 **/
struct node {
    int id;
    int dist;
    int prev;
    bool processed;
    node():dist(INT_MAX),prev(-1),processed(false){

    }
};

/**
* 用于比较距离大小的仿函数
**/
struct compare_node {
    bool operator()(node&amp; a,node &amp;b){
        return a.dist &gt; b.dist;
    }
};

/**
 * Dijkstra算法
 * g 操作的图
 * source 源结点
 **/
vector&lt;node&gt; Dijkstra(Graph &amp;g,int source){
      //获取图结点个数
    int node_count = (int)g.ad_vector.size();

    //将遍历每个结点的结果存放在nodes容器
    vector&lt;node&gt; nodes(node_count);

    for (int i=0; i&lt; node_count; i++) {
        nodes[i].id = i;
    }

    nodes[source].dist = 0;

    //优先队列，dist小的先出队
    priority_queue&lt;node,vector&lt;node&gt;,compare_node&gt; node_pq;
    node_pq.push(nodes[source]);

    while (!node_pq.empty()) {
        node current_node = node_pq.top();
        node_pq.pop();
        if (current_node.processed) {
            continue;
        }else{
            list&lt;edge_node&gt; edge_nodes = g.ad_vector[current_node.id];
            for (auto pos = edge_nodes.begin(); pos!=edge_nodes.end(); pos++) {
                node&amp; dest_node = nodes[pos-&gt;dest_id];
                if (current_node.dist+pos-&gt;weight&lt;dest_node.dist) {
                    dest_node.dist = current_node.dist+pos-&gt;weight;
                    dest_node.prev = current_node.id;
                    node_pq.push(dest_node);
                }
            }
            current_node.processed = true;
        }
    }
    return nodes;
}

void print_path(vector&lt;node&gt;&amp; nodes,int node_id){
    if (nodes[node_id].prev==-1) {
        cout&lt;&lt;"path: "&lt;&lt;node_id;
    }else{
        print_path(nodes,nodes[node_id].prev);
        cout&lt;&lt; "-&gt;" &lt;&lt; node_id;
    }
}

int main(int argc, const char * argv[]) {
    Graph g(7);
    g.add_edge(0, 1, 2);
    g.add_edge(0, 3, 9);
    g.add_edge(0, 4, 6);
    g.add_edge(1, 2, 1);
    g.add_edge(1, 4, 3);
    g.add_edge(2, 4, 1);
    g.add_edge(2, 6, 6);
    g.add_edge(4, 3, 2);
    g.add_edge(4, 5, 9);
    g.add_edge(5, 6, 5);

    vector&lt;node&gt; result = Dijkstra(g, 0);
    for(int i = 0; i &lt; result.size(); i++){
        cout &lt;&lt; "Print path and dist for node:" &lt;&lt; result[i].id &lt;&lt; endl;
        print_path(result, result[i].id);
        cout &lt;&lt; endl &lt;&lt; "Dist:" &lt;&lt; result[i].dist &lt;&lt; endl;
    }
        return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
