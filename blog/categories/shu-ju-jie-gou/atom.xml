<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-08T10:50:44+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[括号匹配问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/08/ios36/"/>
    <updated>2016-02-08T10:34:21+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/08/ios36</id>
    <content type="html"><![CDATA[<h1>新年到了，恭祝大家新年快乐</h1>

<h2>今天解决括号匹配问题</h2>

<h2>要求：</h2>

<p>给定一个字符串，判断它是否括号匹配，'(&lsquo;和&rsquo;)&lsquo;匹配，&rsquo;[&lsquo;和&rsquo;]&lsquo;匹配，&rsquo;{&lsquo;和&rsquo;}&lsquo;匹配，成对出现。例如："( [ [ ] ] )&ldquo;括号匹配，而&rdquo;[ [ ( ( ) )&ldquo;则不匹配。</p>

<h2>做法：</h2>

<p><code>1.</code> 既然要括号匹配，那么奇数长度的字符串一定是不匹配的，而且后出现的符号先匹配，由此我们可以联想到栈后进先出的特点，所以这道题利用栈来解决；  <br/>
<code>2.</code> 遍历字符串，如果遇到了'(&lsquo; , &rsquo;[&lsquo; , &rsquo;{&lsquo;则将它们压栈，如果遇到&rsquo;)&lsquo; , &rsquo;]&lsquo; , &rsquo;}&lsquo;则判断它是否与栈顶元素匹配，如果匹配，则继续遍历字符串，否则返回false，说明它不匹配；当字符串遍历完了，判断栈是否为空，如果为空则括号匹配，如果不为空则括号不匹配。</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;
class Solution {
public:
    bool isValid(string s) {
        if (s.length()&lt;=0) {
            return true;
        }
        int n = (int)s.length();
        if (n%2!=0) {
            return false;
        }else{
            stack&lt;char&gt; stack;
            for (int i=0; i&lt;n; i++) {
                if (s[i]=='('||s[i]=='['||s[i]=='{') {
                    stack.push(s[i]);
                }
                if (!stack.empty()) {
                    if (s[i]==')') {
                        char top = stack.top();
                        if (top=='(') {
                            stack.pop();
                            continue;
                        }else{
                            return false;
                        }
                    }
                    else if (s[i]==']') {
                        char top = stack.top();
                        if (top=='[') {
                            stack.pop();
                            continue;
                        }else{
                            return false;
                        }
                    }
                    else if (s[i]=='}') {
                        char top = stack.top();
                        if (top=='{') {
                            stack.pop();
                            continue;
                        }else{
                            return false;
                        }
                    }
                }
            }
            if (stack.empty()) {
                return true;
            }else{
                return false;
            }
            ;
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栈的压入与弹出序列]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/07/ios35/"/>
    <updated>2016-02-07T11:28:41+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/07/ios35</id>
    <content type="html"><![CDATA[<h2>要求：</h2>

<p>给定压栈序列，如何判断弹栈序列是否合法，例如：  <br/>
压栈序列：1，2，3，4，5  <br/>
弹栈序列：4，5，3，2，1  就是合法  <br/>
弹栈序列：4，5，3，1，2  就是不合法</p>

<h2>做法：</h2>

<p><code>1.</code> 初始化一个栈s和指针k，k用于遍历压栈序列，遍历弹栈序列，如果s非空且弹栈序列元素与s栈顶元素相同，就弹栈；    <br/>
<code>2.</code> 如果上述条件不成立，遍历压栈序列，如果压栈序列元素与弹栈序列元素相同时，则k++，跳出当前循环；否则将压栈元素压入栈中，k++,继续遍历；当k大于等于数组长度时，则返回false；  <br/>
<code>3.</code> 如果压栈序列遍历完成，则返回true；</p>

<h2>代码如下：</h2>

<pre><code class="C++">
#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;
class Solution{
public:
    bool TestValidPushAndPop(int pushSequence[],int popSequence[],int n){
        int k = 0;
        stack&lt;int&gt; s;
        for (int i=0; i&lt;n; i++) {
            if (!s.empty()&amp;&amp;popSequence[i]==s.top()) {
                s.pop();
            }else{
                while (true) {
                    if (k &gt;= n) {
                        return false;
                    }else{
                        if (pushSequence[k]==popSequence[i]) {
                            k++;
                            break;
                        }else{
                            s.push(pushSequence[k]);
                            k++;
                        }
                    }
                }

            }
        }
        return true;
    }


};
int main(int argc, const char * argv[]) {
    Solution* s = new Solution();
    int push[] = {1,2,3,4,5};
    int pop[] = {4,5,3,2,1};
    cout&lt;&lt;s-&gt;TestValidPushAndPop(push, pop, 5)&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现一个带有min()函数的栈，在 O(1) 时间内取得最小元素]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/07/ios34/"/>
    <updated>2016-02-07T11:12:56+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/07/ios34</id>
    <content type="html"><![CDATA[<h2>要求：</h2>

<p>实现一个带有min()函数的栈，在 O(1) 时间内取得最小元素</p>

<h2>做法：</h2>

<p><code>1.</code> 定义两个栈，其中一个栈MinStack用于存储各个阶段的最小值；  <br/>
<code>2.</code> 当元素入栈时，对于普通栈只是正常压入，对于MinStack则先取得MinStack的栈顶元素与压栈元素比较，压入他们之中的较小者；  <br/>
<code>3.</code> 弹栈时，两个栈都弹栈；</p>

<h2>代码如下：</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;
class MinStack {
    stack&lt;int&gt; s;
    stack&lt;int&gt; minStack;
public:
    void push(int x) {
        if (s.empty()) {
            s.push(x);
            minStack.push(x);
        }else{
            s.push(x);
            int k = minStack.top();
            if (k&lt;=x) {
                minStack.push(k);
            }else{
                minStack.push(x);
            }
        }
    }

    void pop() {
        s.pop();
        minStack.pop();
    }

    int top() {
        return s.top();
    }

    int getMin() {
        return minStack.top();
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用栈实现队列]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/06/ios25/"/>
    <updated>2016-02-06T15:13:58+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/06/ios25</id>
    <content type="html"><![CDATA[<h2>C++库中的stack</h2>

<p>stack模板类的定义在stack头文件中  <br/>
stack的基本操作有：  <br/>
<code>1.</code> 入栈：s.push();  <br/>
<code>2.</code> 出栈：s.pop()，注意它不返回元素的值;  <br/>
<code>3.</code> 访问栈顶元素：s.top();  <br/>
<code>4.</code> 栈中元素的个数：s.size();  <br/>
<code>5.</code> 判断栈是否为空：s.empty();</p>

<h2>我们利用栈的这些特点来实现我们的队列</h2>

<p>做法如下:  <br/>
<code>1.</code> 用一个size来记录队列的容量，实现队列需要两个栈s1,s2;  <br/>
<code>2.</code> 入队时，我们将元素压入s1;  <br/>
<code>3.</code> 出队时，如果s2有元素，就弹出s2的栈顶元素;如果没有，则将s1中的所有元素弹出并压入s2中，再弹出s2的栈顶元素;  <br/>
<code>4.</code> 查看队头元素操作同上，只是不需要弹出s2的栈顶元素;  <br/>
代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

class Queue {
public:
    int size = 0;
    stack&lt;int&gt; s1;
    stack&lt;int&gt; s2;

    // Push element x to the back of queue.
    void push(int x) {
        s1.push(x);
        size++;
    }

    // Removes the element from in front of queue.
    void pop(void) {
        if (!s2.empty()) {
            s2.pop();
        }else{
            while (!s1.empty()) {
                int t = s1.top();
                s1.pop();
                s2.push(t);
            }
            s2.pop();
        }
        size--;
    }

    // Get the front element.
    int peek(void) {
        if (!s2.empty()) {
            return s2.top();
        }else{
            while (!s1.empty()) {
                int t = s1.top();
                s1.pop();
                s2.push(t);
            }
            return s2.top();
        }
    }

    // Return whether the queue is empty.
    bool empty(void) {
        if (size==0) {
            return true;
        }else{
            return false;
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用队列实现栈]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/06/ios24/"/>
    <updated>2016-02-06T14:50:43+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/06/ios24</id>
    <content type="html"><![CDATA[<h2>C++库中的queue:</h2>

<p>queue 模板类的定义在queue头文件中  <br/>
queue 的基本操作有：  <br/>
<code>1.</code> 入队：q.push(x);  <br/>
<code>2.</code> 出队：q.pop(),注意它不返回元素的值;  <br/>
<code>3.</code> 访问队首元素： q.front();  <br/>
<code>4.</code> 访问队尾元素： q.back();  <br/>
<code>5.</code> 队列的元素个数： q.size();  <br/>
<code>6.</code> 判断队列是否为空： q.empty();</p>

<h2>我们利用队列的这些特点来实现我们的栈</h2>

<p>做法如下：  <br/>
<code>1.</code> 用一个size来记录栈的容量，实现栈需要利用两个队列q1、q2;  <br/>
<code>2.</code> 压栈时，将元素插入到非空队列里;  <br/>
<code>3.</code> 弹栈时，先取得非空队列q1，弹出元素插入到空队列q2中，直到只剩下最后一个元素，弹栈就是弹出这个元素，且不插入到q2中;  <br/>
<code>4.</code> 查看栈顶元素，操作同上，只是最后那个元素最终要插入到q2中;      <br/>
代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
class Stack {
    int size=0;
    queue&lt;int&gt; q1;
    queue&lt;int&gt; q2;
public:
    // Push element x onto stack.
    void push(int x) {
        if (empty()||!q1.empty()) {
            q1.push(x);
        }else{
            q2.push(x);
        }
        size++;
    }

    // Removes the element on top of the stack.
    void pop() {
        if (!q1.empty()) {
            while (q1.size()&gt;1) {
                int a = q1.front();
                q1.pop();
                q2.push(a);
            }
            q1.pop();
        }else{
            while (q2.size()&gt;1) {
                int a = q2.front();
                q2.pop();
                q1.push(a);
            }
            q2.pop();
        }
        size--;
    }

    // Get the top element.
    int top() {
        if (!q1.empty()) {
            return q1.back();
        }else{
            return q2.back();
        }
    }

    // Return whether the stack is empty.
    bool empty() {
        if (size==0) {
            return true;
        }else{
            return false;
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
