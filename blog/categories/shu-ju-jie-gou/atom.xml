<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-05T21:02:18+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[删除链表中倒数第n个元素]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/05/ios74/"/>
    <updated>2016-03-05T20:48:54+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/05/ios74</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>删除链表中倒数第n个元素，例如1->2->3->4->5->6,n=2,返回1->2->3->4->6</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if (head==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;
            ListNode* pre = newHead;
            ListNode* p = newHead;
            for (int i=0; i&lt;n; i++) {
                p = p-&gt;next;
            }
            while (p-&gt;next!=NULL) {
                pre = pre-&gt;next;
                p = p-&gt;next;
            }
            pre-&gt;next = pre-&gt;next-&gt;next;
            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删除链表元素]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/05/ios73/"/>
    <updated>2016-03-05T20:20:46+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/05/ios73</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>删除链表中值为val的结点，例如：1->2->3->4->5->NULL,val = 4,返回1->2->3->5->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace::std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;
            ListNode* pre = newHead;
            ListNode* p = newHead-&gt;next;
            while (p!=NULL) {
                if (p-&gt;val == val) {
                    pre-&gt;next = p-&gt;next;
                    p = p-&gt;next;

                }else{
                    pre = pre-&gt;next;
                    p = p-&gt;next;
                }
            }
            return newHead-&gt;next;
        }
    }
};

int main(int argc, const char * argv[]) {

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻转链表中的一部分]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios72/"/>
    <updated>2016-03-04T22:23:26+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios72</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>翻转链表的第m到第n部分，例如：1->2->3->4->5->NULL,m=2,n=4,返回1->4->3->2->5->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace::std;


struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:


    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else if (m==n){
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;

            //first为第m-1个结点
            ListNode* first = newHead;
            for (int i=1; i&lt;m; i++) {
                first = first-&gt;next;
            }


            ListNode* pre = first-&gt;next;
            ListNode* p = pre-&gt;next;
            ListNode* next = NULL;

            //top为第m个结点，也是翻转部分翻转后的尾结点
            ListNode* top = pre;
            for (int i =m; i&lt;n; i++) {
                next = p-&gt;next;
                p-&gt;next = pre;
                pre = p;
                p = next;
            }
            //这时候p为第n+1个结点，pre为翻转部分翻转后的头结点

            top-&gt;next = p;
            first-&gt;next = pre;

            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[旋转链表]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios70/"/>
    <updated>2016-03-04T21:18:17+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios70</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个链表1->2->3->4->5->NULL和一个k=2，返回4->5->1->2->3->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    int length(ListNode* head){
        int count = 0;
        ListNode* p = head;
        while (p!=NULL) {
            count++;
            p = p-&gt;next;
        }
        return count;
    }
    ListNode* rotateRight(ListNode* head, int k) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else if(k==0){
            return head;
        }else{
            int n = length(head);
            //如果k大于链表长度则取余
            k = k%n;
            if (k==0) {
                return head;
            }

            //关键步骤
            ListNode* p = head;
            for (int i =0; i&lt;n-k-1; i++) {
                p = p-&gt;next;
            }

            //取得新链表的头和尾
            ListNode* newEnd = p;
            ListNode* newHead = p-&gt;next;

            while (p-&gt;next!=NULL) {
                p = p-&gt;next;
            }
            ListNode* touch = p;
            touch-&gt;next = head;
            newEnd-&gt;next = NULL;
            return newHead;
        }
    }
};
int main(int argc, const char * argv[]) {

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表成对交换问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios69/"/>
    <updated>2016-03-04T20:58:34+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios69</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个链表1->2->3->4,你会返回2->1->4->3</p>

<h2>代码实现</h2>

<pre><code class="C++">
#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            ListNode* pre = head;
            ListNode* p = pre-&gt;next;
            ListNode* next = NULL;
            ListNode* nh = newHead;
            while (p!=NULL) {
                next = p-&gt;next;
                p-&gt;next = pre;
                pre-&gt;next = next;
                nh-&gt;next = p;
                nh = pre;
                if (next==NULL) {
                    break;
                }
                pre = next;
                p = pre-&gt;next;

            }
            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
