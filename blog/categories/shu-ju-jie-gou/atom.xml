<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-04T21:30:43+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[旋转链表]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios70/"/>
    <updated>2016-03-04T21:18:17+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios70</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个链表1->2->3->4->5->NULL和一个k=2，返回4->5->1->2->3->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    int length(ListNode* head){
        int count = 0;
        ListNode* p = head;
        while (p!=NULL) {
            count++;
            p = p-&gt;next;
        }
        return count;
    }
    ListNode* rotateRight(ListNode* head, int k) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else if(k==0){
            return head;
        }else{
            int n = length(head);
            //如果k大于链表长度则取余
            k = k%n;
            if (k==0) {
                return head;
            }

            //关键步骤
            ListNode* p = head;
            for (int i =0; i&lt;n-k-1; i++) {
                p = p-&gt;next;
            }

            //取得新链表的头和尾
            ListNode* newEnd = p;
            ListNode* newHead = p-&gt;next;

            while (p-&gt;next!=NULL) {
                p = p-&gt;next;
            }
            ListNode* touch = p;
            touch-&gt;next = head;
            newEnd-&gt;next = NULL;
            return newHead;
        }
    }
};
int main(int argc, const char * argv[]) {

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表成对交换问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios69/"/>
    <updated>2016-03-04T20:58:34+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios69</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个链表1->2->3->4,你会返回2->1->4->3</p>

<h2>代码实现</h2>

<pre><code class="C++">
#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            ListNode* pre = head;
            ListNode* p = pre-&gt;next;
            ListNode* next = NULL;
            ListNode* nh = newHead;
            while (p!=NULL) {
                next = p-&gt;next;
                p-&gt;next = pre;
                pre-&gt;next = next;
                nh-&gt;next = p;
                nh = pre;
                if (next==NULL) {
                    break;
                }
                pre = next;
                p = pre-&gt;next;

            }
            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图多源最短路径问题(Floyd算法)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/29/ios67/"/>
    <updated>2016-02-29T21:54:48+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/29/ios67</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>求图多源最短路径问题有一种简洁优雅的算法&ndash;Floyd算法。</p>

<h2>做法</h2>

<p><code>1.</code> 定义一个二维数组dist，dist[i][j]代表i到j的最短路径，如果i和j不可达，就初始化为无穷大，为了方便计算，我这里设为9999。  <br/>
<code>2.</code> 定义一个二维数组next，next[i][j]代表i到j这条路径中i的下一个站点，如果i和j不可达，就初始化为-1。  <br/>
<code>3.</code> 我们假设所有点经过k一定会到达另一个点，i到j如果可达，那么它有两条路径i->j和i->k—>j，我们通过比较这两条路径的大小来决定dist[i][j]的值，我们可以转化为一个动态方程来理解下：  <br/>
dist[i][j] = Min{dist[i][j],dist[i][k]+dist[k][j]}  <br/>
<code>4.</code> 同时我们还要记录next[i][j]的值，如果经过k的路径比较短，那么next[i][j] = next[i][k]</p>

<h2>代码如下</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

/**
 * 利用了动态规划
 * 时间复杂度为O(n^3)
 **/
void floyd(vector&lt;vector&lt;int&gt;&gt; &amp;dist,vector&lt;vector&lt;int&gt;&gt; &amp;next){
    size_t size = dist.size();
    for (int k = 0; k&lt;size; k++) {
        for (int i = 0; i &lt;size; i++) {
            for (int j = 0; j&lt;size; j++) {
                if (dist[i][k]+dist[k][j]&lt;dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }
}


void printPath(int i,int j,vector&lt;vector&lt;int&gt;&gt; &amp;next){
    if (next[i][j]==-1) {
        cout&lt;&lt;i&lt;&lt;" to "&lt;&lt;j&lt;&lt;" no path"&lt;&lt;endl;
        return;
    }
    cout&lt;&lt;i;
    while (i!=j) {
        i = next[i][j];
        cout&lt;&lt;"-&gt;"&lt;&lt;i;
    }
    cout&lt;&lt;endl;
}

int main(int argc, const char * argv[]) {
    vector&lt;vector&lt;int&gt;&gt; dist =
    {
        {0,9999,-2,9999},
        {4,0,3,9999},
        {9999,9999,0,2},
        {9999,-1,9999,0}

    };

    vector&lt;vector&lt;int&gt;&gt; next =
    {
        {-1,-1,2,-1},
        {0,-1,2,-1},
        {-1,-1,-1,3},
        {-1,1,-1,-1}
    };

    floyd(dist, next);

    for (int i = 0; i&lt;dist.size(); i++) {
        for (int j = 0; j&lt;dist.size(); j++) {
            cout&lt;&lt;dist[i][j]&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
    }
    cout&lt;&lt;endl;

    for (int i = 0; i&lt;dist.size(); i++) {
        for (int j = 0; j&lt;dist.size(); j++) {
            printPath(i, j, next);
        }
        cout&lt;&lt;endl;
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最长公共子串]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/26/ios64/"/>
    <updated>2016-02-26T16:02:00+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/26/ios64</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>它比最长公共子序列多了一个要求，就是要求子串是连续的，做法跟最长公共子序列的做法大致相同，只是在一处判断的处理改变了。</p>

<h2>做法</h2>

<p>定义一个二维数组C[i][j],记录str1(0~i)和str2(0~j)的最长公共子串。  <br/>
定义一个max，记录填表过程中出现的最大值。</p>

<h5>动态方程</h5>

<p>if str1[i] == str2[j]  <br/>
    c[i][j] = c[i-1][j-1] + 1;  <br/>
if str1[i] != str2[j]  <br/>
    c[i][j] = 0; //因为i和j位置上面的字符不等，那么到该位置公共子串就不连续，所以此时的最长公共子串的长度为0</p>

<h2>代码如下</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;

int lcs(char a[],char b[],int n,int m){
    if (n==0||m==0) {
        return 0;
    }else{
        int count[n+1][m+1];
        int max = 0;
        memset(count, 0, sizeof(count));
        for (int i=1; i&lt;=n; i++) {
            for (int j=1; j&lt;=m; j++) {
                if (a[i-1]==b[j-1]) {
                    count[i][j] = count[i-1][j-1]+1;
                    if (count[i][j]&gt;max) {
                        max = count[i][j];
                    }
                }else{
                    count[i][j] = 0;
                }
           }
        }
        return max;
    }

}




int main(int argc, const char * argv[]) {
    char a[] = "abccbd";
    char b[] = "bbccbd";
    cout&lt;&lt;lcs(a,b,6,6)&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用哈希表的思想实现字符串匹配函数]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/24/ios62/"/>
    <updated>2016-02-24T20:23:48+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/24/ios62</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>C语言有一个字符串匹配函数strstr(const char<em> source,const char</em> pattern)，可以获取匹配字符串在源字符串的位置。我们今天利用哈希表的思想来实现这个函数。</p>

<h4>例子</h4>

<p>源字符串：“abccbasd”
匹配字符串：“ccba”</p>

<h4>做法</h4>

<p>我们可以求出匹配字符串的hashCode，至于如何求，我们可以定义自己的哈希函数，我们可以仿照Java标准库中字符串hashcode的求法，例如“abc”的hashcode等于（'a'*31+&lsquo;b'）*31+'c&rsquo; = 96354。我们根据我们自己的哈希函数求出匹配字符串的hashcode，接着我们遍历我们的源字符串，一开始是“abcc”，我们求出它的hashcode，如果他的hashcode跟匹配字符串相同，则遍历字符串看每一位是否相同，如果不同，则遍历下一串字符串“bccb”，判断方法如上，当遍历到“ccba”位置时，跟匹配字符串一样，返回匹配字符串的位置。</p>

<h2>代码如下</h2>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;string&gt;
#define PRIM_BASE 31
using namespace std;
/**
*计算hashcode的方法跟上面例子的方法一样
*最坏时间复杂度为O(n-m)*m
**/
int rolling_hashCode_Strstr(const string &amp;source,const string &amp;pattern){
    unsigned source_code = 0;
    unsigned pattern_code = 0;
    unsigned pow = 1;
    size_t n = source.length();
    size_t m = pattern.length();

    for (int i=0; i &lt;m; i++) {
        source_code = source_code*PRIM_BASE+source[i];
        pattern_code = pattern_code*PRIM_BASE+pattern[i];
        pow = pow*PRIM_BASE;
    }
    if (source_code==pattern_code&amp;&amp;source.substr(0,m)==pattern) {
        return 0;
    }else{
        for (int i = (int)m; i&lt;n; i++) {
            source_code = source_code*PRIM_BASE+source[i];
            source_code = source_code - pow*source[i-m];
            if (source_code==pattern_code&amp;&amp;source.substr(i-m+1,m)==pattern) {
                return i-(int)m+1;
            }
        }

    }
    return -1;
}



int main(int argc, const char * argv[]) {
    cout&lt;&lt;rolling_hashCode_Strstr("abcdjdbsuad", "djdb")&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
