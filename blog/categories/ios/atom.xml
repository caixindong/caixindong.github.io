<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-05-13T11:38:10+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Runtime小笔记（二）]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/13/ios88/"/>
    <updated>2016-05-13T09:23:18+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/13/ios88</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>上篇主要讲Runtime的一些术语描述和定义，Runtime的主要应用是用于消息的传递，今天会结合一些实战例子来讲下OC的消息传递机制。</p>

<h2>普通消息传递</h2>

<p>在OC里，对象调用方法叫作发送消息，对象调用方法在Runtime里被转化为objc_msgSend函数来实现</p>

<pre><code class="ObjC">
[receiver oneMethod];
//transfer to ：
objc_msgSend(receiver, @selector(oneMethod));
</code></pre>

<h3>Runtime会根据类型自动转换为下列某个函数：</h3>

<p><strong>objc_msgSend</strong>：普通的消息都会通过该函数发送；  <br/>
<strong>objc_msgSend_stret</strong>：消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值；  <br/>
<strong>objc_msgSendSuper</strong>：和objc_msgSend类似，这里把消息发送给父类的实例；  <br/>
<strong>objc_msgSendSuper_stret</strong>：和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值；</p>

<h3>objc_msgSend的调用过程</h3>

<p><code>1.</code> 先检查这个selector是否存在，不存在则忽略；   <br/>
<code>2.</code> 接着检查selector的target是否为nil，向nil对象发送任何消息都会被忽略掉；  <br/>
<code>3.</code> 前面两步没问题，则先在isa指针指向的class的cache里面找有没有方法调用记录，如果有，则运行对应的函数，如果没有则在class的methodLists查找方法，没有则通过super_class指针找到父类的类对象结构体，然后从methodLists查找方法，如果仍找不到，则继续通过
super_class向上一级父类结构体中查找，直到根类（NSObject）；  <br/>
<code>4.</code> 如果还是找不到，则进入<strong>消息动态解析</strong>；</p>

<h2>消息动态解析</h2>

<p>动态解析流程图：
<img src="/images/objective-runtime-6.png"></p>

<p>具体解析：  <br/>
<code>1.</code> 通过resolveInstanceMethod，该方法决定是否动态添加方法。如果返回YES，则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回NO，则进入下一步；   <br/>
<code>2.</code> 这一步会步入forwardingTargetForSelector方法，用于指定备选对象响应这个selector，不能指定为self，如果放回某个对象则会调用对象的方法，结束。如果放回nil，则进入第三步；  <br/>
<code>3.</code> 这一步，我们通过methodSignatureForSelector进行方法签名，如果返回nil，则消息无法处理。如果返回methodSignature则进入下一步；  <br/>
<code>4.</code> 这步调用forwardInvocation方法，我们通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象，如果方法方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector，如果没有实现这个方法会crash</p>

<h2>实战</h2>

<h3>通过runtime动态创建类和对象</h3>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;
void sayFunction(id self, SEL _cmd, id some){

    NSLog(@"%@岁的%@说：%@",object_getIvar(self, class_getInstanceVariable([self class], "_age")),object_getIvar(self, class_getInstanceVariable([self class], "_name")),some);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //动态创建类
        Class MyPeople = objc_allocateClassPair([NSObject class], "Person", 0);

        //为类添加成员变量
        class_addIvar(MyPeople, "_name", sizeof(NSString*), log2(sizeof(NSString*)), @encode(NSString*));
        class_addIvar(MyPeople, "_age", sizeof(int),sizeof(int),@encode(int));

        //注册方法（"v@:@"代表返回值+参数列表）
        SEL say = sel_registerName("say:");
        class_addMethod(MyPeople, say, (IMP)sayFunction, "v@:@");

        //注册类
        objc_registerClassPair(MyPeople);

        //创建实例对象
        id peopleInstance = [[MyPeople alloc]init];

        [peopleInstance setValue:@"李明" forKey:@"name"];

        //获取成员变量
        Ivar age = class_getInstanceVariable(MyPeople, "_age");
        object_setIvar(peopleInstance, age, @18);

        //发送消息
        objc_msgSend(peopleInstance,say,@"你好呀");

        //销毁实例对象
        peopleInstance = nil;

        //当类或子类的实例存在，则不能销毁类
        objc_disposeClassPair(MyPeople);
    }
    return 0;
}
</code></pre>

<p><strong>tip：</strong>
默认会出现以下错误：  <br/>
objc_msgSend()报错Too many arguments to function call ,expected 0,have3
直接通过objc_msgSend(self, setter, value)是报错，说参数过多。  <br/>
请这样解决：
Build Setting–> Apple LLVM 7.0 – Preprocessing–> Enable Strict Checking of objc_msgSend Calls 改为 NO</p>

<h3>通过runtime获取类的相关信息(属性、实例变量、方法)</h3>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject{

    NSString* _nationality;

}

@property(nonatomic,copy)NSString* name;
@property(nonatomic,strong)NSNumber* age;

/**
 * 获取所有属性
 **/
-(NSDictionary*)getAllProperties;

/**
 * 获取所有实例变量
 **/
-(NSDictionary*)getAllIvars;


/**
 * 获取所有方法
 **/
-(NSDictionary*)getAllMethods;

@end
</code></pre>

<pre><code class="ObjC">#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

@implementation People


-(NSDictionary *)getAllProperties{
    unsigned int count = 0;
    NSMutableDictionary* result = [@{} mutableCopy];
    objc_property_t* properties = class_copyPropertyList([self class], &amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        const char* propertyName = property_getName(properties[i]);
        NSString* name = [NSString stringWithUTF8String:propertyName];
        id propertyValue = [self valueForKey:name];
        if (propertyValue) {
            result[name] = propertyValue;
        }else{
            result[name] = @"value 不能为 nil";
        }


    }
    free(properties);

    return result;
}

-(NSDictionary *)getAllIvars{
    unsigned int count = 0;
    NSMutableDictionary* result = [@{} mutableCopy];
    Ivar* ivars = class_copyIvarList([self class], &amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        const char* ivarName = ivar_getName(ivars[i]);
        NSString* name = [NSString stringWithUTF8String:ivarName];
        id value = [self valueForKey:name];
        if (value) {
            result[name] = value;
        }else{
            result[name] = @"value 不能为 nil";
        }
    }
    free(ivars);
    return  result;
}

-(NSDictionary*)getAllMethods{
    unsigned int count = 0;
    NSMutableDictionary* result = [@{} mutableCopy];
    Method* methods = class_copyMethodList([self class], &amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        const char* methodName = sel_getName(method_getName(methods[i]));
        NSString* name = [NSString stringWithUTF8String:methodName];
        //获取参数列表
        int args = method_getNumberOfArguments(methods[i]);
        result[name] = [NSString stringWithFormat:@"args count is %d",args-2 ];
    }
    free(methods);
    return result;
}
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "People.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        People* p = [[People alloc]init];
        p.name = @"罗大锤";
        p.age = @(30);
        [p setValue:@"中国" forKey:@"nationality"];
        NSDictionary* properties = [p getAllProperties];
        NSDictionary* ivars = [p getAllIvars];
        NSDictionary* methods = [p getAllMethods];
        NSLog(@"属性为：%@",properties);
        NSLog(@"实例变量：%@",ivars);
        NSLog(@"方法：%@",methods);
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:22:36.298 runtime 之 获取类的相关信息(属性、实例变量、方法)[2783:307932] 属性为：{
    age = 30;
    name = "\U7f57\U5927\U9524";
}
2016-05-13 11:22:36.299 runtime 之 获取类的相关信息(属性、实例变量、方法)[2783:307932] 实例变量：{
    "_age" = 30;
    "_name" = "\U7f57\U5927\U9524";
    "_nationality" = "\U4e2d\U56fd";
}
2016-05-13 11:22:36.299 runtime 之 获取类的相关信息(属性、实例变量、方法)[2783:307932] 方法：{
    ".cxx_destruct" = "args count is 0";
    age = "args count is 0";
    getAllIvars = "args count is 0";
    getAllMethods = "args count is 0";
    getAllProperties = "args count is 0";
    name = "args count is 0";
    "setAge:" = "args count is 1";
    "setName:" = "args count is 1";
}
Program ended with exit code: 0
</code></pre>

<h3>通过Runtime给category添加属性</h3>

<pre><code class="ObjC">
#import "People.h"

typedef void(^CallBackSomething)();

@interface People (testCategory)

@property(nonatomic,copy)NSString* address;
@property(nonatomic,copy)CallBackSomething block;
@end
</code></pre>

<pre><code class="ObjC">#import "People+testCategory.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;


@implementation People (testCategory)

-(void)setAddress:(NSString *)address{
    objc_setAssociatedObject(self, @selector(address), address, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

-(NSString *)address{
    return objc_getAssociatedObject(self, @selector(address));
}

-(void)setBlock:(CallBackSomething)block{
    objc_setAssociatedObject(self, @selector(block), block, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

-(CallBackSomething)block{
    return objc_getAssociatedObject(self, @selector(block));
}

@end
</code></pre>

<h3>利用Runtime给对象归档和解档</h3>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject&lt;NSCoding&gt;{

    NSString* _nationality;

}

@property(nonatomic,copy)NSString* name;
@property(nonatomic,strong)NSNumber* age;
@end
</code></pre>

<pre><code class="ObjC">#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

@implementation People

//归档
-(void)encodeWithCoder:(NSCoder *)aCoder{
    unsigned int count = 0;
    Ivar* ivars = class_copyIvarList([self class],&amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        Ivar ivar = ivars[i];
        const char* name = ivar_getName(ivar);
        NSString* key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [aCoder encodeObject:value forKey:key];
    }
    free(ivars);
}

//解档
-(instancetype)initWithCoder:(NSCoder *)aDecoder{
    if (self = [super init]) {
        unsigned int count = 0;
        Ivar* ivars = class_copyIvarList([self class],&amp;count);
        for (NSUInteger i = 0; i&lt;count; i++) {
            Ivar ivar = ivars[i];
            const char* name = ivar_getName(ivar);
            NSString* key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];
            [self setValue:value forKey:key];
        }
        free(ivars);
    }
    return self;
}

@end
</code></pre>

<h3>利用Runtime实现Model与字典互转</h3>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject

@property(nonatomic,copy)NSString* name;
@property(nonatomic,strong)NSNumber* age;


/**
 * 字典 转 Model
 **/
-(instancetype)initWithDictionary:(NSDictionary*) dict;

/**
 * Model转换成字典
 **/
-(NSDictionary*)covertToDictionary;
@end
</code></pre>

<pre><code class="ObjC">#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

@implementation People




-(instancetype)initWithDictionary:(NSDictionary *)dict{
    if (self = [super init]) {
        for (NSString* key in dict) {
            id val = dict[key];
            SEL setter = [self propertySetterByKey:key];
            if (setter) {
                objc_msgSend(self, setter,val);
            }
        }
    }
    return self;
}

-(NSDictionary *)covertToDictionary{
    unsigned int count = 0;
    objc_property_t* properties = class_copyPropertyList([self class], &amp;count);

    if (count!=0) {
        NSMutableDictionary* result = [@{} mutableCopy];
        for (NSUInteger i = 0; i&lt;count; i++) {
            const char * propertyName = property_getName(properties[i]);
            NSString* name = [NSString stringWithUTF8String:propertyName];

            SEL getter = [self propertyGetterByKey:name];
            if (getter) {
                id value = objc_msgSend(self, getter);
                if (value) {
                    result[name] = value;
                }else{
                    result[name] = @"value 为 nil";
                }
            }
        }
        free(properties);
        return result;
    }
    free(properties);
    return nil;
}

#pragma mark - 生成setter
-(SEL)propertySetterByKey:(NSString*)key{
    //key的首字母大写
    NSString* propertySetterName = [NSString stringWithFormat:@"set%@:",key.capitalizedString];
    SEL setter = NSSelectorFromString(propertySetterName);
    if ([self respondsToSelector:setter]) {
        return setter;
    }
    return nil;
}

-(SEL)propertyGetterByKey:(NSString*)key{
    SEL getter = NSSelectorFromString(key);
    if ([self respondsToSelector:getter]) {
        return getter;
    }
    return nil;
}

@end
</code></pre>

<h3>消息动态解析（一）</h3>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject

@property(nonatomic,copy)NSString* name;

/** m文件不实现方法，通过runtime动态添加方法
 *  通过resolveInstanceMethod：方法决定是否动态添加方法。
    如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No
 **/
-(void)sing;

@end
</code></pre>

<pre><code class="ObjC">
#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;


@implementation People

+(BOOL)resolveInstanceMethod:(SEL)sel{
    if ([NSStringFromSelector(sel) isEqualToString:@"sing"]) {
        class_addMethod([self class], sel, (IMP)otherIMP, "V@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

void otherIMP(id self ,SEL cmd){
    NSLog(@"%@正在唱歌",((People*)self).name);
}

@end
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "People.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        People* p = [[People alloc]init];
        p.name = @"张全蛋";
        [p sing];
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:24:16.905 runtime 之 消息动态解析(一)[2819:311517] 张全蛋正在唱歌
Program ended with exit code: 0
</code></pre>

<h3>消息动态解析（二）</h3>

<p>修改Bird唱歌方法的调用对象</p>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;

@interface Bird : NSObject
@property(nonatomic,copy)NSString* name;
-(void)sing;
@end
</code></pre>

<pre><code class="ObjC">#import "Bird.h"
#import "People.h"
@implementation Bird


//第一步，不动态添加方法
+(BOOL)resolveInstanceMethod:(SEL)sel{
    return NO;
}

//第二步，不指定备选对象响应sselector
-(id)forwardingTargetForSelector:(SEL)aSelector{

    return nil;
}

//第三步，返回方法签名
-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    if ([NSStringFromSelector(aSelector) isEqualToString:@"sing"]) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

//第四部，修改调用对象
-(void)forwardInvocation:(NSInvocation *)anInvocation{
    People* p = [[People alloc]init];
    p.name = @"张铁柱";
    [anInvocation invokeWithTarget:p];
}
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "Bird.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Bird* b = [[Bird alloc]init];
        b.name = @"小鸟";
        [b sing];
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:29:58.335 runtime 之 消息动态解析(二)[2963:322829] 张铁柱正在唱歌
Program ended with exit code: 0
</code></pre>

<h3>消息动态解析（三）</h3>

<p>修改Person唱歌方法的实现</p>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject
-(void)sing;
@end
</code></pre>

<pre><code class="ObjC">#import "People.h"

@implementation People

//不动态添加方法
+(BOOL)resolveInstanceMethod:(SEL)sel{
    return NO;
}

//不指定备选响应对象
-(id)forwardingTargetForSelector:(SEL)aSelector{
    return nil;
}

//返回方法签名
-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    if ([NSStringFromSelector(aSelector) isEqualToString:@"sing"]) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

//修改调用方法
-(void)forwardInvocation:(NSInvocation *)anInvocation{
    [anInvocation setSelector:@selector(dance)];
    [anInvocation invokeWithTarget:self];
}

//若不实现forwardInvocation，则会调用此方法(可以注释掉forwardInvocation方法来做实验)
-(void)doesNotRecognizeSelector:(SEL)aSelector{
    NSLog(@"消息无法处理:%@",NSStringFromSelector(aSelector));
}

-(void)dance{
    NSLog(@"跳舞中");
}

@end
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        People* p = [[People alloc]init];
        [p sing];
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:33:01.871 runtime 之 消息动态解析(三)[3073:329356] 跳舞中
Program ended with exit code: 0
</code></pre>

<p><a href="https://github.com/caixindong/SomeDemoForYou/tree/master/RuntimeDemo">以上demo地址</a></p>

<p>参考文章：  <br/>
<a href="https://www.ianisme.com/ios/2019.html">Objective-C Runtime 1小时入门教程</a>  <br/>
<a href="http://www.jianshu.com/p/1e06bfee99d0">详解Runtime运行时机制</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime小笔记（一）]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/11/ios87/"/>
    <updated>2016-05-11T21:52:03+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/11/ios87</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>之前看过关于runtime的几篇文章，水平各有千秋，现在先汇集各个大牛的总结，以后找个时间将Runtime的<a href="http://opensource.apple.com//source/objc4/">源码</a>啃一遍，再完善自己的笔记</p>

<h2>什么是Runtime</h2>

<p>Objective-C Runtime是一个将C语言转化为面向对象语言的扩展。  <br/>
C++和Objective进行对比：  <br/>
<code>同 ：</code> C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言；  <br/>
<code>异 ：</code> 实现的机制差异不同。C++是基于静态类型，而Objective-C是基于动态运行时类型。也就是说用C++编写的程序编译时就直接编译成了可令机器读懂的机器语言；用Objective-C编写的程序不能直接编译成可令机器读懂的机器语言，而是在程序运行的时候，通过Runtime把程序转为可令机器读懂的机器语言。Runtime是Objective不可缺少的重要一部分；</p>

<h2>一些 Runtime 的术语</h2>

<h3>id 和 Class</h3>

<pre><code class="ObjC">#if !OBJC_TYPES_DEFINED
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;

/// Represents an instance of a class.
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
#endif
</code></pre>

<p>Class是一个指向<strong>==objc_class==</strong>结构体的指针；  <br/>
id是一个指向<strong>==objc_object==</strong>结构体的指针，其中的<strong>==isa==</strong>是一个指<strong>==objc_class==</strong>结构体的指针。  <br/>
换句话说，id就是我们所说的对象，Class就是我们所说的类。</p>

<h4>objc_class的定义</h4>

<pre><code class="ObjC">typedef struct objc_class *Class;
struct objc_class { 
 Class isa                                 OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
 Class super_class                         OBJC2_UNAVAILABLE; 
 const char *name                          OBJC2_UNAVAILABLE; 
 long version                              OBJC2_UNAVAILABLE; 
 long info                                 OBJC2_UNAVAILABLE; 
 long instance_size                        OBJC2_UNAVAILABLE; 
 struct objc_ivar_list *ivars              OBJC2_UNAVAILABLE;
 struct objc_method_list **methodLists     OBJC2_UNAVAILABLE; 
 struct objc_cache *cache                  OBJC2_UNAVAILABLE; 
 struct objc_protocol_list *protocols      OBJC2_UNAVAILABLE; 
#endif
}
/* Use `Class` instead of `struct objc_class *` */
</code></pre>

<p>isa指针：指向的类结构称为metaclass(元类)，其中存放着static类型的成员变量与类方法（“+”开头的方法）；  <br/>
super_class：指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil；  <br/>
name：类名；  <br/>
version：类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取；  <br/>
info：类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；  <br/>
instance_size：该类的实例变量大小（包括从父类继承下来的实例变量）；   <br/>
ivars：该类的成员变量地址列表；    <br/>
methodLists：方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法；  <br/>
cache：缓存最近使用的方法地址，用于提升效率；  <br/>
protocols：存储该类声明遵守的协议的列表；</p>

<p>类与对象的继承层次关系如图：  <br/>
<img src="/images/objective-runtime.png"></p>

<p>所有的metaclass中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。</p>

<h3>SEL</h3>

<p>SEL是方法选择器，作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现</p>

<pre><code class="ObjC">typedef struct objc_selector *SEL;

struct objc_selector {
    char *name;                       OBJC2_UNAVAILABLE;// 方法名
    char *types;                      OBJC2_UNAVAILABLE;// 方法类型
};
</code></pre>

<h3>IMP</h3>

<p>IMP是由编译器生成的一个函数指针，指向方法的实现。当你发起一个消息后，这个函数指针决定了最终执行哪段代码。</p>

<pre><code class="ObjC">typedef id (*IMP)(id, SEL, ...);
</code></pre>

<h3>Method</h3>

<p>Method代表类中的某个方法的类型。</p>

<pre><code class="ObjC">typedef struct objc_method *Method;

struct objc_method {
    SEL method_name                   OBJC2_UNAVAILABLE; // 方法名
    char *method_types                OBJC2_UNAVAILABLE; // 方法类型,存储着方法的参数类型和返回值类型
    IMP method_imp                    OBJC2_UNAVAILABLE; // 方法实现
}
</code></pre>

<h3>Ivar</h3>

<p>Ivar代表类中实例变量的类型</p>

<pre><code class="ObjC">typedef struct objc_ivar *Ivar;

struct objc_ivar {
    char *ivar_name                   OBJC2_UNAVAILABLE; // 变量名
    char *ivar_type                   OBJC2_UNAVAILABLE; // 变量类型
    int ivar_offset                   OBJC2_UNAVAILABLE; // 基地址偏移字节
#ifdef __LP64__
    int space                         OBJC2_UNAVAILABLE; // 占用空间
#endif
}
</code></pre>

<h3>objc_property_t</h3>

<p>objc_property_t是属性,是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下</p>

<pre><code class="ObjC">typedef struct objc_property *objc_property_t;

typedef struct {
    const char *name; // 名称
    const char *value;  // 值（通常是空的）
} objc_property_attribute_t;
</code></pre>

<h3>Cache</h3>

<p>方法地址缓存</p>

<pre><code class="ObjC">typedef struct objc_cache *Cache

struct objc_cache {
    unsigned int mask                   OBJC2_UNAVAILABLE;
    unsigned int occupied               OBJC2_UNAVAILABLE;
    Method buckets[1]                   OBJC2_UNAVAILABLE;
};
</code></pre>

<p><code>mask</code>： 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。  <br/>
<code>occupied</code>： 实际占用cache buckets的总数。  <br/>
<code>buckets</code>： 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。  <br/>
objc_msgSend每调用一次方法后，就会把该方法缓存到cache列表中，下次调用的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。</p>

<h3>Catagory</h3>

<p>这个就是我们平时所说的类别了,它可以动态的为已存在的类添加新的方法。</p>

<pre><code class="ObjC">typedef struct objc_category *Category;

struct objc_category {
    char *category_name                           OBJC2_UNAVAILABLE; // 类别名称
    char *class_name                              OBJC2_UNAVAILABLE; // 类名
    struct objc_method_list *instance_methods     OBJC2_UNAVAILABLE; // 实例方法列表
    struct objc_method_list *class_methods        OBJC2_UNAVAILABLE; // 类方法列表
    struct objc_protocol_list *protocols          OBJC2_UNAVAILABLE; // 协议列表
}
</code></pre>

<p>参考文章：  <br/>
<a href="https://www.ianisme.com/ios/2019.html">Objective-C Runtime 1小时入门教程</a>  <br/>
<a href="http://www.jianshu.com/p/1e06bfee99d0">详解Runtime运行时机制</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAShapeLayer与UIBezierPath]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/07/ios86/"/>
    <updated>2016-05-07T21:06:22+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/07/ios86</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><code>1.</code> UIBezierPath： UIBezierPath是在 UIKit 中的一个类，继承于NSObject,可以创建基于矢量的路径.此类是Core Graphics框架关于path的一个OC封装。使用此类可以定义常见的圆形、多边形等形状 。我们使用直线、弧（arc）来创建复杂的曲线形状。每一个直线段或者曲线段的结束的地方是下一个的开始的地方。每一个连接的直线或者曲线段的集合成为subpath。一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths。  <br/>
<code>2.</code> CAShapeLayer： 继承于CALayer。 每个CAShapeLayer对象都代表着将要被渲染到屏幕上的一个任意的形状(shape)。具体的形状由其path(类型为CGPathRef)属性指定。 普通的CALayer是矩形，所以需要frame属性。CAShapeLayer它本身没有形状，它的形状来源于其属性path 。CAShapeLayer有不同于CALayer的属性，它从CALayer继承而来的属性在绘制时是不起作用的。</p>

<h2>具体用法看代码</h2>

<p>仅仅使用UIBezierPath来绘图的话，需要在view的drawRect方法里实现,详细可以看MyView的drawRect方法</p>

<pre><code class="ObjC">//
//  MyView.m
//  CAShapeLayerAndUIBezierPath
//
//  Created by 蔡欣东 on 16/4/21.
//  Copyright © 2016年 蔡欣东. All rights reserved.
//

#import "MyView.h"

@implementation MyView

- (void)drawRect:(CGRect)rect {
    [self simpleDraw];
    [self drawARCPath];
    [self drawTrianglePath];
    [self drawSecondBezierPath];
}

//画圆角矩形
-(void)simpleDraw{
    UIBezierPath* path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, 100, 100) cornerRadius:20];
    path.lineWidth = 5;

    //设置填充颜色
    UIColor* fillColor = [UIColor greenColor];
    [fillColor set];
    [path fill];

    //设置线的颜色，需要在填充颜色之后设置
    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}


//画圆弧
-(void)drawARCPath{
    UIBezierPath* path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(20, 150) radius:100 startAngle:0 endAngle:M_PI*90/180 clockwise:YES];

    //连接处的样式
    path.lineCapStyle = kCGLineCapRound;
    //连接方式
    path.lineJoinStyle = kCGLineJoinRound;
    path.lineWidth = 5;

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}

//画三角形
-(void)drawTrianglePath{
    UIBezierPath* path = [UIBezierPath bezierPath];
    //设置起点
    [path moveToPoint:CGPointMake(20, 300)];
    [path addLineToPoint:CGPointMake(150, 400)];
    [path addLineToPoint:CGPointMake(20, 400)];
    [path closePath];

    path.lineWidth = 5;

    UIColor* fillColor = [UIColor greenColor];
    [fillColor set];
    [path fill];

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];


}

//画二次贝尔曲线
-(void)drawSecondBezierPath{
    UIBezierPath* path = [UIBezierPath bezierPath];
    [path moveToPoint:CGPointMake(200, 150)];
    [path addQuadCurveToPoint:CGPointMake(200, 300) controlPoint:CGPointMake(50, 50)];
    path.lineWidth = 5;

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}

@end
</code></pre>

<p>用CAShapeLayer和UIBezierPath画图，以及结合CAAnimation实现一个绘图动画</p>

<h2>动画效果：</h2>

<p><img src="/images/gif1.gif"></p>

<pre><code class="ObjC">//
//  ViewController.m
//  CAShapeLayerAndUIBezierPath
//
//  Created by 蔡欣东 on 16/4/21.
//  Copyright © 2016年 蔡欣东. All rights reserved.
//

#import "ViewController.h"
#import "MyView.h"
@interface ViewController (){
    CAShapeLayer *layer;
}

@end


@implementation ViewController


- (void)viewDidLoad {
    [super viewDidLoad];

    //仅仅使用UIBezierPath的话，需要在view的drawRect方法里实现,详细可以看MyView的drawRect方法
//    CGFloat W = [UIScreen mainScreen].bounds.size.width;
//    CGFloat H = [UIScreen mainScreen].bounds.size.height;
//    MyView* myView = [[MyView alloc]initWithFrame:CGRectMake(0, 0, W, H)];
//    myView.backgroundColor = [UIColor whiteColor];
//    [self.view addSubview:myView];




    //CAShapeLayer和UIBezierPath画图

    layer = [CAShapeLayer layer];
    layer.fillColor = [UIColor clearColor].CGColor;
    layer.lineWidth =  20.0f;
    layer.lineCap = kCALineCapRound;
    layer.lineJoin = kCALineJoinRound;
    layer.strokeColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:layer];

    // 创建贝塞尔路径
    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(200, 200) radius:80 startAngle:0 endAngle:M_PI*2 clockwise:NO];


    // 关联layer和贝塞尔路径
    layer.path = path.CGPath;

    // 创建Animation
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
    animation.fromValue = @(0.0);
    animation.toValue = @(1.0);
    layer.autoreverses = NO;
    animation.duration = 3.0;

    // 设置layer的animation
    [layer addAnimation:animation forKey:nil];
    animation.delegate = self;


    int count = 16;
    for (int i = 0; i&lt;count; i++) {
        CAShapeLayer* lineLayer = [CAShapeLayer layer];
        lineLayer.fillColor = [UIColor clearColor].CGColor;
        lineLayer.strokeColor = [UIColor yellowColor].CGColor;
        lineLayer.lineWidth = 15.0f;
        lineLayer.lineCap = kCALineCapRound;
        lineLayer.lineJoin = kCALineCapRound;
        [self.view.layer addSublayer:lineLayer];

        UIBezierPath* path2 = [UIBezierPath bezierPath];
        int x = 200+100*cos(2*M_PI/count*i);
        int y = 200-100*sin(2*M_PI/count*i);
        int len = 50;
        [path2 moveToPoint:CGPointMake(x, y)];
        [path2 addLineToPoint:CGPointMake(x+len*cos(2*M_PI/count*i), y-len*sin(2*M_PI/count*i))];
        lineLayer.path = path2.CGPath;
        [lineLayer addAnimation:animation forKey:nil];
    }

}

//animation结束回调
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
    NSLog(@"yes");
    layer.fillColor = [UIColor redColor].CGColor;
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];

}

@end
</code></pre>

<p>Demo地址：<a href="https://github.com/caixindong/SomeDemoForYou">https://github.com/caixindong/SomeDemoForYou</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS动画总结]]></title>
    <link href="http://caixindong.github.io/blog/2016/04/19/ios85/"/>
    <updated>2016-04-19T22:21:39+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/04/19/ios85</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>做个知识汇总，日常动画的动画实现，看这篇应该足够了</p>

<h2>iOS图形分层</h2>

<p><img src="/images/uikit.png"></p>

<p>越顶层，动画的封装程度越高，动画api就越简洁，本文章主要讲动画在UIKit层和CoreAnimation层的实现</p>

<h2>UIKit层</h2>

<h4>UIViewAnimation</h4>

<p>动画的实现过程：</p>

<pre><code class="ObjC">[UIView beginAnimations:@"newAnimation" context:nil];
//设置动画的持续时间
[UIView setAnimationDuration:1.0];
//如果设置为YES,代表动画每次重复执行的效果会跟上一次相反
[UIView setAnimationRepeatAutoreverses:YES];
//设置动画的运动曲线（线性、先快后慢、先慢后快）
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
//动画的重复次数
[UIView setAnimationRepeatCount:10];

//动画动作定义
CGRect tmp = self.myView.frame;
tmp.origin.x += 100;
self.myView.frame = tmp;

//提交动画
[UIView commitAnimations];
</code></pre>

<h4>UIViewAnimationWithBlocks</h4>

<p>动画的实现过程：</p>

<pre><code class="ObjC">
//动画持续时间、延迟时间、动画执行函数
[UIView animateWithDuration:0.5 delay:0 options:UIViewAnimationOptionCurveEaseInOut  animations:^{
//动画动作定义
CGRect tmp = self.myView.frame;
tmp.origin.x = 300;
self.myView.frame = tmp;
    } completion:nil];
</code></pre>

<h2>Core Animation</h2>

<p>Core Animation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。</p>

<p>CAAnimation可分为四种：
1.CABasicAnimation  <br/>
通过设定起始点，终点，时间，动画会沿着你这设定点进行移动。可以看做特殊的CAKeyFrameAnimation  <br/>
2.CAKeyframeAnimation  <br/>
Keyframe顾名思义就是关键点的frame，你可以通过设定CALayer的始点、中间关键点、终点的frame，时间，动画会沿你设定的轨迹进行移动  <br/>
3.CAAnimationGroup  <br/>
Group也就是组合的意思，就是把对这个Layer的所有动画都组合起来。PS：一个layer设定了很多动画，他们都会同时执行，如何按顺序执行我到时候再讲。  <br/>
4.CATransition  <br/>
这个就是苹果帮开发者封装好的一些动画</p>

<p>停止动画</p>

<pre><code class="ObjC">CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];

     // 让CALayer的时间停止走动
     layer.speed = 0.0;
     // 让CALayer的时间停留在pausedTime这个时刻
     layer.timeOffset = pausedTime;
</code></pre>

<p>恢复动画</p>

<pre><code class="ObjC">CFTimeInterval pausedTime = layer.timeOffset;
      // 1. 让CALayer的时间继续行走
        layer.speed = 1.0;
      // 2. 取消上次记录的停留时刻
        layer.timeOffset = 0.0;
      // 3. 取消上次设置的时间
        layer.beginTime = 0.0;    
      // 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)
      CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;
      // 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)
        layer.beginTime = timeSincePause;
</code></pre>

<h4>CABasicAnimation的实现</h4>

<p>基础动画，是CAPropertyAnimation子类  <br/>
keyPath附录表：  <br/>
<img src="/images/keypath.png">
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='ObjC'><span class='line'><span class="bp">CALayer</span><span class="o">*</span> <span class="n">scaleLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">CALayer</span> <span class="n">alloc</span><span class="p">]</span><span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">scaleLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleLayer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</span><span class='line'>    <span class="n">scaleLayer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">scaleLayer</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="c1">//动画类型</span>
</span><span class='line'><span class="bp">CABasicAnimation</span><span class="o">*</span> <span class="n">scaleAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CABasicAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;transform.scale&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">//动画的起始状态</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="mf">@1.0</span><span class="p">;</span>
</span><span class='line'><span class="c1">//动画的结束状态</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="mf">@1.5</span><span class="p">;</span>
</span><span class='line'><span class="c1">//如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">* fillMode决定当前对象在非active时间段的行为。（要想fillMode有效，最好设置removedOnCompletion = NO）</span>
</span><span class='line'><span class="cm">**/</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForwards</span><span class="p">;</span>
</span><span class='line'><span class="c1">//动画重复次数</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">MAXFLOAT</span><span class="p">;</span>
</span><span class='line'><span class="c1">//动画持续时间</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//将动画添加到layer上面</span>
</span><span class='line'><span class="p">[</span><span class="n">scaleLayer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">scaleAnimation</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;scaleAnimation&quot;</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####CAKeyframeAnimation的实现</span>
</span><span class='line'><span class="err">关键帧动画，也是</span><span class="bp">CAPropertyAnimation</span><span class="err">的子类</span>
</span><span class='line'><span class="err">与</span><span class="bp">CABasicAnimation</span><span class="err">的区别是：</span>
</span><span class='line'><span class="bp">CABasicAnimation</span><span class="err">只能从一个数值（</span><span class="n">fromValue</span><span class="err">）变到另一个数值（</span><span class="n">toValue</span><span class="err">），而</span><span class="bp">CAKeyframeAnimation</span><span class="err">会使用一个</span><span class="bp">NSArray</span><span class="err">保存这些数值</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="bp">CALayer</span><span class="o">*</span> <span class="n">blackPoint</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">CALayer</span> <span class="n">alloc</span><span class="p">]</span><span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">blackPoint</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">blackPoint</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">blackPoint</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">CGFloat</span> <span class="n">originY</span> <span class="o">=</span> <span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="bp">CAKeyframeAnimation</span><span class="o">*</span> <span class="n">keyAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">//记录每一个关键帧</span>
</span><span class='line'><span class="n">keyAnimation</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">],[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">220</span><span class="p">,</span> <span class="n">originY</span><span class="p">)],[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'><span class="c1">//可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</span>
</span><span class='line'><span class="n">keyAnimation</span><span class="p">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithFloat</span><span class="p">:</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithFloat</span><span class="p">:</span><span class="mf">0.5</span><span class="p">],</span>
</span><span class='line'>                          <span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithFloat</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="c1">//指定时间函数</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">timingFunctions</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">],</span>
</span><span class='line'>                                                                               <span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">calculationMode</span> <span class="o">=</span> <span class="n">kCAAnimationLinear</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">blackPoint</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">keyAnimation</span> <span class="nl">forKey</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">rectRunAnimation</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4>CAAnimationGroup的实现</h4>

<p>组动画，是CAAnimation的子类  <br/>
可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行,可以通过设置动画对象的beginTime属性来更改动画的开始时间</p>

<pre><code class="ObjC">CAAnimationGroup* group = [CAAnimationGroup animation];
    //用来保存一组动画对象
    group.animations = @[scaleAnimation];
    group.duration = 0.8;
    group.repeatCount = 3;
    group.autoreverses = YES;
    [scaleLayer addAnimation:group forKey:nil];
</code></pre>

<h4>CATransition的实现</h4>

<p>转场动画，是CAAnimation的子类，，能够为层提供移出屏幕和移入屏幕的动画效果。
UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果
有以下效果可以使用：  <br/>
cube 方块  <br/>
suckEffect 三角  <br/>
rippleEffect 水波抖动  <br/>
pageCurl 上翻页  <br/>
pageUnCurl 下翻页  <br/>
oglFlip 上下翻转  <br/>
cameraIrisHollowOpen 镜头快门开  <br/>
cameraIrisHollowClose 镜头快门开</p>

<pre><code class="ObjC">CATransition* animation = [CATransition animation];
    animation.duration = 1.0f;
    animation.timingFunction = UIViewAnimationCurveEaseInOut;
    //执行完是否移除
    animation.removedOnCompletion = NO;
    //过渡效果
    animation.type = @"cube";
    //过渡方向
    animation.subtype = kCATransitionFromRight;
    //设置之后endProgress才有效
    animation.fillMode = kCAFillModeForwards;
    animation.endProgress = 1;
    [imageView.layer addAnimation:animation forKey:nil];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈GCD的内部实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/04/06/ios84/"/>
    <updated>2016-04-06T22:37:36+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/04/06/ios84</id>
    <content type="html"><![CDATA[<h2>CGD</h2>

<p>GCD是苹果开发的多线程编程的解决方案，通过简单的API就可以实现创建新线程去执行我们需要执行的任务，不需要我们手动地创建和管理线程。它的API包含在libdispatch库中。</p>

<h2>Dispatch Queue</h2>

<p>Dispatch Queue是GCD中很重要的一部分，它是负责执行处理的队列，它的内部主要由三部分构成：  <br/>
1、一个管理追加block的C语言实现的FIFO的队列；   <br/>
2、处理信号量的原子操作；  <br/>
3、用于管理线程的C语言实现的一些容器。</p>

<pre><code class="ObjC">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"我的操作");
    });
</code></pre>

<p>dispatch queue 通过 dispatch_async等函数将block追加到队列上，block不是直接追加到队列，而是先构成一个dispatch continuation构造体，构造体包含了这个block还有一些上下文信息，例如block所属的dispatch group等等。</p>

<h2>Dispatch Queue执行过程是怎么的呢？</h2>

<h2>workqueue</h2>

<p>工作队列，是一个用于创建内核线程的接口，通过它创建的内核线程来执行内核其他模块排列到队列里的工作。不同优先级的dispatch queue对应着对应优先级的workqueue。GCD初始化的时候，使用pthread_workqueue_create_np创建pthread_workqueue</p>

<h2>执行过程</h2>

<p>dispatch queue执行block时，先从dispatch queue自身的FIFO队列中取出dispatch continuation，接着调用pthread_workqueue_additem_np函数，传入这些参数：dispatch queue自身、一个符合其优先级workqueue,dispatch continuation。  <br/>
调用该函数后，会通知对应的workqueue增加执行项目，XNU内核生成线程，线程执行pthread_workqueue函数执行block。</p>
]]></content>
  </entry>
  
</feed>
