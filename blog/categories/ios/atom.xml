<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-17T20:59:00+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发一些零碎的小知识（四）]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/17/ios82/"/>
    <updated>2016-03-17T20:49:00+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/17/ios82</id>
    <content type="html"><![CDATA[<h2>为app添加侧滑返回手势</h2>

<h3>前言</h3>

<p>侧滑返回功能默认是开启，但需要我们在storyBoard做一个这样的设置   <br/>
<img src="/images/exampleImg2.png"></p>

<p>将Hide Bottom Bar On Push 这个选项勾选上  <br/>
但当我们在我们的controller里定义返回功能，侧滑返回功能就会失效，如何解决呢，请看下面的代码</p>

<h3>代码如下</h3>

<pre><code class="ObjC">- (void)viewDidLoad {
    [super viewDidLoad];

    //打开侧滑返回
    self.navigationController.interactivePopGestureRecognizer.enabled = YES;
    self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为app实现渐变的遮罩效果]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/17/ios81/"/>
    <updated>2016-03-17T20:17:14+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/17/ios81</id>
    <content type="html"><![CDATA[<h2>效果图如下</h2>

<p><img src="/images/exampleImg1.png"></p>

<h2>实现代码如下</h2>

<pre><code class="ObjC">//blackView为你想加上遮罩的视图


     CGColorRef opaqueBlackColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:1].CGColor;
    CGColorRef transparentBalckColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4].CGColor;

     //遮罩效果由CAGradientLayer实现
    CAGradientLayer * layer = [[CAGradientLayer alloc]init];
    layer.frame = CGRectMake(0, 0, WIDTH, self.blackView.bounds.size.height);

    //设置渐变的方向
    layer.startPoint = CGPointMake(0, 1);
    layer.endPoint = CGPointMake(0, 0);

    //设置渐变得颜色范围
    layer.colors = @[(__bridge id)opaqueBlackColor,(__bridge id)transparentBalckColor];

    [self.blackView.layer insertSublayer:layer atIndex:0];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 网络编程]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/07/ios80/"/>
    <updated>2016-03-07T22:45:23+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/07/ios80</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近要给quanta的小朋友讲iOS网络编程的相关知识，所以提前在这里梳理。</p>

<h2>何为HTTP</h2>

<p>首先我们必须了解HTTP协议，何为HTTP?超文本传送协议，它是基于应用层的通信规范，是一个设计来使客户端和服务器顺利进行通讯的协议。
HTTP做了以下几方面的规定：  <br/>
<code>1.</code> request和response的格式；  <br/>
<code>2.</code> 建立连接的方法，有持久连接和非持久连接。HTTP1.1默认是带流水的持久连接；  <br/>
         非持久连接：服务器发出一个对象后，相应TCP连接关闭，每个TCP连接只用于传输一个请求消息和一个响应消息；  <br/>
         持久连接：单个持久TCP连接，它分为不带流水线和流水线。不带流水线的只有收到上个请求响应再请求；
<code>3.</code> 缓存机制（减少发送请求）；      <br/>
<code>4.</code> 响应授权激发机制，用于服务器激发客户端请求并授权；</p>

<p>过程：客户端先建立一个TCP连接，再发送一个请求，服务器收到请求处理后响应，传送数据，客户端可以继续发生请求或关闭TCP</p>

<h2>GET与POST</h2>

<p>GET与POST是两种请求方式，GET主要用于从指定的服务器中获取数据，POST主要用于提交数据给指定服务器
区别：  <br/>
GET请求能够被缓存，POST请求不能被缓存下来
GET提交的数据放在url(以？分割url和传输数据，参数之间以&amp;相连)      <br/>
GET请求会保存在浏览器的浏览记录中，POST请求不会保存在浏览器浏览记录中  <br/>
以GET请求的URL能够保存为浏览器书签，以POST请求的URL无法保存为浏览器书签  <br/>
GET请求有长度限制，POST请求无长度限制
GET安全性没有POST好，因为GET提交的参数是可见</p>

<h2>iOS网络编程</h2>

<p>在iOS9之前，我们主要利用NSURLConnection来进行网络请求操作，在iOS9以后，苹果推荐使用NSURLSession。具体如何使用这些类来进行网络请求，我以代码加注释的形式呈现出来。</p>

<pre><code class="ObjC">    /**
     * 可变请求与不可变请求的区别：
     * 1、不可变请求在初始化的时候需要指定url，而可变请求可以以后指定
     * 2、cachePolicy缓存策略 timeoutInterval超时时间
     **/

    NSURLRequest* request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://a1.jikexueyuan.com/home/201601/25/1f7e/56a5887620a10.png"] cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:60];



    /**
     * iOS 9以前 请求,默认是GET
     **/
    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
        //解析json数据
        NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
        NSLog(@"%@",dict);
       dispatch_async(dispatch_get_main_queue(), ^{
           _imageView.image = [UIImage imageWithData:data];
       });
    }];


    /**
     * iOS 9 请求
    **/
    NSMutableURLRequest* request2 = [[NSMutableURLRequest alloc]init];
    request2.URL = [NSURL URLWithString:@"http://a1.jikexueyuan.com/home/201601/25/1f7e/56a5887620a10.png"];
    request2.HTTPMethod = @"GET";

    NSURLSession* session = [NSURLSession sharedSession];

    [[session dataTaskWithRequest:request2 completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"%@",data);
            _imageView.image = [UIImage imageWithData:data];
        });
    }] resume];
    //记得resume 唤醒 suspend 暂停

    /**
     * 上传 用POST，具体可以看这个链接 http://borissun.iteye.com/blog/1338991
     **/
    NSMutableURLRequest* postRequest = [[NSMutableURLRequest alloc]init];
    postRequest.URL = [NSURL URLWithString:@""];
    NSInputStream* inStream = [NSInputStream inputStreamWithFileAtPath:@""];
    postRequest.HTTPBodyStream = inStream;
    postRequest.HTTPMethod = @"POST";
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9适配]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/06/ios77/"/>
    <updated>2016-03-06T12:22:31+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/06/ios77</id>
    <content type="html"><![CDATA[<h2>MARK</h2>

<p>开发遇到适配iOS9的问题，这里mark一下</p>

<p><code>1.</code> 默认使用HTTPS请求  <br/>
如果在Xcode 9之前使用的时http请求，那么在XCode 9上编译的App是不能联网的，会提示如下错误:
App Transport Security has blocked a cleartext HTTP (<a href="http://">http://</a>) resource load since it is insecure. Temporary exceptions can be configured via your app&rsquo;s Info.plist file.  <br/>
修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，因此推荐使用后面一种方法，具体的做法是:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>

<p><code>2.</code> iOS 9使用URL scheme必须将其加入白名单  <br/>
否则会提示类似如下错误:  <br/>
canOpenURL: failed for URL: &ldquo;mqqopensdkapiV2://qqapp&rdquo; - error: &ldquo;This app is not allowed to query for scheme mqqopensdkapiV2”  <br/>
修正方法是，Info.plist文件中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。特酷吧在项目中使用了qq，微信等分享登录功能，需要添加的值为：  <br/>
mqqopensdkapiV2  <br/>
mqqOpensdkSSoLogin  <br/>
mqq  <br/>
mqzoneopensdkapiV2  <br/>
mqzoneopensdkapi19  <br/>
mqzoneopensdkapi  <br/>
mqzoneopensdk  <br/>
mqzone  <br/>
weixin  <br/>
wechat  <br/>
更多其他适配点后续不断跟进。</p>

<p><code>3.</code> bitcode  <br/>
使用Xcode7编译提示：XXX does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64  <br/>
bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。    bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。  <br/>
Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”->”Enable Bitcode”选项中看关闭bitcode即可。  <br/>
开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。</p>

<p><code>4.</code> 使用XCode7链接第三方库提示warning  <br/>
Lots of warnings when building with Xcode 7 with 3rd party libraries  <br/>
warning: Could not resolve external type c:objc(cs)NSString  <br/>
warning: Could not resolve external type c:objc(cs)NSDictionary  <br/>
warning: Could not resolve external type c:objc(cs)NSMutableString  <br/>
warning: Could not resolve external type c:objc(cs)NSError  <br/>
<a href="https://forums.developer.apple.com/thread/17921">https://forums.developer.apple.com/thread/17921</a>  <br/>
目前没发现好的解决办法，可以尝试如下:  <br/>
I had this problem too.  Here&rsquo;s how I fixed it.  <br/>
1)  Go to Build Settings -> Build Options -> Debug Information Format  <br/>
2)  Change the Debug setting from &ldquo;DWARF with dSYM File&rdquo; to &ldquo;DWARF&rdquo;  <br/>
3)  Leave the Release setting at &ldquo;DWARF with dSYM File&rdquo;  <br/>
The problem appears to be that Xcode was trying to create dSYM files for Debug     builds.  You don&rsquo;t need dSYM files for Debug builds &ndash; it&rsquo;s release builds where you need them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简析SDWebImage]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/26/ios66/"/>
    <updated>2016-02-26T22:31:56+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/26/ios66</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>SDWebImage是一个强大的第三方图片异步加载库，从事iOS开发的人或多或少用过它。今天我点开源码一看，里面一些实现细节确实令人玩味，同时也让我了解到缓存机制是如何实现。</p>

<h1>简析</h1>

<pre><code class="objC">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;
</code></pre>

<p>作者利用category为一些UIKit类拓展出相应的缓存功能，其中UIImageView和UIButton使用频率比较高，因为日常开发中，我们需要这两个控件加载图片。上面那个方法是UIImageView+WebCache最常用的方法，传一个url，UIImageView就会将网络图片加载出来，这个方法看起来简单，可是背后的实现没那么容易，不禁感慨大神之牛，巧妙的设计和背后复杂的实现竟然浓缩成这样的一个接口函数。</p>

<h2>点进去看源码</h2>

<pre><code class="objC">[self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];
</code></pre>

<p>这个是原始接口</p>

<h2>点进去这个原始接口</h2>

<p>我可以看到这个函数体</p>

<pre><code class="objc">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 
</code></pre>

<p>这个函数体就是就是sd_setImage的实现逻辑，利用block回调，有加载过程的回调和加载完成的回调</p>

<pre><code class="objC">[self sd_cancelCurrentImageLoad];
objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    if (!(options &amp; SDWebImageDelayPlaceholder)) {
        dispatch_main_async_safe(^{
            self.image = placeholder;
        });
    }
</code></pre>

<p>首先，它先取消下载队列里正在进行的任务，将图片的url和UIImageView关联起来作为UIImageView的一部分；如果有placeholder，就先将它显示出来；</p>

<p>接着就是网络加载图片实现逻辑的主要部分</p>

<pre><code class="objC">id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
if (!wself) return;
            dispatch_main_sync_safe(^{
                if (!wself) return;
                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
                {
                    completedBlock(image, error, cacheType, url);
                    return;
                }
                else if (image) {
                    wself.image = image;
                    [wself setNeedsLayout];
                } else {
                    if ((options &amp; SDWebImageDelayPlaceholder)) {
                        wself.image = placeholder;
                        [wself setNeedsLayout];
                    }
                }
                if (completedBlock &amp;&amp; finished) {
                    completedBlock(image, error, cacheType, url);
                }
            });
}];
</code></pre>

<p>利用一个全局的SDWebImageManager来进行下载缓存操作的管理和调度。SDWebImageManager由两部分构成，由SDImageCache缓存器和SDWebImageDownloader下载器构成。同步上面加载过程的回调，在completed里除了同步加载完成的回调外，还将block回调的image加载在控件上面。</p>

<pre><code class="objC">[self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"];
</code></pre>

<p>这个函数是为了判断当前是否有重复的网络图片加载操作，如果有，就取消，key作为判断加载操作的标识。</p>

<h2>点进去看downloadImageWithURL源码</h2>

<pre><code class="objC">__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];
</code></pre>

<p>首先，先new一个新的operation，operation是遵守SDWebImageOperation协议的一个对象，协议有个cancle方法，利用cancle可以取消当前操作</p>

<pre><code class="objC">    @synchronized (self.failedURLs) {
        isFailedUrl = [self.failedURLs containsObject:url];
    }

    if (!url || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
        dispatch_main_sync_safe(^{
            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);
        });
        return operation;
    }
    @synchronized (self.runningOperations) {
        [self.runningOperations addObject:operation];
    }
</code></pre>

<p>接着我们可以看到一个实现的亮点，它用一个failedURLs集合来记录失败或者无效的url，如果传进来的url是failedURLs这个集合里的或者是为空，则完成操作并回调,否则将operation添加到运行的operation数组中。</p>

<pre><code class="objC"> NSString *key = [self cacheKeyForURL:url];
    }
</code></pre>

<p>它将url缓存起来,给他一个key值</p>

<pre><code class="objC">operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {}];
</code></pre>

<p>SDWebImageManager的缓存器根据缓存的url的key值来寻找是否有对应的缓存</p>

<h2>点进去看queryDiskCacheForKey源码</h2>

<pre><code class="objC">if (!key) {
        doneBlock(nil, SDImageCacheTypeNone);
        return nil;
    }
</code></pre>

<p>如果相关的缓存记录则doneBlock回调，标识为SDImageCacheTypeNone</p>

<pre><code class="objC">
UIImage *image = [self imageFromMemoryCacheForKey:key];
if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }
</code></pre>

<p>先在内存里寻找，SDImage用的内存缓存是用NSCache实现的，如果有就是doneBlock回调，标志为SDImageCacheTypeMemory</p>

<pre><code class="objC">  UIImage *diskImage = [self diskImageForKey:key];
            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) {
                NSUInteger cost = SDCacheCostForImage(diskImage);
                [self.memCache setObject:diskImage forKey:key cost:cost];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
</code></pre>

<p>如果没有，就从磁盘缓存里找，如果找到了，就将他缓存到内存中，doneBlock回调，标志为SDImageCacheTypeDisk</p>

<h2>返回上层函数查看done:^(UIImage *image, SDImageCacheType cacheType) {}这个block的主体</h2>

<p>我们只看如果没有图片缓存该如何做
<code>objC
id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) {};
</code>
SDWebImageManager的下载器开启下载operation来下载图片</p>

<h2>点进去看downloadImageWithURL源码</h2>

<p>下载的实现就不展开讲了，它利用的苹果提供的NSURLConnection来实现。
<code>objC
wself.lastAddedOperation = operation;
</code>
同时记录最后一个下载操作，最后block回调。
图片下载完成后，利用SDWebImageManager的缓冲器将图片缓存到内存和磁盘中，并将operation从运行的operation数组移除，如果失败则记录他是一个失败的url，成功则block回调。</p>
]]></content>
  </entry>
  
</feed>
