<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2015-10-13T13:40:57+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发一些零碎的小知识（三）]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/09/ios10/"/>
    <updated>2015-10-09T15:17:29+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/09/ios10</id>
    <content type="html"><![CDATA[<p>在IOS开发中，我们经常用的NSArray或者NSMutableArray ,但是当使用不当的时候，会有下面的错误提示。
Collection &lt;__NSArrayM: 0xxxxxxx> was mutated while being enumerated.</p>

<p>遇到这类错误的时候，是同时对同一个数组进行了操作</p>

<p>错误例子：</p>

<pre><code>NSMutableArray * arrayTemp = xxx;   

for (NSDictionary * dic in arrayTemp) {        

    if (condition){            
        [arrayTemp removeObject:dic];
    }       
}
</code></pre>

<p>数组在遍历的同时，也对它进行移除操作，这样做程序在运行的时候会崩溃</p>

<p>所以应改为</p>

<pre><code>NSMutableArray * arrayTemp = xxx; 

NSArray * array = [NSArray arrayWithArray: arrayTemp];  

for (NSDictionary * dic in array) {        

    if (condition){            
        [arrayTemp removeObject:dic];
    }       
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发一些零碎的小知识（二）]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/04/ios9/"/>
    <updated>2015-10-04T20:45:04+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/04/ios9</id>
    <content type="html"><![CDATA[<p>关于收键盘
在viewDidLoad里添加以下代码</p>

<pre><code>self.view.userInteractionEnabled =YES;
UITapGestureRecognizer* guest = [[UITapGestureRecognizeralloc]
initWithTarget:selfaction:@selector(touchView:)];
[self.viewaddGestureRecognizer:guest];
</code></pre>

<p>然后在外部定义一个名为touchView的方法</p>

<pre><code>-(void)touchView:(UITapGestureRecognizer*) recognizer{
[self.viewendEditing:YES];
}
</code></pre>

<p>加入上述代码后，当点击屏幕的任意地方，手机的键盘就会收起来</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBarButtonItem随着屏幕切换变化的问题]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/04/ios8/"/>
    <updated>2015-10-04T20:11:07+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/04/ios8</id>
    <content type="html"><![CDATA[<p>将item里面的view中的autoresizingMask 设为UIViewAutoresizingNone，item就不会随着屏幕的切换而变化</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发一些零碎的知识点（一）]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/04/ios7/"/>
    <updated>2015-10-04T20:04:43+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/04/ios7</id>
    <content type="html"><![CDATA[<p>一、导航栏的创建</p>

<pre><code>UIViewController* firstCon = [[UIViewControlleralloc]init];
NavigationController* nav = [[NavigationControlleralloc]initWithRootViewController:
firstCon];//指定导航控制器的根视图控制器
nav.modalPresentationStyle =UIModalPresentationFormSheet;//呈现出模态效果
</code></pre>

<p>二、下拉菜单的创建</p>

<pre><code> UIViewController* pvc = [[UIViewControlleralloc]init];
UIPopoverController* pop = [[UIPopoverControlleralloc]initWithContentViewController:
pvc];//创建下拉菜单
[pop presentPopoverFromBarButtonItem:firstItem permittedArrowDirections:
UIPopoverArrowDirectionAny animated:YES];//展示出来
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking的用法]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/04/ios6/"/>
    <updated>2015-10-04T19:45:43+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/04/ios6</id>
    <content type="html"><![CDATA[<p>AFNeiworking 用法</p>

<p>1、get post请求</p>

<pre><code>NSString *url1 = @"http://api.openweathermap.org/data/2.5/
forecast/daily?lat=39.907501&amp;lon=116.397232&amp;cnt=10";//测试get请求

NSString *url2 =@"http://webservice.webxml.com.cn/
WebServices/MobileCodeWS.asmx/getMobileCodeInfo";//测试post请求

//创建一个请求管理类对象
AFHTTPRequestOperationManager* manager = [AFHTTPRequestOperationManager manager];
//注意：此行不加也可以   
manager.responseSerializer.acceptableContentTypes = [manager.responseSerializer. 
acceptableContentTypes setByAddingObject:@"text/html"];

//设置请求类型
manager.requestSerializer = [AFHTTPRequestSerializer serializer];

//设置返回类型 json AFXMLParserResponseSerializer:xml类型 AFHTTPResponseSerializer:二进制类型
//manager.responseSerializer = [AFJSONResponseSerializer serializer];
manager.responseSerializer = [AFXMLParserResponseSerializer serializer];

//get请求
[manager GET:url1 parameters:nil success:^(AFHTTPRequestOperation *operation,
id responseObject) {
    NSLog(@"%@",responseObject);

} failure:^(AFHTTPRequestOperation *operation,NSError *error) {
    NSLog(@"%@",error);
}];

//post请求，参数不显示在正文（一个网址？后面就是正文，内容就是参数），参数设置在parameters里
[manager POST:url2 parameters:@{@"mobileCode":@"15910514636",@"userID":@""}
success:^(AFHTTPRequestOperation *operation,id responseObject) {
    NSLog(@"%@",responseObject);

} failure:^(AFHTTPRequestOperation *operation,NSError *error) {
    NSLog(@"%@",error);

}];
</code></pre>

<p>2、上传</p>

<pre><code>NSString* url = @"";

//参数
NSDictionary* paras =@{};

//获得的数据
NSDate* data =nil;
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
manager.requestSerializer = [AFHTTPRequestSerializer serializer];
manager.responseSerializer = [AFJSONResponseSerializer serializer];

manager.responseSerializer.acceptableContentTypes = [manager.responseSerializer.
acceptableContentTypes   setByAddingObject:@"text/html"];
AFHTTPRequestOperation *httpoperation = 
[manager POST:url parameters:paras constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
//构造数据，上传的数据
    [formData appendPartWithFileData:dataname:@"upload"fileName:@"image1.jpg"mimeType:nil];

} success:^(AFHTTPRequestOperation *operation,id responseObject) {

} failure:^(AFHTTPRequestOperation *operation,NSError *error) {

}];
</code></pre>

<p>3、监听网络状态</p>

<pre><code>//开启网络状态指示器
[[AFNetworkActivityIndicatorManager sharedManager]setEnabled:YES];
//初始化监听
AFHTTPRequestOperationManager* manager =  [[AFHTTPRequestOperationManager alloc]
initWithBaseURL:[NSURL URLWithString:@"http://www.baidu.com"]];
NSOperationQueue* queue = manager.operationQueue;

//监听结果回调
[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        caseAFNetworkReachabilityStatusReachableViaWiFi:
        caseAFNetworkReachabilityStatusReachableViaWWAN:
            [queue setSuspended:NO];//设置是否挂起该进程
            NSLog(@"have net");
            break;
        caseAFNetworkReachabilityStatusNotReachable:
        default:
            [queue setSuspended:YES];
            NSLog(@"no");
            break;
    }
}];
//开始监听
[manager.reachabilityManager startMonitoring];
</code></pre>
]]></content>
  </entry>
  
</feed>
