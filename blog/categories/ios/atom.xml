<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-07T17:04:20+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS9适配]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/06/ios77/"/>
    <updated>2016-03-06T12:22:31+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/06/ios77</id>
    <content type="html"><![CDATA[<h2>MARK</h2>

<p>开发遇到适配iOS9的问题，这里mark一下</p>

<p><code>1.</code> 默认使用HTTPS请求  <br/>
如果在Xcode 9之前使用的时http请求，那么在XCode 9上编译的App是不能联网的，会提示如下错误:
App Transport Security has blocked a cleartext HTTP (<a href="http://">http://</a>) resource load since it is insecure. Temporary exceptions can be configured via your app&rsquo;s Info.plist file.  <br/>
修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，因此推荐使用后面一种方法，具体的做法是:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>

<p><code>2.</code> iOS 9使用URL scheme必须将其加入白名单  <br/>
否则会提示类似如下错误:  <br/>
canOpenURL: failed for URL: &ldquo;mqqopensdkapiV2://qqapp&rdquo; - error: &ldquo;This app is not allowed to query for scheme mqqopensdkapiV2”  <br/>
修正方法是，Info.plist文件中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。特酷吧在项目中使用了qq，微信等分享登录功能，需要添加的值为：  <br/>
mqqopensdkapiV2  <br/>
mqqOpensdkSSoLogin  <br/>
mqq  <br/>
mqzoneopensdkapiV2  <br/>
mqzoneopensdkapi19  <br/>
mqzoneopensdkapi  <br/>
mqzoneopensdk  <br/>
mqzone  <br/>
weixin  <br/>
wechat  <br/>
更多其他适配点后续不断跟进。</p>

<p><code>3.</code> bitcode  <br/>
使用Xcode7编译提示：XXX does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64  <br/>
bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。    bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。  <br/>
Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”->”Enable Bitcode”选项中看关闭bitcode即可。  <br/>
开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。</p>

<p><code>4.</code> 使用XCode7链接第三方库提示warning  <br/>
Lots of warnings when building with Xcode 7 with 3rd party libraries  <br/>
warning: Could not resolve external type c:objc(cs)NSString  <br/>
warning: Could not resolve external type c:objc(cs)NSDictionary  <br/>
warning: Could not resolve external type c:objc(cs)NSMutableString  <br/>
warning: Could not resolve external type c:objc(cs)NSError  <br/>
<a href="https://forums.developer.apple.com/thread/17921">https://forums.developer.apple.com/thread/17921</a>  <br/>
目前没发现好的解决办法，可以尝试如下:  <br/>
I had this problem too.  Here&rsquo;s how I fixed it.  <br/>
1)  Go to Build Settings -> Build Options -> Debug Information Format  <br/>
2)  Change the Debug setting from &ldquo;DWARF with dSYM File&rdquo; to &ldquo;DWARF&rdquo;  <br/>
3)  Leave the Release setting at &ldquo;DWARF with dSYM File&rdquo;  <br/>
The problem appears to be that Xcode was trying to create dSYM files for Debug     builds.  You don&rsquo;t need dSYM files for Debug builds &ndash; it&rsquo;s release builds where you need them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简析SDWebImage]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/26/ios66/"/>
    <updated>2016-02-26T22:31:56+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/26/ios66</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>SDWebImage是一个强大的第三方图片异步加载库，从事iOS开发的人或多或少用过它。今天我点开源码一看，里面一些实现细节确实令人玩味，同时也让我了解到缓存机制是如何实现。</p>

<h1>简析</h1>

<pre><code class="objC">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;
</code></pre>

<p>作者利用category为一些UIKit类拓展出相应的缓存功能，其中UIImageView和UIButton使用频率比较高，因为日常开发中，我们需要这两个控件加载图片。上面那个方法是UIImageView+WebCache最常用的方法，传一个url，UIImageView就会将网络图片加载出来，这个方法看起来简单，可是背后的实现没那么容易，不禁感慨大神之牛，巧妙的设计和背后复杂的实现竟然浓缩成这样的一个接口函数。</p>

<h2>点进去看源码</h2>

<pre><code class="objC">[self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];
</code></pre>

<p>这个是原始接口</p>

<h2>点进去这个原始接口</h2>

<p>我可以看到这个函数体</p>

<pre><code class="objc">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 
</code></pre>

<p>这个函数体就是就是sd_setImage的实现逻辑，利用block回调，有加载过程的回调和加载完成的回调</p>

<pre><code class="objC">[self sd_cancelCurrentImageLoad];
objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    if (!(options &amp; SDWebImageDelayPlaceholder)) {
        dispatch_main_async_safe(^{
            self.image = placeholder;
        });
    }
</code></pre>

<p>首先，它先取消下载队列里正在进行的任务，将图片的url和UIImageView关联起来作为UIImageView的一部分；如果有placeholder，就先将它显示出来；</p>

<p>接着就是网络加载图片实现逻辑的主要部分</p>

<pre><code class="objC">id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
if (!wself) return;
            dispatch_main_sync_safe(^{
                if (!wself) return;
                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
                {
                    completedBlock(image, error, cacheType, url);
                    return;
                }
                else if (image) {
                    wself.image = image;
                    [wself setNeedsLayout];
                } else {
                    if ((options &amp; SDWebImageDelayPlaceholder)) {
                        wself.image = placeholder;
                        [wself setNeedsLayout];
                    }
                }
                if (completedBlock &amp;&amp; finished) {
                    completedBlock(image, error, cacheType, url);
                }
            });
}];
</code></pre>

<p>利用一个全局的SDWebImageManager来进行下载缓存操作的管理和调度。SDWebImageManager由两部分构成，由SDImageCache缓存器和SDWebImageDownloader下载器构成。同步上面加载过程的回调，在completed里除了同步加载完成的回调外，还将block回调的image加载在控件上面。</p>

<pre><code class="objC">[self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"];
</code></pre>

<p>这个函数是为了判断当前是否有重复的网络图片加载操作，如果有，就取消，key作为判断加载操作的标识。</p>

<h2>点进去看downloadImageWithURL源码</h2>

<pre><code class="objC">__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];
</code></pre>

<p>首先，先new一个新的operation，operation是遵守SDWebImageOperation协议的一个对象，协议有个cancle方法，利用cancle可以取消当前操作</p>

<pre><code class="objC">    @synchronized (self.failedURLs) {
        isFailedUrl = [self.failedURLs containsObject:url];
    }

    if (!url || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
        dispatch_main_sync_safe(^{
            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);
        });
        return operation;
    }
    @synchronized (self.runningOperations) {
        [self.runningOperations addObject:operation];
    }
</code></pre>

<p>接着我们可以看到一个实现的亮点，它用一个failedURLs集合来记录失败或者无效的url，如果传进来的url是failedURLs这个集合里的或者是为空，则完成操作并回调,否则将operation添加到运行的operation数组中。</p>

<pre><code class="objC"> NSString *key = [self cacheKeyForURL:url];
    }
</code></pre>

<p>它将url缓存起来,给他一个key值</p>

<pre><code class="objC">operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {}];
</code></pre>

<p>SDWebImageManager的缓存器根据缓存的url的key值来寻找是否有对应的缓存</p>

<h2>点进去看queryDiskCacheForKey源码</h2>

<pre><code class="objC">if (!key) {
        doneBlock(nil, SDImageCacheTypeNone);
        return nil;
    }
</code></pre>

<p>如果相关的缓存记录则doneBlock回调，标识为SDImageCacheTypeNone</p>

<pre><code class="objC">
UIImage *image = [self imageFromMemoryCacheForKey:key];
if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }
</code></pre>

<p>先在内存里寻找，SDImage用的内存缓存是用NSCache实现的，如果有就是doneBlock回调，标志为SDImageCacheTypeMemory</p>

<pre><code class="objC">  UIImage *diskImage = [self diskImageForKey:key];
            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) {
                NSUInteger cost = SDCacheCostForImage(diskImage);
                [self.memCache setObject:diskImage forKey:key cost:cost];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
</code></pre>

<p>如果没有，就从磁盘缓存里找，如果找到了，就将他缓存到内存中，doneBlock回调，标志为SDImageCacheTypeDisk</p>

<h2>返回上层函数查看done:^(UIImage *image, SDImageCacheType cacheType) {}这个block的主体</h2>

<p>我们只看如果没有图片缓存该如何做
<code>objC
id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) {};
</code>
SDWebImageManager的下载器开启下载operation来下载图片</p>

<h2>点进去看downloadImageWithURL源码</h2>

<p>下载的实现就不展开讲了，它利用的苹果提供的NSURLConnection来实现。
<code>objC
wself.lastAddedOperation = operation;
</code>
同时记录最后一个下载操作，最后block回调。
图片下载完成后，利用SDWebImageManager的缓冲器将图片缓存到内存和磁盘中，并将operation从运行的operation数组移除，如果失败则记录他是一个失败的url，成功则block回调。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS本地推送功能实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/01/11/ios20/"/>
    <updated>2016-01-11T15:49:33+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/01/11/ios20</id>
    <content type="html"><![CDATA[<p>1、首先在AppDelegate注册推送</p>

<pre><code class="objc">    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {


        if ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) {

        //注册推送, iOS 8以上
        UIUserNotificationSettings *settings = [UIUserNotificationSettings

                                                settingsForTypes:(UIUserNotificationTypeBadge |

                                                                  UIUserNotificationTypeSound |

                                                                  UIUserNotificationTypeAlert)

                                                categories:nil];

        [application registerUserNotificationSettings:settings];
        [application registerForRemoteNotifications];

    } else {
        //注册推送, 适配系统版本iOS 8以下的手机
        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge |

        UIRemoteNotificationTypeAlert |

        UIRemoteNotificationTypeSound;

        [application registerForRemoteNotificationTypes:myTypes];

    }


    return YES;
    }
</code></pre>

<p>2、注册成功与否的回调</p>

<pre><code class="objc">    - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken {
            NSLog(@"device token is %@",deviceToken);
    }

    - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error{
            NSLog(@"push fail error is %@",error);
    }
</code></pre>

<p>3、获取本地通知数据回调</p>

<pre><code class="objc">    - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{
            NSLog(@"get notification");
            //获取通知后的操作
    }
</code></pre>

<p>4、发起本地推送</p>

<pre><code class="objc">    -(void)sendLocalNotifation{
        UILocalNotification* notifation = [[UILocalNotification alloc]init];
        //当前时间5秒后
        NSDate* pushDate = [NSDate dateWithTimeIntervalSinceNow:5];
        if (notifation!=nil) {
            //设置推送时间
            notifation.fireDate = pushDate;
            //设置时区
            notifation.timeZone = [NSTimeZone defaultTimeZone];
            //设置重复次数
            notifation.repeatInterval = 0;
            notifation.soundName = UILocalNotificationDefaultSoundName;
            //通知弹窗的文本
            notifation.alertBody = @"推送的文本";
            //设置icon小红点
            notifation.applicationIconBadgeNumber = 1;
            //设置userinfo 方便在之后需要撤销的时候使用
            NSDictionary* info = [NSDictionary dictionaryWithObject:@"通知的名字" forKey:@"key"];
            notifation.userInfo = info;
            //添加推送到UIApplication
            UIApplication* app = [UIApplication sharedApplication];
            [app scheduleLocalNotification:notifation];
        }
    }
</code></pre>

<p>5、解除本地推送</p>

<pre><code class="objc">    -(void)cancleLocalNotifation{
        UIApplication* app = [UIApplication sharedApplication];
        //获取所有本地推送
        NSArray* localArray = [app scheduledLocalNotifications];
        UILocalNotification* notification;
        if (localArray) {
            for(UILocalNotification* noti in localArray){
            NSDictionary* userInfo = noti.userInfo;
            if (userInfo) {
                NSString *keyValue = [userInfo objectForKey:@"key"];
                if ([keyValue isEqualToString:@"通知的名字"]) {
                    notification = noti;
                    [app cancelLocalNotification:notification];
                }
            }
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS图片压缩及上传]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/31/ios19/"/>
    <updated>2015-12-31T22:51:47+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/31/ios19</id>
    <content type="html"><![CDATA[<p>1、在工具类定义压缩图片的方法,传入图片和所要压缩的尺寸</p>

<pre><code class="objc ">    +(UIImage *)imageWithImage:(UIImage *)image scaleToSize :(CGSize )newSize{

    UIGraphicsBeginImageContext(newSize);

    [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];

    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();

    UIGraphicsEndImageContext();

    return newImage;

    }
</code></pre>

<p>2、利用AFNetworking做图片上传功能</p>

<pre><code class="objc">    +(void)POSTToUrl:(NSString *)url WithData:(NSData *)data 
        WithReturnBlock:(ReturnValueBlock)block         
        WithErrorCodeBlock:(ErrorCodeBlock)errorBlock       
        WithFailtureBlock:(FailureBlock)failtureBlock{

        AFHTTPRequestOperationManager* manager = [[AFHTTPRequestOperationManager alloc]init];

        manager.requestSerializer = [AFHTTPRequestSerializer serializer];
        manager.responseSerializer = [AFJSONResponseSerializer serializer];     

        //不设置可能会出现404的bug
        manager.responseSerializer.acceptableContentTypes =     [manager.responseSerializer.acceptableContentTypes   setByAddingObject:@"text/html"];

        [manager POST:url parameters:nil 
        constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
            //以上传的时间为图片名
            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
            formatter.dateFormat = @"yyyyMMddHHmmss";
            NSString *str = [formatter stringFromDate:[NSDate date]];
            NSString *fileName = [NSString stringWithFormat:@"%@.png", str];

            [formData appendPartWithFileData:data 
            name:@"upload" //upload.php处理文件的字段
            fileName:fileName //图片名字 
            mimeType:@"image/png"];

        }success:^(AFHTTPRequestOperation *operation,id responseObject) {
            //上传成功
        }failure:^(AFHTTPRequestOperation *operation,NSError *error) {
            //上传失败
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中遇过的一些小bug（二）]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/18/ios18/"/>
    <updated>2015-12-18T21:12:27+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/18/ios18</id>
    <content type="html"><![CDATA[<p>1、block会release，所以在使用的时候记得非空判断，特别在使用AFNetworking block交互的时候</p>

<p>2、有时候在真机测试的时，某些第三方库编译不通过，可能bitcode没关，可以在build setting里面将这个值设为no。苹果文档是这样说的：bitcode是被编译程序的一种中间形式的代码，包含bitcode配置的程序将会在App store上被编译和链接，bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
]]></content>
  </entry>
  
</feed>
