<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-05-07T21:40:08+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CAShapeLayer与UIBezierPath]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/07/ios86/"/>
    <updated>2016-05-07T21:06:22+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/07/ios86</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><code>1.</code> UIBezierPath： UIBezierPath是在 UIKit 中的一个类，继承于NSObject,可以创建基于矢量的路径.此类是Core Graphics框架关于path的一个OC封装。使用此类可以定义常见的圆形、多边形等形状 。我们使用直线、弧（arc）来创建复杂的曲线形状。每一个直线段或者曲线段的结束的地方是下一个的开始的地方。每一个连接的直线或者曲线段的集合成为subpath。一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths。  <br/>
<code>2.</code> CAShapeLayer： 继承于CALayer。 每个CAShapeLayer对象都代表着将要被渲染到屏幕上的一个任意的形状(shape)。具体的形状由其path(类型为CGPathRef)属性指定。 普通的CALayer是矩形，所以需要frame属性。CAShapeLayer它本身没有形状，它的形状来源于其属性path 。CAShapeLayer有不同于CALayer的属性，它从CALayer继承而来的属性在绘制时是不起作用的。</p>

<h2>具体用法看代码</h2>

<p>仅仅使用UIBezierPath来绘图的话，需要在view的drawRect方法里实现,详细可以看MyView的drawRect方法</p>

<pre><code class="ObjC">//
//  MyView.m
//  CAShapeLayerAndUIBezierPath
//
//  Created by 蔡欣东 on 16/4/21.
//  Copyright © 2016年 蔡欣东. All rights reserved.
//

#import "MyView.h"

@implementation MyView

- (void)drawRect:(CGRect)rect {
    [self simpleDraw];
    [self drawARCPath];
    [self drawTrianglePath];
    [self drawSecondBezierPath];
}

//画圆角矩形
-(void)simpleDraw{
    UIBezierPath* path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, 100, 100) cornerRadius:20];
    path.lineWidth = 5;

    //设置填充颜色
    UIColor* fillColor = [UIColor greenColor];
    [fillColor set];
    [path fill];

    //设置线的颜色，需要在填充颜色之后设置
    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}


//画圆弧
-(void)drawARCPath{
    UIBezierPath* path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(20, 150) radius:100 startAngle:0 endAngle:M_PI*90/180 clockwise:YES];

    //连接处的样式
    path.lineCapStyle = kCGLineCapRound;
    //连接方式
    path.lineJoinStyle = kCGLineJoinRound;
    path.lineWidth = 5;

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}

//画三角形
-(void)drawTrianglePath{
    UIBezierPath* path = [UIBezierPath bezierPath];
    //设置起点
    [path moveToPoint:CGPointMake(20, 300)];
    [path addLineToPoint:CGPointMake(150, 400)];
    [path addLineToPoint:CGPointMake(20, 400)];
    [path closePath];

    path.lineWidth = 5;

    UIColor* fillColor = [UIColor greenColor];
    [fillColor set];
    [path fill];

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];


}

//画二次贝尔曲线
-(void)drawSecondBezierPath{
    UIBezierPath* path = [UIBezierPath bezierPath];
    [path moveToPoint:CGPointMake(200, 150)];
    [path addQuadCurveToPoint:CGPointMake(200, 300) controlPoint:CGPointMake(50, 50)];
    path.lineWidth = 5;

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}

@end
</code></pre>

<p>用CAShapeLayer和UIBezierPath画图，以及结合CAAnimation实现一个绘图动画</p>

<h2>动画效果：</h2>

<p><img src="/images/gif1.gif"></p>

<pre><code class="ObjC">//
//  ViewController.m
//  CAShapeLayerAndUIBezierPath
//
//  Created by 蔡欣东 on 16/4/21.
//  Copyright © 2016年 蔡欣东. All rights reserved.
//

#import "ViewController.h"
#import "MyView.h"
@interface ViewController (){
    CAShapeLayer *layer;
}

@end


@implementation ViewController


- (void)viewDidLoad {
    [super viewDidLoad];

    //仅仅使用UIBezierPath的话，需要在view的drawRect方法里实现,详细可以看MyView的drawRect方法
//    CGFloat W = [UIScreen mainScreen].bounds.size.width;
//    CGFloat H = [UIScreen mainScreen].bounds.size.height;
//    MyView* myView = [[MyView alloc]initWithFrame:CGRectMake(0, 0, W, H)];
//    myView.backgroundColor = [UIColor whiteColor];
//    [self.view addSubview:myView];




    //CAShapeLayer和UIBezierPath画图

    layer = [CAShapeLayer layer];
    layer.fillColor = [UIColor clearColor].CGColor;
    layer.lineWidth =  20.0f;
    layer.lineCap = kCALineCapRound;
    layer.lineJoin = kCALineJoinRound;
    layer.strokeColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:layer];

    // 创建贝塞尔路径
    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(200, 200) radius:80 startAngle:0 endAngle:M_PI*2 clockwise:NO];


    // 关联layer和贝塞尔路径
    layer.path = path.CGPath;

    // 创建Animation
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
    animation.fromValue = @(0.0);
    animation.toValue = @(1.0);
    layer.autoreverses = NO;
    animation.duration = 3.0;

    // 设置layer的animation
    [layer addAnimation:animation forKey:nil];
    animation.delegate = self;


    int count = 16;
    for (int i = 0; i&lt;count; i++) {
        CAShapeLayer* lineLayer = [CAShapeLayer layer];
        lineLayer.fillColor = [UIColor clearColor].CGColor;
        lineLayer.strokeColor = [UIColor yellowColor].CGColor;
        lineLayer.lineWidth = 15.0f;
        lineLayer.lineCap = kCALineCapRound;
        lineLayer.lineJoin = kCALineCapRound;
        [self.view.layer addSublayer:lineLayer];

        UIBezierPath* path2 = [UIBezierPath bezierPath];
        int x = 200+100*cos(2*M_PI/count*i);
        int y = 200-100*sin(2*M_PI/count*i);
        int len = 50;
        [path2 moveToPoint:CGPointMake(x, y)];
        [path2 addLineToPoint:CGPointMake(x+len*cos(2*M_PI/count*i), y-len*sin(2*M_PI/count*i))];
        lineLayer.path = path2.CGPath;
        [lineLayer addAnimation:animation forKey:nil];
    }

}

//animation结束回调
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
    NSLog(@"yes");
    layer.fillColor = [UIColor redColor].CGColor;
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];

}

@end
</code></pre>

<p>Demo地址：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS动画总结]]></title>
    <link href="http://caixindong.github.io/blog/2016/04/19/ios85/"/>
    <updated>2016-04-19T22:21:39+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/04/19/ios85</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>做个知识汇总，日常动画的动画实现，看这篇应该足够了</p>

<h2>iOS图形分层</h2>

<p><img src="/images/uikit.png"></p>

<p>越顶层，动画的封装程度越高，动画api就越简洁，本文章主要讲动画在UIKit层和CoreAnimation层的实现</p>

<h2>UIKit层</h2>

<h4>UIViewAnimation</h4>

<p>动画的实现过程：</p>

<pre><code class="ObjC">[UIView beginAnimations:@"newAnimation" context:nil];
//设置动画的持续时间
[UIView setAnimationDuration:1.0];
//如果设置为YES,代表动画每次重复执行的效果会跟上一次相反
[UIView setAnimationRepeatAutoreverses:YES];
//设置动画的运动曲线（线性、先快后慢、先慢后快）
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
//动画的重复次数
[UIView setAnimationRepeatCount:10];

//动画动作定义
CGRect tmp = self.myView.frame;
tmp.origin.x += 100;
self.myView.frame = tmp;

//提交动画
[UIView commitAnimations];
</code></pre>

<h4>UIViewAnimationWithBlocks</h4>

<p>动画的实现过程：</p>

<pre><code class="ObjC">
//动画持续时间、延迟时间、动画执行函数
[UIView animateWithDuration:0.5 delay:0 options:UIViewAnimationOptionCurveEaseInOut  animations:^{
//动画动作定义
CGRect tmp = self.myView.frame;
tmp.origin.x = 300;
self.myView.frame = tmp;
    } completion:nil];
</code></pre>

<h2>Core Animation</h2>

<p>Core Animation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。</p>

<p>CAAnimation可分为四种：
1.CABasicAnimation  <br/>
通过设定起始点，终点，时间，动画会沿着你这设定点进行移动。可以看做特殊的CAKeyFrameAnimation  <br/>
2.CAKeyframeAnimation  <br/>
Keyframe顾名思义就是关键点的frame，你可以通过设定CALayer的始点、中间关键点、终点的frame，时间，动画会沿你设定的轨迹进行移动  <br/>
3.CAAnimationGroup  <br/>
Group也就是组合的意思，就是把对这个Layer的所有动画都组合起来。PS：一个layer设定了很多动画，他们都会同时执行，如何按顺序执行我到时候再讲。  <br/>
4.CATransition  <br/>
这个就是苹果帮开发者封装好的一些动画</p>

<p>停止动画</p>

<pre><code class="ObjC">CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];

     // 让CALayer的时间停止走动
     layer.speed = 0.0;
     // 让CALayer的时间停留在pausedTime这个时刻
     layer.timeOffset = pausedTime;
</code></pre>

<p>恢复动画</p>

<pre><code class="ObjC">CFTimeInterval pausedTime = layer.timeOffset;
      // 1. 让CALayer的时间继续行走
        layer.speed = 1.0;
      // 2. 取消上次记录的停留时刻
        layer.timeOffset = 0.0;
      // 3. 取消上次设置的时间
        layer.beginTime = 0.0;    
      // 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)
      CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;
      // 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)
        layer.beginTime = timeSincePause;
</code></pre>

<h4>CABasicAnimation的实现</h4>

<p>基础动画，是CAPropertyAnimation子类  <br/>
keyPath附录表：  <br/>
<img src="/images/keypath.png">
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='ObjC'><span class='line'><span class="bp">CALayer</span><span class="o">*</span> <span class="n">scaleLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">CALayer</span> <span class="n">alloc</span><span class="p">]</span><span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">scaleLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleLayer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</span><span class='line'>    <span class="n">scaleLayer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">scaleLayer</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="c1">//动画类型</span>
</span><span class='line'><span class="bp">CABasicAnimation</span><span class="o">*</span> <span class="n">scaleAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CABasicAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;transform.scale&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">//动画的起始状态</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="mf">@1.0</span><span class="p">;</span>
</span><span class='line'><span class="c1">//动画的结束状态</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="mf">@1.5</span><span class="p">;</span>
</span><span class='line'><span class="c1">//如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">* fillMode决定当前对象在非active时间段的行为。（要想fillMode有效，最好设置removedOnCompletion = NO）</span>
</span><span class='line'><span class="cm">**/</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForwards</span><span class="p">;</span>
</span><span class='line'><span class="c1">//动画重复次数</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">MAXFLOAT</span><span class="p">;</span>
</span><span class='line'><span class="c1">//动画持续时间</span>
</span><span class='line'><span class="n">scaleAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//将动画添加到layer上面</span>
</span><span class='line'><span class="p">[</span><span class="n">scaleLayer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">scaleAnimation</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;scaleAnimation&quot;</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####CAKeyframeAnimation的实现</span>
</span><span class='line'><span class="err">关键帧动画，也是</span><span class="bp">CAPropertyAnimation</span><span class="err">的子类</span>
</span><span class='line'><span class="err">与</span><span class="bp">CABasicAnimation</span><span class="err">的区别是：</span>
</span><span class='line'><span class="bp">CABasicAnimation</span><span class="err">只能从一个数值（</span><span class="n">fromValue</span><span class="err">）变到另一个数值（</span><span class="n">toValue</span><span class="err">），而</span><span class="bp">CAKeyframeAnimation</span><span class="err">会使用一个</span><span class="bp">NSArray</span><span class="err">保存这些数值</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="bp">CALayer</span><span class="o">*</span> <span class="n">blackPoint</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">CALayer</span> <span class="n">alloc</span><span class="p">]</span><span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">blackPoint</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">blackPoint</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">blackPoint</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">CGFloat</span> <span class="n">originY</span> <span class="o">=</span> <span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="bp">CAKeyframeAnimation</span><span class="o">*</span> <span class="n">keyAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">//记录每一个关键帧</span>
</span><span class='line'><span class="n">keyAnimation</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">],[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">220</span><span class="p">,</span> <span class="n">originY</span><span class="p">)],[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">blackPoint</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'><span class="c1">//可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</span>
</span><span class='line'><span class="n">keyAnimation</span><span class="p">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithFloat</span><span class="p">:</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithFloat</span><span class="p">:</span><span class="mf">0.5</span><span class="p">],</span>
</span><span class='line'>                          <span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithFloat</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="c1">//指定时间函数</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">timingFunctions</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">],</span>
</span><span class='line'>                                                                               <span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">calculationMode</span> <span class="o">=</span> <span class="n">kCAAnimationLinear</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">blackPoint</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">keyAnimation</span> <span class="nl">forKey</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">rectRunAnimation</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4>CAAnimationGroup的实现</h4>

<p>组动画，是CAAnimation的子类  <br/>
可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行,可以通过设置动画对象的beginTime属性来更改动画的开始时间</p>

<pre><code class="ObjC">CAAnimationGroup* group = [CAAnimationGroup animation];
    //用来保存一组动画对象
    group.animations = @[scaleAnimation];
    group.duration = 0.8;
    group.repeatCount = 3;
    group.autoreverses = YES;
    [scaleLayer addAnimation:group forKey:nil];
</code></pre>

<h4>CATransition的实现</h4>

<p>转场动画，是CAAnimation的子类，，能够为层提供移出屏幕和移入屏幕的动画效果。
UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果
有以下效果可以使用：  <br/>
cube 方块  <br/>
suckEffect 三角  <br/>
rippleEffect 水波抖动  <br/>
pageCurl 上翻页  <br/>
pageUnCurl 下翻页  <br/>
oglFlip 上下翻转  <br/>
cameraIrisHollowOpen 镜头快门开  <br/>
cameraIrisHollowClose 镜头快门开</p>

<pre><code class="ObjC">CATransition* animation = [CATransition animation];
    animation.duration = 1.0f;
    animation.timingFunction = UIViewAnimationCurveEaseInOut;
    //执行完是否移除
    animation.removedOnCompletion = NO;
    //过渡效果
    animation.type = @"cube";
    //过渡方向
    animation.subtype = kCATransitionFromRight;
    //设置之后endProgress才有效
    animation.fillMode = kCAFillModeForwards;
    animation.endProgress = 1;
    [imageView.layer addAnimation:animation forKey:nil];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈GCD的内部实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/04/06/ios84/"/>
    <updated>2016-04-06T22:37:36+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/04/06/ios84</id>
    <content type="html"><![CDATA[<h2>CGD</h2>

<p>GCD是苹果开发的多线程编程的解决方案，通过简单的API就可以实现创建新线程去执行我们需要执行的任务，不需要我们手动地创建和管理线程。它的API包含在libdispatch库中。</p>

<h2>Dispatch Queue</h2>

<p>Dispatch Queue是GCD中很重要的一部分，它是负责执行处理的队列，它的内部主要由三部分构成：  <br/>
1、一个管理追加block的C语言实现的FIFO的队列；   <br/>
2、处理信号量的原子操作；  <br/>
3、用于管理线程的C语言实现的一些容器。</p>

<pre><code class="ObjC">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"我的操作");
    });
</code></pre>

<p>dispatch queue 通过 dispatch_async等函数将block追加到队列上，block不是直接追加到队列，而是先构成一个dispatch continuation构造体，构造体包含了这个block还有一些上下文信息，例如block所属的dispatch group等等。</p>

<h2>Dispatch Queue执行过程是怎么的呢？</h2>

<h2>workqueue</h2>

<p>工作队列，是一个用于创建内核线程的接口，通过它创建的内核线程来执行内核其他模块排列到队列里的工作。不同优先级的dispatch queue对应着对应优先级的workqueue。GCD初始化的时候，使用pthread_workqueue_create_np创建pthread_workqueue</p>

<h2>执行过程</h2>

<p>dispatch queue执行block时，先从dispatch queue自身的FIFO队列中取出dispatch continuation，接着调用pthread_workqueue_additem_np函数，传入这些参数：dispatch queue自身、一个符合其优先级workqueue,dispatch continuation。  <br/>
调用该函数后，会通知对应的workqueue增加执行项目，XNU内核生成线程，线程执行pthread_workqueue函数执行block。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Foundation(C对象)与 Foundation(OC对象)之间的转换的理解]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/18/ios83/"/>
    <updated>2016-03-18T21:43:11+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/18/ios83</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近在做一个UI效果的时候，用到__bridge这个关键字，查了资料发现它是Objective-C的对象类型转换为 void* 类型的一个关键字，于是继续查资料深入学习，发现了一遍好文章，在这里MARK一下。</p>

<h2>转载自<a href="http://blog.sina.com.cn/s/blog_7c8dc2d50101ll9d.html">http://blog.sina.com.cn/s/blog_7c8dc2d50101ll9d.html</a></h2>

<h4>Core Foundation 框架</h4>

<p>Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。下面列举该框架支持进行管理的数据以及可提供的服务：  <br/>
群体数据类型 (数组、集合等)  <br/>
程序包  <br/>
字符串管理  <br/>
日期和时间管理  <br/>
原始数据块管理  <br/>
偏好管理  <br/>
URL及数据流操作  <br/>
线程和RunLoop  <br/>
端口和soket通讯  <br/>
Core Foundation框架和Foundation框架紧密相关，它们为相同功能提供接口，但Foundation框架提供Objective-C接口。如果您将Foundation对象和Core Foundation类型掺杂使用，则可利用两个框架之间的 “toll-free bridging”。所谓的Toll-free bridging是说您可以在某个框架的方法或函数同时使用Core Foundatio和Foundation 框架中的某些类型。很多数据类型支持这一特性，其中包括群体和字符串数据类型。每个框架的类和类型描述都会对某个对象是否为 toll-free bridged，应和什么对象桥接进行说明。  <br/>
如需进一步信息，请阅读Core Foundation 框架参考。</p>

<p>自 Xcode4.2 开始导入ARC机制后，为了支持对象间的转型，Apple又增加了许多转型用的关键字。这一讲我们就来了解其用法，以及产生的理由。  <br/>
引子  <br/>
我们先来看一下ARC无效的时候，我们写id类型转void*类型的写法：</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];
void *p = obj;
</code></pre>

<p>反过来，当把void*对象变回id类型时，只是简单地如下来写，</p>

<pre><code class="ObjC">id obj = p;
[obj release];
</code></pre>

<p>但是上面的代码在ARC有效时，就有了下面的错误：</p>

<pre><code>error: implicit conversion of an Objective-C pointer
    to ’void *’ is disallowed with ARC
    void *p = obj;
              ^

error: implicit conversion of a non-Objective-C pointer
    type ’void *’ to ’id’ is disallowed with ARC
    id o = p;
            ^
</code></pre>

<p><strong>bridge
为了解决这一问题，我们使用 </strong>bridge 关键字来实现id类型与void*类型的相互转换。看下面的例子。</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];

void *p = (__bridge void *)obj;

id o = (__bridge id)p;
</code></pre>

<p>将Objective-C的对象类型用 <strong>bridge 转换为 void* 类型和使用 </strong>unsafe_unretained 关键字修饰的变量是一样的。被代入对象的所有者需要明确对象生命周期的管理，不要出现异常访问的问题。
除过 <strong>bridge 以外，还有两个 </strong>bridge 相关的类型转换关键字：  <br/>
<strong>bridge_transfer  <br/>
</strong>bridge_retained  <br/>
接下来，我们将看看这两个关键字的区别。</p>

<p><code>1.</code> <strong>bridge_retained  <br/>
先来看使用 </strong>bridge_retained 关键字的例子程序：</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];

void *p = (__bridge_retained void *)obj;
</code></pre>

<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。如果不是ARC代码，类似下面的实现：</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];

void *p = obj;
[(id)p retain];
</code></pre>

<p>可以用一个实际的例子验证，对象所有权是否被持有。</p>

<pre><code class="ObjC">void *p = 0;

{
    id obj = [[NSObject alloc] init];
    p = (__bridge_retained void *)obj;
}

NSLog(@"class=%@", [(__bridge id)p class]);
</code></pre>

<p>出了大括号的范围后，p 仍然指向一个有效的实体。说明他拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>

<p><code>2.</code> __bridge_transfer</p>

<p>相反，当想把本来拥有对象所有权的变量，在类型转换后，让其释放原先所有权的时候，需要使用__bridge_transfer 关键字。文字有点绕口，我们还是来看一段代码吧。
如果ARC无效的时候，我们可能需要写下面的代码。</p>

<pre><code class="ObjC">// p 变量原先持有对象的所有权
id obj = (id)p;
[obj retain];
[(id)p release];
</code></pre>

<p>那么ARC有效后，我们可以用下面的代码来替换：</p>

<pre><code class="ObjC">// p 变量原先持有对象的所有权
id obj = (__bridge_transfer id)p;
</code></pre>

<p>可以看出来，<strong>bridge_retained 是编译器替我们做了 retain 操作，而 </strong>bridge_transfer 是替我们做了 release。</p>

<p>Toll-Free bridged
在iOS世界，主要有两种对象：Objective-C 对象和 Core Foundation 对象0。Core Foundation 对象主要是有C语言实现的 Core Foundation Framework 的对象，其中也有对象引用计数的概念，只是不是 Cocoa Framework::Foundation Framework 的 retain/release，而是自身的 CFRetain/CFRelease 接口。
这两种对象间可以互相转换和操作，不使用ARC的时候，单纯的用C原因的类型转换，不需要消耗CPU的资源，所以叫做 Toll-Free bridged。比如 NSArray和CFArrayRef, NSString和CFStringRef，他们虽然属于不同的 Framework，但是具有相同的对象结构，所以可以用标准C的类型转换。
比如不使用ARC时，我们用下面的代码：</p>

<pre><code class="ObjC">NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (CFStringRef)string;
</code></pre>

<p>同样，Core Foundation类型向Objective-C类型转换时，也是简单地用标准C的类型转换即可。
但是在ARC有效的情况下，将出现类似下面的编译错误：</p>

<pre><code>Cast of Objective-C pointer type ‘NSString *’ to C pointer type ‘CFStringRef’ (aka ‘const struct __CFString *’) requires a bridged cast
Use __bridge to convert directly (no change in ownership)
Use __bridge_retained to make an ARC object available as a +1 ‘CFStringRef’ (aka ‘const struct __CFString *’)
</code></pre>

<p>错误中已经提示了我们需要怎样做：用 <strong>bridge 或者 </strong>bridge_retained 来转型，其差别就是变更对象的所有权。</p>

<p>正因为Objective-C是ARC管理的对象，而Core Foundation不是ARC管理的对象，所以才要特意这样转换，这与id类型向void*转换是一个概念。也就是说，当这两种类型（有ARC管理，没有ARC管理）在转换时，需要告诉编译器怎样处理对象的所有权。</p>

<p>上面的例子，使用 <strong>bridge/</strong>bridge_retained 后的代码如下：</p>

<pre><code class="ObjC">NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge CFStringRef)string;
只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当string对象被释放的时候，cfString也不能被使用了。
NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge_retained CFStringRef)string;
...
CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release
</code></pre>

<p>使用 __bridge_retained 可以通过转换目标处（cfString）的 retain 处理，来使所有权转移。即使 string 变量被释放，cfString 还是可以使用具体的对象。只是有一点，由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release。</p>

<p>实际上，Core Foundation 内部，为了实现Core Foundation对象类型与Objective-C对象类型的相互转换，提供了下面的函数。</p>

<pre><code class="ObjC">CFTypeRef  CFBridgingRetain(id  X)  {
    return  (__bridge_retained  CFTypeRef)X;
}

id  CFBridgingRelease(CFTypeRef  X)  {
    return  (__bridge_transfer  id)X;
}
</code></pre>

<p>所以，可以用 CFBridgingRetain 替代 __bridge_retained 关键字：</p>

<pre><code class="ObjC">NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = CFBridgingRetain(string);
...
CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。
</code></pre>

<pre><code>__bridge_transfer
</code></pre>

<p>所有权被转移的同时，被转换变量将失去对象的所有权。当Core Foundation对象类型向Objective-C对象类型转换的时候，会经常用到 __bridge_transfer 关键字。</p>

<pre><code class="ObjC">CFStringRef cfString = CFStringCreate...();
NSString *string = (__bridge_transfer NSString *)cfString;

// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release
</code></pre>

<p>同样，我们可以使用 CFBridgingRelease() 来代替 __bridge_transfer 关键字。</p>

<pre><code class="ObjC">CFStringRef cfString = CFStringCreate...();
NSString *string = CFBridgingRelease(cfString);
</code></pre>

<p>总结
由上面的学习我们了解到 ARC 中类型转换的用法，那么我们实际使用中按照怎样的原则或者方法来区分使用呢，下面我总结了几点关键要素。
明确被转换类型是否是 ARC 管理的对象
Core Foundation 对象类型不在 ARC 管理范畴内
Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内
如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁
各种对象的生命周期是怎样的
1. 声明 id obj 的时候，其实是缺省的申明了一个 <strong>strong 修饰的变量，所以编译器自动地加入了 retain 的处理，所以说 </strong>bridge_transfer 关键字只为我们做了 release 处理。</p>

<p>根据苹果官方的文档（<a href="https://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html%EF%BC%89%EF%BC%9A">https://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html%EF%BC%89%EF%BC%9A</a></p>

<p>__bridge只做类型转换，但是不修改对象（内存）管理权；</p>

<p>__bridge_retained（也可以使用CFBridgingRetain）将Objective-C的对象转换为Core Foundation的对象，同时将对象（内存）的管理权交给我们，后续需要使用CFRelease或者相关方法来释放对象；</p>

<p>__bridge_transfer（也可以使用CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给ARC。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发一些零碎的小知识（四）]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/17/ios82/"/>
    <updated>2016-03-17T20:49:00+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/17/ios82</id>
    <content type="html"><![CDATA[<h2>为app添加侧滑返回手势</h2>

<h3>前言</h3>

<p>侧滑返回功能默认是开启，但需要我们在storyBoard做一个这样的设置   <br/>
<img src="/images/exampleImg2.png"></p>

<p>将Hide Bottom Bar On Push 这个选项勾选上  <br/>
但当我们在我们的controller里定义返回功能，侧滑返回功能就会失效，如何解决呢，请看下面的代码</p>

<h3>代码如下</h3>

<pre><code class="ObjC">- (void)viewDidLoad {
    [super viewDidLoad];

    //打开侧滑返回
    self.navigationController.interactivePopGestureRecognizer.enabled = YES;
    self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
