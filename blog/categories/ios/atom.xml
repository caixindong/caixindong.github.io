<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-30T23:28:04+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Core Foundation(C对象)与 Foundation(OC对象)之间的转换的理解]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/18/ios83/"/>
    <updated>2016-03-18T21:43:11+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/18/ios83</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近在做一个UI效果的时候，用到__bridge这个关键字，查了资料发现它是Objective-C的对象类型转换为 void* 类型的一个关键字，于是继续查资料深入学习，发现了一遍好文章，在这里MARK一下。</p>

<h2>转载自<a href="http://blog.sina.com.cn/s/blog_7c8dc2d50101ll9d.html">http://blog.sina.com.cn/s/blog_7c8dc2d50101ll9d.html</a></h2>

<h4>Core Foundation 框架</h4>

<p>Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。下面列举该框架支持进行管理的数据以及可提供的服务：  <br/>
群体数据类型 (数组、集合等)  <br/>
程序包  <br/>
字符串管理  <br/>
日期和时间管理  <br/>
原始数据块管理  <br/>
偏好管理  <br/>
URL及数据流操作  <br/>
线程和RunLoop  <br/>
端口和soket通讯  <br/>
Core Foundation框架和Foundation框架紧密相关，它们为相同功能提供接口，但Foundation框架提供Objective-C接口。如果您将Foundation对象和Core Foundation类型掺杂使用，则可利用两个框架之间的 “toll-free bridging”。所谓的Toll-free bridging是说您可以在某个框架的方法或函数同时使用Core Foundatio和Foundation 框架中的某些类型。很多数据类型支持这一特性，其中包括群体和字符串数据类型。每个框架的类和类型描述都会对某个对象是否为 toll-free bridged，应和什么对象桥接进行说明。  <br/>
如需进一步信息，请阅读Core Foundation 框架参考。</p>

<p>自 Xcode4.2 开始导入ARC机制后，为了支持对象间的转型，Apple又增加了许多转型用的关键字。这一讲我们就来了解其用法，以及产生的理由。  <br/>
引子  <br/>
我们先来看一下ARC无效的时候，我们写id类型转void*类型的写法：</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];
void *p = obj;
</code></pre>

<p>反过来，当把void*对象变回id类型时，只是简单地如下来写，</p>

<pre><code class="ObjC">id obj = p;
[obj release];
</code></pre>

<p>但是上面的代码在ARC有效时，就有了下面的错误：</p>

<pre><code>error: implicit conversion of an Objective-C pointer
    to ’void *’ is disallowed with ARC
    void *p = obj;
              ^

error: implicit conversion of a non-Objective-C pointer
    type ’void *’ to ’id’ is disallowed with ARC
    id o = p;
            ^
</code></pre>

<p><strong>bridge
为了解决这一问题，我们使用 </strong>bridge 关键字来实现id类型与void*类型的相互转换。看下面的例子。</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];

void *p = (__bridge void *)obj;

id o = (__bridge id)p;
</code></pre>

<p>将Objective-C的对象类型用 <strong>bridge 转换为 void* 类型和使用 </strong>unsafe_unretained 关键字修饰的变量是一样的。被代入对象的所有者需要明确对象生命周期的管理，不要出现异常访问的问题。
除过 <strong>bridge 以外，还有两个 </strong>bridge 相关的类型转换关键字：  <br/>
<strong>bridge_transfer  <br/>
</strong>bridge_retained  <br/>
接下来，我们将看看这两个关键字的区别。</p>

<p><code>1.</code> <strong>bridge_retained  <br/>
先来看使用 </strong>bridge_retained 关键字的例子程序：</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];

void *p = (__bridge_retained void *)obj;
</code></pre>

<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。如果不是ARC代码，类似下面的实现：</p>

<pre><code class="ObjC">id obj = [[NSObject alloc] init];

void *p = obj;
[(id)p retain];
</code></pre>

<p>可以用一个实际的例子验证，对象所有权是否被持有。</p>

<pre><code class="ObjC">void *p = 0;

{
    id obj = [[NSObject alloc] init];
    p = (__bridge_retained void *)obj;
}

NSLog(@"class=%@", [(__bridge id)p class]);
</code></pre>

<p>出了大括号的范围后，p 仍然指向一个有效的实体。说明他拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>

<p><code>2.</code> __bridge_transfer</p>

<p>相反，当想把本来拥有对象所有权的变量，在类型转换后，让其释放原先所有权的时候，需要使用__bridge_transfer 关键字。文字有点绕口，我们还是来看一段代码吧。
如果ARC无效的时候，我们可能需要写下面的代码。</p>

<pre><code class="ObjC">// p 变量原先持有对象的所有权
id obj = (id)p;
[obj retain];
[(id)p release];
</code></pre>

<p>那么ARC有效后，我们可以用下面的代码来替换：</p>

<pre><code class="ObjC">// p 变量原先持有对象的所有权
id obj = (__bridge_transfer id)p;
</code></pre>

<p>可以看出来，<strong>bridge_retained 是编译器替我们做了 retain 操作，而 </strong>bridge_transfer 是替我们做了 release。</p>

<p>Toll-Free bridged
在iOS世界，主要有两种对象：Objective-C 对象和 Core Foundation 对象0。Core Foundation 对象主要是有C语言实现的 Core Foundation Framework 的对象，其中也有对象引用计数的概念，只是不是 Cocoa Framework::Foundation Framework 的 retain/release，而是自身的 CFRetain/CFRelease 接口。
这两种对象间可以互相转换和操作，不使用ARC的时候，单纯的用C原因的类型转换，不需要消耗CPU的资源，所以叫做 Toll-Free bridged。比如 NSArray和CFArrayRef, NSString和CFStringRef，他们虽然属于不同的 Framework，但是具有相同的对象结构，所以可以用标准C的类型转换。
比如不使用ARC时，我们用下面的代码：</p>

<pre><code class="ObjC">NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (CFStringRef)string;
</code></pre>

<p>同样，Core Foundation类型向Objective-C类型转换时，也是简单地用标准C的类型转换即可。
但是在ARC有效的情况下，将出现类似下面的编译错误：</p>

<pre><code>Cast of Objective-C pointer type ‘NSString *’ to C pointer type ‘CFStringRef’ (aka ‘const struct __CFString *’) requires a bridged cast
Use __bridge to convert directly (no change in ownership)
Use __bridge_retained to make an ARC object available as a +1 ‘CFStringRef’ (aka ‘const struct __CFString *’)
</code></pre>

<p>错误中已经提示了我们需要怎样做：用 <strong>bridge 或者 </strong>bridge_retained 来转型，其差别就是变更对象的所有权。</p>

<p>正因为Objective-C是ARC管理的对象，而Core Foundation不是ARC管理的对象，所以才要特意这样转换，这与id类型向void*转换是一个概念。也就是说，当这两种类型（有ARC管理，没有ARC管理）在转换时，需要告诉编译器怎样处理对象的所有权。</p>

<p>上面的例子，使用 <strong>bridge/</strong>bridge_retained 后的代码如下：</p>

<pre><code class="ObjC">NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge CFStringRef)string;
只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当string对象被释放的时候，cfString也不能被使用了。
NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge_retained CFStringRef)string;
...
CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release
</code></pre>

<p>使用 __bridge_retained 可以通过转换目标处（cfString）的 retain 处理，来使所有权转移。即使 string 变量被释放，cfString 还是可以使用具体的对象。只是有一点，由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release。</p>

<p>实际上，Core Foundation 内部，为了实现Core Foundation对象类型与Objective-C对象类型的相互转换，提供了下面的函数。</p>

<pre><code class="ObjC">CFTypeRef  CFBridgingRetain(id  X)  {
    return  (__bridge_retained  CFTypeRef)X;
}

id  CFBridgingRelease(CFTypeRef  X)  {
    return  (__bridge_transfer  id)X;
}
</code></pre>

<p>所以，可以用 CFBridgingRetain 替代 __bridge_retained 关键字：</p>

<pre><code class="ObjC">NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = CFBridgingRetain(string);
...
CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。
</code></pre>

<pre><code>__bridge_transfer
</code></pre>

<p>所有权被转移的同时，被转换变量将失去对象的所有权。当Core Foundation对象类型向Objective-C对象类型转换的时候，会经常用到 __bridge_transfer 关键字。</p>

<pre><code class="ObjC">CFStringRef cfString = CFStringCreate...();
NSString *string = (__bridge_transfer NSString *)cfString;

// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release
</code></pre>

<p>同样，我们可以使用 CFBridgingRelease() 来代替 __bridge_transfer 关键字。</p>

<pre><code class="ObjC">CFStringRef cfString = CFStringCreate...();
NSString *string = CFBridgingRelease(cfString);
</code></pre>

<p>总结
由上面的学习我们了解到 ARC 中类型转换的用法，那么我们实际使用中按照怎样的原则或者方法来区分使用呢，下面我总结了几点关键要素。
明确被转换类型是否是 ARC 管理的对象
Core Foundation 对象类型不在 ARC 管理范畴内
Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内
如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁
各种对象的生命周期是怎样的
1. 声明 id obj 的时候，其实是缺省的申明了一个 <strong>strong 修饰的变量，所以编译器自动地加入了 retain 的处理，所以说 </strong>bridge_transfer 关键字只为我们做了 release 处理。</p>

<p>根据苹果官方的文档（<a href="https://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html%EF%BC%89%EF%BC%9A">https://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html%EF%BC%89%EF%BC%9A</a></p>

<p>__bridge只做类型转换，但是不修改对象（内存）管理权；</p>

<p>__bridge_retained（也可以使用CFBridgingRetain）将Objective-C的对象转换为Core Foundation的对象，同时将对象（内存）的管理权交给我们，后续需要使用CFRelease或者相关方法来释放对象；</p>

<p>__bridge_transfer（也可以使用CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给ARC。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发一些零碎的小知识（四）]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/17/ios82/"/>
    <updated>2016-03-17T20:49:00+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/17/ios82</id>
    <content type="html"><![CDATA[<h2>为app添加侧滑返回手势</h2>

<h3>前言</h3>

<p>侧滑返回功能默认是开启，但需要我们在storyBoard做一个这样的设置   <br/>
<img src="/images/exampleImg2.png"></p>

<p>将Hide Bottom Bar On Push 这个选项勾选上  <br/>
但当我们在我们的controller里定义返回功能，侧滑返回功能就会失效，如何解决呢，请看下面的代码</p>

<h3>代码如下</h3>

<pre><code class="ObjC">- (void)viewDidLoad {
    [super viewDidLoad];

    //打开侧滑返回
    self.navigationController.interactivePopGestureRecognizer.enabled = YES;
    self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为app实现渐变的遮罩效果]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/17/ios81/"/>
    <updated>2016-03-17T20:17:14+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/17/ios81</id>
    <content type="html"><![CDATA[<h2>效果图如下</h2>

<p><img src="/images/exampleImg1.png"></p>

<h2>实现代码如下</h2>

<pre><code class="ObjC">//blackView为你想加上遮罩的视图


     CGColorRef opaqueBlackColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:1].CGColor;
    CGColorRef transparentBalckColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4].CGColor;

     //遮罩效果由CAGradientLayer实现
    CAGradientLayer * layer = [[CAGradientLayer alloc]init];
    layer.frame = CGRectMake(0, 0, WIDTH, self.blackView.bounds.size.height);

    //设置渐变的方向
    layer.startPoint = CGPointMake(0, 1);
    layer.endPoint = CGPointMake(0, 0);

    //设置渐变得颜色范围
    layer.colors = @[(__bridge id)opaqueBlackColor,(__bridge id)transparentBalckColor];

    [self.blackView.layer insertSublayer:layer atIndex:0];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 网络编程]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/07/ios80/"/>
    <updated>2016-03-07T22:45:23+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/07/ios80</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近要给quanta的小朋友讲iOS网络编程的相关知识，所以提前在这里梳理。</p>

<h2>何为HTTP</h2>

<p>首先我们必须了解HTTP协议，何为HTTP?超文本传送协议，它是基于应用层的通信规范，是一个设计来使客户端和服务器顺利进行通讯的协议。
HTTP做了以下几方面的规定：  <br/>
<code>1.</code> request和response的格式；  <br/>
<code>2.</code> 建立连接的方法，有持久连接和非持久连接。HTTP1.1默认是带流水的持久连接；  <br/>
         非持久连接：服务器发出一个对象后，相应TCP连接关闭，每个TCP连接只用于传输一个请求消息和一个响应消息；  <br/>
         持久连接：单个持久TCP连接，它分为不带流水线和流水线。不带流水线的只有收到上个请求响应再请求；
<code>3.</code> 缓存机制（减少发送请求）；      <br/>
<code>4.</code> 响应授权激发机制，用于服务器激发客户端请求并授权；</p>

<p>过程：客户端先建立一个TCP连接，再发送一个请求，服务器收到请求处理后响应，传送数据，客户端可以继续发生请求或关闭TCP</p>

<h2>GET与POST</h2>

<p>GET与POST是两种请求方式，GET主要用于从指定的服务器中获取数据，POST主要用于提交数据给指定服务器
区别：  <br/>
GET请求能够被缓存，POST请求不能被缓存下来
GET提交的数据放在url(以？分割url和传输数据，参数之间以&amp;相连)      <br/>
GET请求会保存在浏览器的浏览记录中，POST请求不会保存在浏览器浏览记录中  <br/>
以GET请求的URL能够保存为浏览器书签，以POST请求的URL无法保存为浏览器书签  <br/>
GET请求有长度限制，POST请求无长度限制
GET安全性没有POST好，因为GET提交的参数是可见</p>

<h2>iOS网络编程</h2>

<p>在iOS9之前，我们主要利用NSURLConnection来进行网络请求操作，在iOS9以后，苹果推荐使用NSURLSession。具体如何使用这些类来进行网络请求，我以代码加注释的形式呈现出来。</p>

<pre><code class="ObjC">    /**
     * 可变请求与不可变请求的区别：
     * 1、不可变请求在初始化的时候需要指定url，而可变请求可以以后指定
     * 2、cachePolicy缓存策略 timeoutInterval超时时间
     **/

    NSURLRequest* request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://a1.jikexueyuan.com/home/201601/25/1f7e/56a5887620a10.png"] cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:60];



    /**
     * iOS 9以前 请求,默认是GET
     **/
    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
        //解析json数据
        NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
        NSLog(@"%@",dict);
       dispatch_async(dispatch_get_main_queue(), ^{
           _imageView.image = [UIImage imageWithData:data];
       });
    }];


    /**
     * iOS 9 请求
    **/
    NSMutableURLRequest* request2 = [[NSMutableURLRequest alloc]init];
    request2.URL = [NSURL URLWithString:@"http://a1.jikexueyuan.com/home/201601/25/1f7e/56a5887620a10.png"];
    request2.HTTPMethod = @"GET";

    NSURLSession* session = [NSURLSession sharedSession];

    [[session dataTaskWithRequest:request2 completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"%@",data);
            _imageView.image = [UIImage imageWithData:data];
        });
    }] resume];
    //记得resume 唤醒 suspend 暂停

    /**
     * 上传 用POST，具体可以看这个链接 http://borissun.iteye.com/blog/1338991
     **/
    NSMutableURLRequest* postRequest = [[NSMutableURLRequest alloc]init];
    postRequest.URL = [NSURL URLWithString:@""];
    NSInputStream* inStream = [NSInputStream inputStreamWithFileAtPath:@""];
    postRequest.HTTPBodyStream = inStream;
    postRequest.HTTPMethod = @"POST";
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9适配]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/06/ios77/"/>
    <updated>2016-03-06T12:22:31+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/06/ios77</id>
    <content type="html"><![CDATA[<h2>MARK</h2>

<p>开发遇到适配iOS9的问题，这里mark一下</p>

<p><code>1.</code> 默认使用HTTPS请求  <br/>
如果在Xcode 9之前使用的时http请求，那么在XCode 9上编译的App是不能联网的，会提示如下错误:
App Transport Security has blocked a cleartext HTTP (<a href="http://">http://</a>) resource load since it is insecure. Temporary exceptions can be configured via your app&rsquo;s Info.plist file.  <br/>
修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，因此推荐使用后面一种方法，具体的做法是:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>

<p><code>2.</code> iOS 9使用URL scheme必须将其加入白名单  <br/>
否则会提示类似如下错误:  <br/>
canOpenURL: failed for URL: &ldquo;mqqopensdkapiV2://qqapp&rdquo; - error: &ldquo;This app is not allowed to query for scheme mqqopensdkapiV2”  <br/>
修正方法是，Info.plist文件中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。特酷吧在项目中使用了qq，微信等分享登录功能，需要添加的值为：  <br/>
mqqopensdkapiV2  <br/>
mqqOpensdkSSoLogin  <br/>
mqq  <br/>
mqzoneopensdkapiV2  <br/>
mqzoneopensdkapi19  <br/>
mqzoneopensdkapi  <br/>
mqzoneopensdk  <br/>
mqzone  <br/>
weixin  <br/>
wechat  <br/>
更多其他适配点后续不断跟进。</p>

<p><code>3.</code> bitcode  <br/>
使用Xcode7编译提示：XXX does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64  <br/>
bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。    bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。  <br/>
Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”->”Enable Bitcode”选项中看关闭bitcode即可。  <br/>
开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。</p>

<p><code>4.</code> 使用XCode7链接第三方库提示warning  <br/>
Lots of warnings when building with Xcode 7 with 3rd party libraries  <br/>
warning: Could not resolve external type c:objc(cs)NSString  <br/>
warning: Could not resolve external type c:objc(cs)NSDictionary  <br/>
warning: Could not resolve external type c:objc(cs)NSMutableString  <br/>
warning: Could not resolve external type c:objc(cs)NSError  <br/>
<a href="https://forums.developer.apple.com/thread/17921">https://forums.developer.apple.com/thread/17921</a>  <br/>
目前没发现好的解决办法，可以尝试如下:  <br/>
I had this problem too.  Here&rsquo;s how I fixed it.  <br/>
1)  Go to Build Settings -> Build Options -> Debug Information Format  <br/>
2)  Change the Debug setting from &ldquo;DWARF with dSYM File&rdquo; to &ldquo;DWARF&rdquo;  <br/>
3)  Leave the Release setting at &ldquo;DWARF with dSYM File&rdquo;  <br/>
The problem appears to be that Xcode was trying to create dSYM files for Debug     builds.  You don&rsquo;t need dSYM files for Debug builds &ndash; it&rsquo;s release builds where you need them.</p>
]]></content>
  </entry>
  
</feed>
