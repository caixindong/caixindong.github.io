<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-04T22:27:54+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[简析SDWebImage]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/26/ios66/"/>
    <updated>2016-02-26T22:31:56+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/26/ios66</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>SDWebImage是一个强大的第三方图片异步加载库，从事iOS开发的人或多或少用过它。今天我点开源码一看，里面一些实现细节确实令人玩味。</p>

<h1>简析</h1>

<pre><code class="objC">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;
</code></pre>

<p>这个是这个库里最常用的方法，传一个url，UIImageView就会将图片加载出来，这个方法看起来简单，可是背后的实现没那么容易，不禁感慨大神之牛，巧妙的设计和背后复杂的实现竟然浓缩成这样的一个接口函数。</p>

<h2>点进去看源码</h2>

<pre><code class="objC">[self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];
</code></pre>

<p>这个是原始接口</p>

<h2>点进去看源码</h2>

<p>我可以看到这个函数体</p>

<pre><code class="objc">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 
</code></pre>

<p>这个函数体就是就是sd_setImage的实现逻辑</p>

<pre><code class="objC">[self sd_cancelCurrentImageLoad];
</code></pre>

<p>首先，它先取消下载队列里正在进行的任务；
如果有placeholder，就先将它显示出来；
接着就是实现逻辑的主要部分</p>

<pre><code class="objC">id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {};
</code></pre>

<h2>点进去看源码</h2>

<pre><code class="objC">__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];
</code></pre>

<p>首先，先启动一个新的operation；</p>

<pre><code class="objC">    @synchronized (self.failedURLs) {
        isFailedUrl = [self.failedURLs containsObject:url];
    }

    if (!url || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
        dispatch_main_sync_safe(^{
            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);
        });
        return operation;
    }
    @synchronized (self.runningOperations) {
        [self.runningOperations addObject:operation];
    }
</code></pre>

<p>接着我们可以看到一个实现的亮点，它用一个failedURLs集合来记录失败或者无效的url，如果传进来的url是failedURLs里或者是为空，则return出去,否则将operation添加到运行的operation数组中。</p>

<pre><code class="objC"> NSString *key = [self cacheKeyForURL:url];
    }
</code></pre>

<p>它将url缓存起来,给他一个key值</p>

<pre><code class="objC">operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {};
</code></pre>

<p>根据缓存的url来寻找是否有对应的缓存</p>

<h2>点进去看源码</h2>

<pre><code class="objC">UIImage *image = [self imageFromMemoryCacheForKey:key];
if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }
</code></pre>

<p>先在内存里寻找，SDImage用的内存缓存是用NSCache实现的，如果有就是block回调，return；</p>

<pre><code class="objC">  UIImage *diskImage = [self diskImageForKey:key];
            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) {
                NSUInteger cost = SDCacheCostForImage(diskImage);
                [self.memCache setObject:diskImage forKey:key cost:cost];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
</code></pre>

<p>如果没有，就从磁盘缓存里找，如果找到了，就将他缓存到内存中，block回调</p>

<h2>如果都没找到</h2>

<pre><code class="objC">id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) {};
</code></pre>

<p>则开启下载operation下载图片，下载利用NSURLConnection实现</p>

<h2>点进去看源码</h2>

<p>初始化和完善请求头，将下载operation添加到下载队列中</p>

<pre><code class="objC">wself.lastAddedOperation = operation;
</code></pre>

<p>同时记录最后一个下载操作，return，成功block回调，利用SDImageCache将图片缓存到内存和磁盘中，并将operation从运行的operation数组移除，如果失败则记录他是一个失败的url，成功则加载图片，主线程刷新UI。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS本地推送功能实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/01/11/ios20/"/>
    <updated>2016-01-11T15:49:33+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/01/11/ios20</id>
    <content type="html"><![CDATA[<p>1、首先在AppDelegate注册推送</p>

<pre><code class="objc">    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {


        if ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) {

        //注册推送, iOS 8以上
        UIUserNotificationSettings *settings = [UIUserNotificationSettings

                                                settingsForTypes:(UIUserNotificationTypeBadge |

                                                                  UIUserNotificationTypeSound |

                                                                  UIUserNotificationTypeAlert)

                                                categories:nil];

        [application registerUserNotificationSettings:settings];
        [application registerForRemoteNotifications];

    } else {
        //注册推送, 适配系统版本iOS 8以下的手机
        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge |

        UIRemoteNotificationTypeAlert |

        UIRemoteNotificationTypeSound;

        [application registerForRemoteNotificationTypes:myTypes];

    }


    return YES;
    }
</code></pre>

<p>2、注册成功与否的回调</p>

<pre><code class="objc">    - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken {
            NSLog(@"device token is %@",deviceToken);
    }

    - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error{
            NSLog(@"push fail error is %@",error);
    }
</code></pre>

<p>3、获取本地通知数据回调</p>

<pre><code class="objc">    - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{
            NSLog(@"get notification");
            //获取通知后的操作
    }
</code></pre>

<p>4、发起本地推送</p>

<pre><code class="objc">    -(void)sendLocalNotifation{
        UILocalNotification* notifation = [[UILocalNotification alloc]init];
        //当前时间5秒后
        NSDate* pushDate = [NSDate dateWithTimeIntervalSinceNow:5];
        if (notifation!=nil) {
            //设置推送时间
            notifation.fireDate = pushDate;
            //设置时区
            notifation.timeZone = [NSTimeZone defaultTimeZone];
            //设置重复次数
            notifation.repeatInterval = 0;
            notifation.soundName = UILocalNotificationDefaultSoundName;
            //通知弹窗的文本
            notifation.alertBody = @"推送的文本";
            //设置icon小红点
            notifation.applicationIconBadgeNumber = 1;
            //设置userinfo 方便在之后需要撤销的时候使用
            NSDictionary* info = [NSDictionary dictionaryWithObject:@"通知的名字" forKey:@"key"];
            notifation.userInfo = info;
            //添加推送到UIApplication
            UIApplication* app = [UIApplication sharedApplication];
            [app scheduleLocalNotification:notifation];
        }
    }
</code></pre>

<p>5、解除本地推送</p>

<pre><code class="objc">    -(void)cancleLocalNotifation{
        UIApplication* app = [UIApplication sharedApplication];
        //获取所有本地推送
        NSArray* localArray = [app scheduledLocalNotifications];
        UILocalNotification* notification;
        if (localArray) {
            for(UILocalNotification* noti in localArray){
            NSDictionary* userInfo = noti.userInfo;
            if (userInfo) {
                NSString *keyValue = [userInfo objectForKey:@"key"];
                if ([keyValue isEqualToString:@"通知的名字"]) {
                    notification = noti;
                    [app cancelLocalNotification:notification];
                }
            }
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS图片压缩及上传]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/31/ios19/"/>
    <updated>2015-12-31T22:51:47+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/31/ios19</id>
    <content type="html"><![CDATA[<p>1、在工具类定义压缩图片的方法,传入图片和所要压缩的尺寸</p>

<pre><code class="objc ">    +(UIImage *)imageWithImage:(UIImage *)image scaleToSize :(CGSize )newSize{

    UIGraphicsBeginImageContext(newSize);

    [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];

    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();

    UIGraphicsEndImageContext();

    return newImage;

    }
</code></pre>

<p>2、利用AFNetworking做图片上传功能</p>

<pre><code class="objc">    +(void)POSTToUrl:(NSString *)url WithData:(NSData *)data 
        WithReturnBlock:(ReturnValueBlock)block         
        WithErrorCodeBlock:(ErrorCodeBlock)errorBlock       
        WithFailtureBlock:(FailureBlock)failtureBlock{

        AFHTTPRequestOperationManager* manager = [[AFHTTPRequestOperationManager alloc]init];

        manager.requestSerializer = [AFHTTPRequestSerializer serializer];
        manager.responseSerializer = [AFJSONResponseSerializer serializer];     

        //不设置可能会出现404的bug
        manager.responseSerializer.acceptableContentTypes =     [manager.responseSerializer.acceptableContentTypes   setByAddingObject:@"text/html"];

        [manager POST:url parameters:nil 
        constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
            //以上传的时间为图片名
            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
            formatter.dateFormat = @"yyyyMMddHHmmss";
            NSString *str = [formatter stringFromDate:[NSDate date]];
            NSString *fileName = [NSString stringWithFormat:@"%@.png", str];

            [formData appendPartWithFileData:data 
            name:@"upload" //upload.php处理文件的字段
            fileName:fileName //图片名字 
            mimeType:@"image/png"];

        }success:^(AFHTTPRequestOperation *operation,id responseObject) {
            //上传成功
        }failure:^(AFHTTPRequestOperation *operation,NSError *error) {
            //上传失败
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中遇过的一些小bug（二）]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/18/ios18/"/>
    <updated>2015-12-18T21:12:27+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/18/ios18</id>
    <content type="html"><![CDATA[<p>1、block会release，所以在使用的时候记得非空判断，特别在使用AFNetworking block交互的时候</p>

<p>2、有时候在真机测试的时，某些第三方库编译不通过，可能bitcode没关，可以在build setting里面将这个值设为no。苹果文档是这样说的：bitcode是被编译程序的一种中间形式的代码，包含bitcode配置的程序将会在App store上被编译和链接，bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个比较有趣的界面过渡动画]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/19/ios17/"/>
    <updated>2015-11-19T16:35:49+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/19/ios17</id>
    <content type="html"><![CDATA[<p>动画的类型依次为立方，吸走，翻转，水波，翻页，翻页回，打开相机，关闭相机</p>

<pre><code>NSString *Types[]={@"cube",
@"suckEffect",
@"oglFlip",
@"rippleEffect",
@"pageCurl",
@"pageUnCurl",
@"cameraIrisHollowOpen",
@"cameraIrisHollowClose"};
</code></pre>

<p>直接贴代码</p>

<pre><code>CATransition *animation = [CATransition animation];
[animation setDuration:0.8];
//设置动画的类型
[animation setType: @"rippleEffect"];
//设置动画变化快慢得函数
[animation setTimingFunction:[CAMediaTimingFunction functionWithName:
kCAMediaTimingFunctionLinear]];
[self.navigationController.view.layer addAnimation:animation forKey:nil];
[self.navigationController pushViewController:tvc animated:NO];
</code></pre>
]]></content>
  </entry>
  
</feed>
