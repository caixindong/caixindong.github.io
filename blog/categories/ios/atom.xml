<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2015-12-18T21:21:19+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS遇过的bug（一）]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/18/ios18/"/>
    <updated>2015-12-18T21:12:27+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/18/ios18</id>
    <content type="html"><![CDATA[<p>1、block会release，所以在使用的时候记得非空判断，特别在使用AFNetworking block交互的时候</p>

<p>2、有时候在真机测试的时，某些第三方库编译不通过，可能bitcode没关，可以在build setting里面将这个值设为no。苹果文档是这样说的：bitcode是被编译程序的一种中间形式的代码，包含bitcode配置的程序将会在App store上被编译和链接，bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个比较有趣的界面过渡动画]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/19/ios17/"/>
    <updated>2015-11-19T16:35:49+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/19/ios17</id>
    <content type="html"><![CDATA[<p>动画的类型依次为立方，吸走，翻转，水波，翻页，翻页回，打开相机，关闭相机</p>

<pre><code>NSString *Types[]={@"cube",
@"suckEffect",
@"oglFlip",
@"rippleEffect",
@"pageCurl",
@"pageUnCurl",
@"cameraIrisHollowOpen",
@"cameraIrisHollowClose"};
</code></pre>

<p>直接贴代码</p>

<pre><code>CATransition *animation = [CATransition animation];
[animation setDuration:0.8];
//设置动画的类型
[animation setType: @"rippleEffect"];
//设置动画变化快慢得函数
[animation setTimingFunction:[CAMediaTimingFunction functionWithName:
kCAMediaTimingFunctionLinear]];
[self.navigationController.view.layer addAnimation:animation forKey:nil];
[self.navigationController pushViewController:tvc animated:NO];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中遇过的一些小bug（一）]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/19/ios16/"/>
    <updated>2015-11-19T16:20:47+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/19/ios16</id>
    <content type="html"><![CDATA[<p>  当我们在使用<code>UITableView</code>的时候或者其他类<code>UIScrollView</code>的UI组件时，我们可能会遇到UITableView顶部留有一段空白区域的情况，那是因为<code>iOS 7</code> viewcontroller新增属性<code>automaticallyAdjustsScrollViewInsets</code>，即是否根据按所在界面的navigationbar与tabbar的高度，自动调整scrollview的 inset。如果我们不想要那段空白，将<code>automaticallyAdjustsScrollViewInsets</code>这个值设为<code>NO</code>就可以解决这个问题了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[强大的FastCoder]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/08/ios15/"/>
    <updated>2015-11-08T21:31:42+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/08/ios15</id>
    <content type="html"><![CDATA[<p>FastCoder是一个Cocoa object和object graph的高性能二进制序列化格式,可以作为Property Lists和JSON的替代选择。通过两个简单的方法就可以实现任意对象和NSData之间的相互转化</p>

<p>1、对象转化为NSData</p>

<pre><code>NSData *data = [FastCoder dataWithRootObject:obj];
</code></pre>

<p>2、从中NSData取回对象</p>

<pre><code>id obj = [FastCoder objectWithData:data];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为项目添加定位和导航功能]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/25/ios14/"/>
    <updated>2015-10-25T10:10:17+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/25/ios14</id>
    <content type="html"><![CDATA[<p>现在不少App都配备了定位和导航的功能，今天我教大家用iOS原生态的方法来实现这个两个功能。我们通过系统提供的CoreLocation和MapKit来实现。接下来用代码来演示。</p>

<p>1、添加MapView并且实例化它</p>

<pre><code>MKMapView* myMapView = = [[MKMapView alloc]initWithFrame:self.view.frame];

//让MapView显示当前位置
[myMapView setShowsUserLocation:YES];

//设置代理（MKMapViewDelegate）
myMapView.delegate = self;
[self.view addSubview:myMapView];
</code></pre>

<p>2、声明CLLocationManager并且实例化它，实现定位功能</p>

<pre><code>CLLocationManager* manager;
if (manager==nil) {
    manager = [[CLLocationManager alloc]init];
    if ([manager respondsToSelector:@selector(requestWhenInUseAuthorization)]) {
        [_manager requestWhenInUseAuthorization];

        //设置代理（CLLocationManagerDelegate）
        manager.delegate = self;

        //设置定位精度
        manager.desiredAccuracy = kCLLocationAccuracyBest;

        //设置距离筛选
        manager.distanceFilter = 100;
    }
}
//开始定位
[manager startUpdatingLocation];
</code></pre>

<p>注意：使用定位时记得在Info.plist添加NSLocationWhenInUseUsageDescription这个键值</p>

<p>3、实现CLLocationManagerDelegate的方法</p>

<pre><code>//定位成功的回调
-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations{
    //获取定位成功的经纬度
    CLLocation* location1 = locations.firstObject;
    CLLocationCoordinate2D centerCoordinate2D = location1.coordinate;

    //为MapView添加大头针
     MKPointAnnotation* localAnnotstion = [[MKPointAnnotation alloc]init];
    localAnnotstion.coordinate = centerCoordinate2D;
    localAnnotstion.title = @"当前位置";
    [_myMapView addAnnotation:localAnnotstion];

    //设置MapView的显示区域
    MKCoordinateRegion region1 = MKCoordinateRegionMakeWithDistance(centerCoordinate2D, 500, 500);
    [myMapView setRegion:[myMapView regionThatFits:region1] animated:YES];

    //定位成功就导航，设置导航路线的起点
    MKPlacemark* localPlacemark = [[MKPlacemark alloc]initWithCoordinate:centerCoordinate2D addressDictionary:nil];
    MKMapItem* fromItem = [[MKMapItem alloc]initWithPlacemark:localPlacemark];

    //createLineFromCurrentSite是我自己写的方法，用来获取导航路线和获取导航步骤
    //myItem指导航的终点，它实例化参考上面fromItem的实例化
    [self createLineFromCurrentSite:fromItem to:myItem];

    //停止定位
    [manager stopUpdatingLocation];

}

//定位失败的回调
-(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error{
NSLog(@"guide error is %@",error);
}
</code></pre>

<p>4、createLineFromCurrentSite方法的实现，用来用来获取导航路线和获取导航步骤</p>

<pre><code>-(void)createLineFromCurrentSite:(MKMapItem*) fromItem to:(MKMapItem*)toItem{
    //实例化导航请求
    MKDirectionsRequest* request = [[MKDirectionsRequest alloc]init];

    //设置导航的起点和终点
    request.source = fromItem;
    request.destination = toItem;

    //为no时只显示一条导航路线
    request.requestsAlternateRoutes = NO;

    //实例化MKDirections
    MKDirections* directions = [[MKDirections alloc]initWithRequest:request];

    //如果当前导航好没结束，就取消下一次导航请求
    if (directions.calculating) {
        [directions cancel];
    }

    //开始导航，在block里面写回调的方法
    [directions calculateDirectionsWithCompletionHandler:^(MKDirectionsResponse * _Nullable response, NSError * _Nullable error) {
        if (response.routes.count==0|| error) {
        //导航失败
            NSLog(@"directions error is %@",error);
        }else{
        //导航成功
            for (MKRoute* route in response.routes) {
                for (MKRouteStep* step in route.steps) {
               //打印导航的步骤
                NSLog(@"导航:%@", step.instructions);
            }
        //将导航路线添加到MapView上面
        [myMapView addOverlay:route.polyline level:MKOverlayLevelAboveRoads];
        }
    }
    }];
}
</code></pre>

<p>5、实现MKMapViewDelegate的方法</p>

<pre><code>//通过这个方法来帮我们绘制导航路线
-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay{
    if ([overlay isKindOfClass:[MKPolyline class]]) {
        //设置渲染器
        MKPolylineRenderer* renderer = [[MKPolylineRenderer alloc]initWithPolyline:overlay];

        //设置线的长度
        [renderer setLineWidth:2];

        //设置线的颜色
        [renderer setStrokeColor:[UIColor redColor]];
        return renderer;
}
    return nil;

}
</code></pre>
]]></content>
  </entry>
  
</feed>
