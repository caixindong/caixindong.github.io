<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2015-11-08T21:37:42+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[强大的FastCoder]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/08/ios15/"/>
    <updated>2015-11-08T21:31:42+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/08/ios15</id>
    <content type="html"><![CDATA[<p>FastCoder是一个Cocoa object和object graph的高性能二进制序列化格式,可以作为Property Lists和JSON的替代选择。通过两个简单的方法就可以实现任意对象和NSData之间的相互转化</p>

<p>1、对象转化为NSData</p>

<pre><code>NSData *data = [FastCoder dataWithRootObject:obj];
</code></pre>

<p>2、从中NSData取回对象</p>

<pre><code>id obj = [FastCoder objectWithData:data];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为项目添加定位和导航功能]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/25/ios14/"/>
    <updated>2015-10-25T10:10:17+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/25/ios14</id>
    <content type="html"><![CDATA[<p>现在不少App都配备了定位和导航的功能，今天我教大家用iOS原生态的方法来实现这个两个功能。我们通过系统提供的CoreLocation和MapKit来实现。接下来用代码来演示。</p>

<p>1、添加MapView并且实例化它</p>

<pre><code>MKMapView* myMapView = = [[MKMapView alloc]initWithFrame:self.view.frame];

//让MapView显示当前位置
[myMapView setShowsUserLocation:YES];

//设置代理（MKMapViewDelegate）
myMapView.delegate = self;
[self.view addSubview:myMapView];
</code></pre>

<p>2、声明CLLocationManager并且实例化它，实现定位功能</p>

<pre><code>CLLocationManager* manager;
if (manager==nil) {
    manager = [[CLLocationManager alloc]init];
    if ([manager respondsToSelector:@selector(requestWhenInUseAuthorization)]) {
        [_manager requestWhenInUseAuthorization];

        //设置代理（CLLocationManagerDelegate）
        manager.delegate = self;

        //设置定位精度
        manager.desiredAccuracy = kCLLocationAccuracyBest;

        //设置距离筛选
        manager.distanceFilter = 100;
    }
}
//开始定位
[manager startUpdatingLocation];
</code></pre>

<p>注意：使用定位时记得在Info.plist添加NSLocationWhenInUseUsageDescription这个键值</p>

<p>3、实现CLLocationManagerDelegate的方法</p>

<pre><code>//定位成功的回调
-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations{
    //获取定位成功的经纬度
    CLLocation* location1 = locations.firstObject;
    CLLocationCoordinate2D centerCoordinate2D = location1.coordinate;

    //为MapView添加大头针
     MKPointAnnotation* localAnnotstion = [[MKPointAnnotation alloc]init];
    localAnnotstion.coordinate = centerCoordinate2D;
    localAnnotstion.title = @"当前位置";
    [_myMapView addAnnotation:localAnnotstion];

    //设置MapView的显示区域
    MKCoordinateRegion region1 = MKCoordinateRegionMakeWithDistance(centerCoordinate2D, 500, 500);
    [myMapView setRegion:[myMapView regionThatFits:region1] animated:YES];

    //定位成功就导航，设置导航路线的起点
    MKPlacemark* localPlacemark = [[MKPlacemark alloc]initWithCoordinate:centerCoordinate2D addressDictionary:nil];
    MKMapItem* fromItem = [[MKMapItem alloc]initWithPlacemark:localPlacemark];

    //createLineFromCurrentSite是我自己写的方法，用来获取导航路线和获取导航步骤
    //myItem指导航的终点，它实例化参考上面fromItem的实例化
    [self createLineFromCurrentSite:fromItem to:myItem];

    //停止定位
    [manager stopUpdatingLocation];

}

//定位失败的回调
-(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error{
NSLog(@"guide error is %@",error);
}
</code></pre>

<p>4、createLineFromCurrentSite方法的实现，用来用来获取导航路线和获取导航步骤</p>

<pre><code>-(void)createLineFromCurrentSite:(MKMapItem*) fromItem to:(MKMapItem*)toItem{
    //实例化导航请求
    MKDirectionsRequest* request = [[MKDirectionsRequest alloc]init];

    //设置导航的起点和终点
    request.source = fromItem;
    request.destination = toItem;

    //为no时只显示一条导航路线
    request.requestsAlternateRoutes = NO;

    //实例化MKDirections
    MKDirections* directions = [[MKDirections alloc]initWithRequest:request];

    //如果当前导航好没结束，就取消下一次导航请求
    if (directions.calculating) {
        [directions cancel];
    }

    //开始导航，在block里面写回调的方法
    [directions calculateDirectionsWithCompletionHandler:^(MKDirectionsResponse * _Nullable response, NSError * _Nullable error) {
        if (response.routes.count==0|| error) {
        //导航失败
            NSLog(@"directions error is %@",error);
        }else{
        //导航成功
            for (MKRoute* route in response.routes) {
                for (MKRouteStep* step in route.steps) {
               //打印导航的步骤
                NSLog(@"导航:%@", step.instructions);
            }
        //将导航路线添加到MapView上面
        [myMapView addOverlay:route.polyline level:MKOverlayLevelAboveRoads];
        }
    }
    }];
}
</code></pre>

<p>5、实现MKMapViewDelegate的方法</p>

<pre><code>//通过这个方法来帮我们绘制导航路线
-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay{
    if ([overlay isKindOfClass:[MKPolyline class]]) {
        //设置渲染器
        MKPolylineRenderer* renderer = [[MKPolylineRenderer alloc]initWithPolyline:overlay];

        //设置线的长度
        [renderer setLineWidth:2];

        //设置线的颜色
        [renderer setStrokeColor:[UIColor redColor]];
        return renderer;
}
    return nil;

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MKLocalSearch附近兴趣点的搜索]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/19/ios13/"/>
    <updated>2015-10-19T23:42:39+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/19/ios13</id>
    <content type="html"><![CDATA[<p>现在很多主流app都有涉及到O2O的模块，根据用户的需求和用户的位置，给用户提供最准确最贴心的服务。其中LBS功能可以帮我们实现这一点。这次刚好用到它，所以拿它出来说说。功能主要通过iOS原生方法MKLocalSearch实现。</p>

<pre><code>//实例化一个搜索请求
MKLocalSearchRequest* request = [[MKLocalSearchRequest alloc]init];

//searchStr：搜索的内容
request.naturalLanguageQuery = searchStr;

//指定搜索范围，如果用的是模拟器，可以模拟一个经纬度(23.071123, 113.404434)
request.region = MKCoordinateRegionMakeWithDistance(CLLocationCoordinate2DMake(23.071123, 113.404434),
 1000, 1000);

//实例化 MKLocalSearch
MKLocalSearch localSearch = [[MKLocalSearch alloc]initWithRequest:request];

//开始搜索
[localSearch startWithCompletionHandler:^(MKLocalSearchResponse * _Nullable response,
 NSError * _Nullable error) {
    if (response.mapItems.count==0||error!=nil) {
        NSLog(@"error : %@",error);
    }else{
        //取得搜索后的结果 response.mapItems
    }
}];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Parse为我们的app构建后台服务]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/15/ios12/"/>
    <updated>2015-10-15T16:26:52+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/15/ios12</id>
    <content type="html"><![CDATA[<p>一、什么是Parse?</p>

<p>Parse是一群美国人开发的专为移动APP服务的云计算平台，与现有的其他云计算平台相比，Parse除了提供Restful的service 之外，也提供了官方的iOS和Android SDK。</p>

<p>二、如何导入Parse的iOS SDK?</p>

<p>可以参考<a href="https://www.parse.com/docs">https://www.parse.com/docs</a></p>

<p>三、如何使用Parse为我们app实现登录注册功能</p>

<p>1、先在 <a href="https://www.parse.com">https://www.parse.com</a> 创建一个app，得到它的ApplicationId和clientKey，然后在AppDelegate注册，这是必要的配置工作</p>

<pre><code>#import &lt;Parse/Parse.h&gt;
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:
- (NSDictionary *)launchOptions {
// Initialize Parse.
[Parse setApplicationId:@"omV1NT7fu3QX91ph5lIBj5LANoaMhSvlxXC5Awdt"
              clientKey:@"hMXPZhDtZ14lNKpZuuuodtxo0RCramJHDN0go4Uy"];
return YES;
} 
</code></pre>

<p>2、在你的app的注册界面实例化一个PFUser对象，用用户的注册信息对它属性进行赋值，并提交它</p>

<pre><code>PFUser* myuser = [[PFUser alloc]init];
myuser.username = userPhoneNum;//用户名
myuser.password = userPassword;//密码
myuser.email = userEmail;//邮箱

[myuser signUpInBackgroundWithBlock:^(BOOL succeeded, NSError * _Nullable error) {
    if (!succeeded) {
        //注册失败
    }else{
        //注册成功
   }
}];
</code></pre>

<p>3、在你的app的登录界面，将登录信息提交给Parse后台进行验证</p>

<pre><code>[PFUser logInWithUsernameInBackground:username password:password 
    block:^(PFUser * _Nullable user, NSError * _Nullable error) {
    //username和password是你提交的登录信息
    if (user!=nil) {
        //登录成功
    }else{
        //登录失败
    }
}];
</code></pre>

<p>4、退出当前账号</p>

<pre><code>[PFUser logOutInBackgroundWithBlock:^(NSError * _Nullable error) {
    if (error) {
      //退出失败  
    }else{
       //退出成功 
    }
}];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抽屉视图（MMDrawerController使用）]]></title>
    <link href="http://caixindong.github.io/blog/2015/10/14/ios11/"/>
    <updated>2015-10-14T19:06:18+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/10/14/ios11</id>
    <content type="html"><![CDATA[<p>1、初始化MMDrawerController，用这个controller装载我们的不同视图控制器</p>

<pre><code>MMDrawerController* drawerController = [[MMDrawerController alloc]
initWithCenterViewController:controller1 leftDrawerViewController:controller2];
</code></pre>

<p>controller1是主视图，controller2是左侧视图</p>

<p>2、为drawerController添加打开抽屉和关闭抽屉的手势</p>

<pre><code>drawerController.openDrawerGestureModeMask = MMOpenDrawerGestureModePanningCenterView;
drawerController.closeDrawerGestureModeMask = MMCloseDrawerGestureModePanningCenterView;
</code></pre>

<p>3、打开抽屉</p>

<pre><code>[drawerController toggleDrawerSide:MMDrawerSideLeft animated:YES completion:nil];
</code></pre>

<p>执行这个方法可以打开左侧抽屉视图，一般用作点击事件</p>

<p>详细使用：<a href="https://github.com/mutualmobile/MMDrawerController">https://github.com/mutualmobile/MMDrawerController</a></p>
]]></content>
  </entry>
  
</feed>
