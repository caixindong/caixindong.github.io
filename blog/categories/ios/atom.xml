<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-07-27T22:35:39+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解决iOS8以下UIAlertController无法使用的问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/07/27/ios94/"/>
    <updated>2016-07-27T22:33:08+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/07/27/ios94</id>
    <content type="html"><![CDATA[<h1>XDAlertController</h1>

<p>最近在一个项目中遇到的这样的一个问题iOS8以下UIAlertController无法使用，XDAlertController我的一个解决方案</p>

<h1>实现原理</h1>

<p>在iOS7环境下调用UIAlertController会崩溃，所以通过判断系统的版本号来调用不同的API；        
通过Method Swizzling替换原生的presentViewController和提供近似于原生API接口，让开发者感觉不出与原生API有什么差别。（Method Swizzling通过method_exchangeImplementations交换方法，交换时期在调用load的时候，里面涉及runtime相关知识，如果理解起来吃力，可以移步到<a href="http://www.jianshu.com/p/43a0d64b0dbf">这边文章</a>了解
）       </p>

<h1>使用</h1>

<pre><code class="ObjC">#import "XDAlertController.h"
...
XDAlertController *alert = [XDAlertController alertControllerWithTitle:@"我是actionsheet" message:@"123" preferredStyle:XDAlertControllerStyleActionSheet];
    XDAlertAction *action1 = [XDAlertAction actionWithTitle:@"default" style: XDAlertActionStyleDefault handler:^( XDAlertAction * _Nonnull action) {
        
    }];
    
    XDAlertAction *action2 = [XDAlertAction actionWithTitle:@"取消" style:XDAlertActionStyleCancel handler:^(XDAlertAction * _Nonnull action) {
        
    }];
    
    XDAlertAction *action3 = [XDAlertAction actionWithTitle:@"destructive" style:XDAlertActionStyleDestructive handler:^(XDAlertAction * _Nonnull action) {
        
    }];
    
    [alert addAction:action1];
    [alert addAction:action2];
    [alert addAction:action3];
    
    [self presentViewController:alert animated:YES completion:nil];
</code></pre>

<h1>github地址</h1>

<p><a href="https://github.com/caixindong/XDAlertController">https://github.com/caixindong/XDAlertController</a>
大家觉得喜欢就赏个star，有什么问题可以issue我或者在评论指出，相互学习</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多级展开列表的实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/07/17/ios93/"/>
    <updated>2016-07-17T14:38:50+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/07/17/ios93</id>
    <content type="html"><![CDATA[<h1>iOS多级展开列表的实现</h1>

<h2>效果图</h2>

<p><img src="/images/multTableView.gif"></p>

<h2>用法（类似UITableView）</h2>

<h3>初始化XDMultTableView</h3>

<pre><code class="ObjC">#import "XDMultTableView.h"
...
@property(nonatomic, readwrite, strong)XDMultTableView *tableView;

 _tableView = [[XDMultTableView alloc] initWithFrame:CGRectMake(0, 64, self.view.frame.size.width, self.view.frame.size.height-64)];
    _tableView.openSectionArray = [NSArray arrayWithObjects:@1,@2, nil];
    _tableView.delegate = self;
    _tableView.datasource = self;
    _tableView.backgroundColor = [UIColor whiteColor];
    [self.view addSubview:_tableView];
</code></pre>

<h3>实现数据源</h3>

<pre><code class="ObjC">
- (NSInteger)mTableView:(XDMultTableView *)mTableView numberOfRowsInSection:(NSInteger)section{
    return 5;
}

- (XDMultTableViewCell *)mTableView:(XDMultTableView *)mTableView
              cellForRowAtIndexPath:(NSIndexPath *)indexPath{
    static NSString *cellIdentifier = @"cell";
    UITableViewCell *cell = [mTableView dequeueReusableCellWithIdentifier:cellIdentifier];
    if (cell == nil)
    {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier];
    }
    UIView *view = [[UIView alloc] initWithFrame:cell.bounds] ;
    view.layer.backgroundColor  = [UIColor whiteColor].CGColor;
    view.layer.masksToBounds    = YES;
    view.layer.borderWidth      = 0.3;
    view.layer.borderColor      = [UIColor lightGrayColor].CGColor;

    cell.backgroundView = view;
    cell.selectionStyle = UITableViewCellSelectionStyleNone;

    return cell;
}

- (NSInteger)numberOfSectionsInTableView:(XDMultTableView *)mTableView{
    return 6;
}

-(NSString *)mTableView:(XDMultTableView *)mTableView titleForHeaderInSection:(NSInteger)section{
    return @"我是头部";
}
</code></pre>

<h3>实现代理</h3>

<pre><code class="ObjC">
- (CGFloat)mTableView:(XDMultTableView *)mTableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 50;
}

- (CGFloat)mTableView:(XDMultTableView *)mTableView heightForHeaderInSection:(NSInteger)section{
    return 40;
}


- (void)mTableView:(XDMultTableView *)mTableView willOpenHeaderAtSection:(NSInteger)section{
    NSLog(@"即将展开");
}


- (void)mTableView:(XDMultTableView *)mTableView willCloseHeaderAtSection:(NSInteger)section{
    NSLog(@"即将关闭");
}

- (void)mTableView:(XDMultTableView *)mTableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    NSLog(@"点击cell");
}
</code></pre>

<h2>列表展开关闭的实现原理</h2>

<h3>在section header注册一个手势</h3>

<pre><code class="ObjC ">//section header view 设置tag值为section
view.tag = section;
UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapHeader:)];
    [view addGestureRecognizer:tap];
</code></pre>

<h3>手势的响应事件</h3>

<pre><code class="ObjC">
- (void)tapHeader:(UITapGestureRecognizer *) tap {
    NSInteger section = tap.view.tag;
    NSNumber *sectionObj = [NSNumber numberWithInteger:section];
    UIImageView *imageView = (UIImageView *)[tap.view viewWithTag:100];
    //_multopenSectionArray 用于记录每个 section的展开和关闭状态
    if ([_multopenSectionArray containsObject:sectionObj]) {
        NSArray *deleteArray = [self buildDeleteRowWithSection:section];
        [_multopenSectionArray removeObject:sectionObj];
        //想关闭的section的所有indexPath
        [_tableView deleteRowsAtIndexPaths:deleteArray withRowAnimation:UITableViewRowAnimationFade];
        [UIView animateWithDuration:0.3 animations:^{
            imageView.transform = CGAffineTransformMakeRotation(-M_PI/2);
        }];
    }else{
        [_multopenSectionArray addObject:sectionObj];
        //想展开的section的所有indexPath
        NSArray *insertArray = [self buildInsertRowWithSection:section];
        [_tableView insertRowsAtIndexPaths:insertArray withRowAnimation:UITableViewRowAnimationFade];
        [UIView animateWithDuration:0.3 animations:^{
            imageView.transform = CGAffineTransformMakeRotation(0);
        }];
    }
}
</code></pre>

<h2><a href="https://github.com/caixindong/XDMultTableView">源码地址：https://github.com/caixindong/XDMultTableView</a></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runloop小笔记]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/20/ios92/"/>
    <updated>2016-05-20T20:44:54+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/20/ios92</id>
    <content type="html"><![CDATA[<h2>何为RunLoop</h2>

<p>RunLoop就是一直运行的循环。程序的持续运行和即时反应依赖于RunLoop。我们知道，一个线程一次只能执行一个任务，执行完后线程就会退出，而RunLoop就是一个机制使我们的线程能够随时处理事件而不退出。其实它实现逻辑很简单，就是在内部开启一个死循环。</p>

<pre><code class="ObjC">-(void)loop{
    do{
        bool isRunning = SomeToDo();
    }while(isRunning);
}
</code></pre>

<p>这种模型有个术语叫作Event Loop，实现这种模型的关键在于：   <br/>
1、 如何管理事件；   <br/>
2、 如何让线程在没有消息处理的时候休眠，在有事件响应的时候及时被唤醒；</p>

<h2>RunLoop是一个对象</h2>

<p>RunLoop管理着需要处理的事件和消息，并提供一个入口函数来执行上面Event Loop的逻辑。线程执行这个函数后就会处于“<strong>接受消息->等待->处理</strong>”的循环中,直到循环结束，函数返回。</p>

<h2>Cocoa 中的 RunLoop</h2>

<p>苹果为我们提供这样的两个对象：NSRunLoop 和 CFRunLoopRef 来实现RunLoop。  <br/>
NSRunLoop是基于CFRunLoopRef封装的，提供面向对象API，但是它不是线程安全的。  <br/>
CFRunLoopRef是CoreFoundation框架内的，它提供纯C的API，而且它是线程安全的。此外它是<a href="http://opensource.apple.com/tarballs/CF/">开源</a>的。      <br/>
我们这篇博客讲解也是主要基于CFRunLoopRef。</p>

<h2>RunLoop与线程</h2>

<p>pthread_t和NSThread都可以用于创建新线程，他们都是基于底层的mach thread封装的。且pthread_t与NSThread是一一对应的。CFRunLoop是基于pthread来管理的。  <br/>
苹果不允许直接创建RunLoop，它提供两个自动获取函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()。实现逻辑如下：</p>

<pre><code class="ObjC">// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;

// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;loopsLock);

    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    // 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));

    if (!loop) {
        // 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        // 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }

    OSSpinLockUnLock(&amp;loopsLock);
    return loop;
}

CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
</code></pre>

<p>由上面的代码，可看出，线程与RunLoop是一一对应，而且他们以键值对的关系保存在一个全局的字典里面。线程刚创建时是没有RunLoop，如果你不主动获取，那它一直都不会有。RunLoop的创建发生在第一次获取时，RunLoop的销毁发生在线程结束时。</p>

<h2>RunLoop对外提供的API</h2>

<p>CoreFoundation的RunLoop提供以下5个类：   <br/>
CFRunLoopRef  <br/>
CFRunLoopModeRef  <br/>
CFRunLoopSourceRef  <br/>
CFRunLoopTimerRef  <br/>
CFRUNLoopObserverRef  <br/>
他们的关系如下图：</p>

<p><img src="/images/RunLoop_0.png"></p>

<p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数，只能指定其中一个Mode，这个Mode被称为Current Mode。如果要切换Mode，只能退出Loop，再重新指定一个Mode进入，这样做是为了分隔不同组的Source/Timer/Observer，让其互不影响。</p>

<h3>CFRunLoopSourceRef</h3>

<p>是事件产生的地方，它有两个版本：Source0 和 Source 1。        <br/>
<strong>Source0</strong> 只包含一个回调（函数指针），它并不能主动触发事件，使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个source标记为待处理，然后手动调用CFRunLoopWakeUp(source)来唤醒RunLoop，让其处理这个事件。  <br/>
<strong>Source1</strong> 包含一个mach_port和一个回调，被用于通过内核和其他线程相互发送消息。这种Source能主动唤醒RunLoop线程。</p>

<h3>CFRunLoopTimerRef</h3>

<p>是基于时间的触发器，它与NSTimer是toll-free-bridged的，可以混用。它包含一个时间长度和一个回调。当其加入RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒去执行那个回调。</p>

<h3>CFRunLoopObserverRef</h3>

<p>是观察者，每个Observer包含一个回调，当RunLoop的状态发生变化时，观察者能通过回调接收到这个变化。以下是观察者观察的时间点：</p>

<pre><code class="ObjC">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></pre>

<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>

<h3>CFRunLoopMode</h3>

<p>有了以上的基础，来谈Mode比较容易理解。  <br/>
我们看下CFRunLoop和CFRunLoopMode的结构：</p>

<pre><code class="ObjC">struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};

struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
</code></pre>

<p>这里解释下commonModes和comminModeItems：  <br/>
一个Mode可以将自己标识为Common属性（通过将其ModeName添加到RunLoop的commonModes中）。每当RunLoop的内容发生变化时，RunLoop都会自动将commonModeItems里的Source/Observer/Timer同步到具有“Common”标识的所有Mode里。   <br/>
<strong>举例说明下</strong>：主线程的RunLoop里有两个预设的Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个Mode都已经被标志为“Common”属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并添加到DefaultMode时，Timer会得到重复回调，但当你滑动scrollView时，RunLoop会将Mode切换为TrackingRunLoopMode来保证滑动顺畅，这时Timer会停止回调。  <br/>
如果你想Timer在滑动的时候也有回调的话，有两种做法：  <br/>
一：将这个Timer分别加入这两个Mode；  <br/>
二：这个做法用得比较多，就是将Timer加入到顶层的RunLoop的“commonModeItems”中。“commonModeItems”被RunLoop自动更新到所有具有“Common”属性的Mode里去。</p>

<p>我们只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。
苹果公开提供Mode有两个：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，我们可以通过这两个Mode Name来操作相应的Mode。  <br/>
同时苹果还提供了一个操作Common标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，我们可以用这个字符串来操作Common Items 或标志一个Mode为“Common”。</p>

<h2>RunLoop的内部逻辑</h2>

<p>RunLoop内部实现逻辑大致如下图：</p>

<p><img src="/images/RunLoop_1.png"></p>

<p>代码实现逻辑如下：</p>

<pre><code class="ObjC">/// 用DefaultMode启动
void CFRunLoopRun(void) {
    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
}

/// 用指定的Mode启动，允许设置RunLoop超时时间
int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}

/// RunLoop的实现
int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {

    /// 首先根据modeName找到对应mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);
    /// 如果mode里没有source/timer/observer, 直接返回。
    if (__CFRunLoopModeIsEmpty(currentMode)) return;

    /// 1. 通知 Observers: RunLoop 即将进入 loop。
    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);

    /// 内部函数，进入loop
    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {

        Boolean sourceHandledThisLoop = NO;
        int retVal = 0;
        do {

            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);

            /// 4. RunLoop 触发 Source0 (非port) 回调。
            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);

            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__Source0DidDispatchPortLastTime) {
                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)
                if (hasMsg) goto handle_msg;
            }

            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
            if (!sourceHandledThisLoop) {
                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
            }

            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。
            /// • 一个基于 port 的Source 的事件。
            /// • 一个 Timer 到时间了
            /// • RunLoop 自身的超时时间到了
            /// • 被其他什么调用者手动唤醒
            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {
                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
            }

            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);

            /// 收到消息，处理消息。
            handle_msg:

            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。
            if (msg_is_timer) {
                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
            } 

            /// 9.2 如果有dispatch到main_queue的block，执行block。
            else if (msg_is_dispatch) {
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } 

            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件
            else {
                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
                if (sourceHandledThisLoop) {
                    mach_msg(reply, MACH_SEND_MSG, reply);
                }
            }

            /// 执行加入到Loop的block
            __CFRunLoopDoBlocks(runloop, currentMode);


            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
                /// 进入loop时参数说处理完事件就返回。
                retVal = kCFRunLoopRunHandledSource;
            } else if (timeout) {
                /// 超出传入参数标记的超时时间了
                retVal = kCFRunLoopRunTimedOut;
            } else if (__CFRunLoopIsStopped(runloop)) {
                /// 被外部调用者强制停止了
                retVal = kCFRunLoopRunStopped;
            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
                /// source/timer/observer一个都没有了
                retVal = kCFRunLoopRunFinished;
            }

            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。
        } while (retVal == 0);
    }

    /// 10. 通知 Observers: RunLoop 即将退出。
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
}
</code></pre>

<p>实际上RunLoop内部就是一个do-while循环，当你调用CFRunLoopRun（）时，线程就会一直停留在这个循环里，处于<strong>接受消息->等待->处理</strong>的循环中，直到超时或者手动停止，函数返回。</p>

<h2>RunLoop底层实现</h2>

<p>RunLoop的核心是基于mach port，在RunLoop进入休眠时，它调用mach_msg()等待mach port传消息过来，如果没有消息过来，内核会将线程置于等待状态。为了更好的了解mach port，我们先了解OSX/iOS的系统架构。</p>

<p><img src="/images/RunLoop_3.png"></p>

<p>苹果官方将整个系统大致划分为上述4个层次：  <br/>
<strong>应用层</strong>：包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。  <br/>
<strong>应用框架层</strong>：即开发人员接触到的 Cocoa 等框架。  <br/>
<strong>核心框架层</strong>：包括各种核心框架、OpenGL 等内容。  <br/>
<strong>Darwin</strong>： 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com">opensource.apple.com</a> 里找到。</p>

<p>我们再深入看下Darwin：</p>

<p><img src="/images/RunLoop_4.png"></p>

<p>其中，在硬件层上面由三部分组成：Mach、BSD、IOKit（还包括一些没标注的内容），共同组成XNU内核。  <br/>
XNU内核的内环被称为Mach，它作为一个微内核，仅提供诸如处理器调度、IPC（进程间通信）等非常少量的基础服务。  <br/>
BSD层可以看作围绕Mach层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。
IOKit层为设备驱动提供一个面向对象的框架（C++）。</p>

<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为"对象"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。"消息"是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>

<p>Mach 的消息定义是在 &lt;mach/message.h> 头文件的，很简单：</p>

<pre><code class="ObjC">typedef struct {
  mach_msg_header_t header;
  mach_msg_body_t body;
} mach_msg_base_t;

typedef struct {
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_t msgh_remote_port;
  mach_port_t msgh_local_port;
  mach_port_name_t msgh_voucher_port;
  mach_msg_id_t msgh_id;
} mach_msg_header_t;
</code></pre>

<p>一条Mach消息实际上就是一个二进制数据包（BLOB），其头部定义了当前端口local_port和目标端口remote_port。</p>

<pre><code class="ObjC">mach_msg_return_t mach_msg(
            mach_msg_header_t *msg,
            mach_msg_option_t option,
            mach_msg_size_t send_size,
            mach_msg_size_t rcv_size,
            mach_port_name_t rcv_name,
            mach_msg_timeout_t timeout,
            mach_port_name_t notify);
</code></pre>

<p>发送消息和接收消息是通过同个API进行的，其option标记了消息传递的方向。</p>

<p>为了实现消息的发送和接收，mach_msg()实际上是调用了一个Mach陷阱，即mach_msg_trap()，陷阱这个概念在Mach中等同于系统调用，当你在用户态调用mach_msg_trap()时会触发陷阱机制，切换到内核态，内核态中的内核实现的mach_msg()会完成实际的工作。例如你在在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block 之 Block内存管理]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/16/ios91/"/>
    <updated>2016-05-16T20:20:25+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/16/ios91</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>block的内存管理相对比较复杂，分ARC和MRC两种情况考虑，虽然现在开发基本是用ARC，编译器已经帮我们做了很多内存管理的优化，但我们不仅要知其然，也要知其所以然。</p>

<h2>Block的类型</h2>

<p>根据Block的存储方式，分为以下三种：
<code>.</code> <em>NSConcretStackBlock  <br/>
<code>.</code> </em>NSConcretGlobalBlock  <br/>
<code>.</code> _NSConcretMallocBlock  <br/>
这三种类型表明了Block的三种存储方式：栈、全局、堆。   <br/>
<strong>注意：</strong> 在ARC模式下，Block只存在全局和堆之中，对于栈上的Block，编译器帮我们拷贝到堆上，这也是为什么我们声明Block的时候即使不声明为copy，Block也是拷贝到堆上。显示地声明不会与编译器相冲突，是为了我们更好地理解是编译器做了copy这一步使得Block拷贝到堆上。</p>

<h3>全局Block</h3>

<p>位于全局存储区的Block有两种情况：  <br/>
<code>.</code> 定义在函数外面的Block；</p>

<pre><code class="ObjC">void (^myBlock)(void) = ^(){
    NSLog(@"hello");
};
</code></pre>

<p><code>.</code> 不引用局部变量的Block；</p>

<pre><code class="ObjC">
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^myBlock)(void) = ^(){
            NSLog(@"hello");
        };
        myBlock();

    }
    return 0;
}
</code></pre>

<h3>栈Block</h3>

<pre><code>typedef void (^stackBlock)() ;

stackBlock returnBlock(){
    int a =10;
    return ^{printf("a=%d\n",a);};
}
</code></pre>

<p>上面的例子在MRC下无法编译，而在ARC下可以编译  <br/>
这是因为返回block的时候是返回局部变量的指针,而这一点恰是编译器已经断定了。在ARC下可以编译过，是因为ARC使用autorelease了</p>

<h3>堆Block</h3>

<pre><code class="ObjC">id getBlockArray(){
    int val =10;
    return [NSArray arrayWithObjects:
            ^{NSLog(@"blk0:%d",val);},
            ^{NSLog(@"blk1:%d",val);},nil];
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {

        id obj = getBlockArray();
        typedef void (^blk_t)(void);
        blk_t blk = (blk_t)[obj objectAtIndex:0];
        blk();

    }
    return 0;
}
</code></pre>

<p>在MRC模式下，会发生异常，因为数组中的block是在栈上的，到blk指向的block已经释放内存了，访问blk就会造成崩溃，解决方法就是在block后面加上copy，使它变成堆上的block。</p>

<h2>copy的使用</h2>

<p>不管block配置在何处，用copy方法复制都不会引起任何问题。  <br/>
在ARC环境下，如果不确定是否要copy block尽管copy即可。ARC会自动处理的。  <br/>
【注意】：  <br/>
● 在栈上调用copy那么复制到堆上  <br/>
● 在全局block调用copy什么也不做  <br/>
● 在堆上调用block 引用计数增加</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block 之 Block引用局部变量]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/15/ios90/"/>
    <updated>2016-05-15T11:25:38+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/15/ios90</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>这一篇主要着重对__block关键字的理解</p>

<h2>例子</h2>

<pre><code class="ObjC">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int a = 10;
        void (^helloBlock)(void) = ^(){
            printf("%d\n",a);
        };
        a = 11;
        helloBlock();

    }
    return 0;
}
</code></pre>

<p>上面那个例子运行后的结果是10。我们可以编译看一下block里面匿名函数的实现：</p>

<pre><code class="ObjC">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int a = __cself-&gt;a; // bound by copy

            printf("%d\n",a);
}
</code></pre>

<p><strong>bound by copy</strong>这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。所以在执行block语法后，即使改写block中使用的局部变量的值也不会影响block执行时局部变量的值。      <br/>
那怎么样才能修改a的值呢？答案就是__block</p>

<h2>__block</h2>

<pre><code class="ObjC">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block int a = 10;
        void (^helloBlock)(void) = ^(){
            printf("%d\n",a);
        };
        a = 11;
        helloBlock();

    }
    return 0;
}
</code></pre>

<p>引入__block关键字后，运行结果是11，我们再编译看看block里面匿名函数的实现</p>

<pre><code class="ObjC">
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref

            printf("%d\n",(a-&gt;__forwarding-&gt;a));
}

struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};
</code></pre>

<p>我们看到局部变量a变成一个构造体对象，而不再是一个整形变量，结构体里包含它原来的整形变量。<strong>bound by ref</strong>这个注释也表明此时已变成引用传递</p>

<h2>小小总结</h2>

<p>block可以引用局部变量，但是不能修改它，不然就是编译错误，如果想修改它，可以加上__block关键字。但是可以改变全局变量、静态变量、全局静态变量。</p>
]]></content>
  </entry>
  
</feed>
