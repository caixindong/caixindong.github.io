<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-05-15T16:28:37+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Block 之 Block内存管理]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/15/ios90/"/>
    <updated>2016-05-15T11:25:38+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/15/ios90</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block 之 Block的底层实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/14/ios89/"/>
    <updated>2016-05-14T10:57:07+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/14/ios89</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近在总结关于block的东西，可能会写几篇关于block的博客，语法那些就不说，这里提供一个<a href="http://fuckingblocksyntax.com">语法的入口</a>，我们主要探究block的底层实现、block引用局部变量与对象、block的内存管理，今天先讲下block的底层实现。</p>

<h2>block实例</h2>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

void hello_(){
    int i = 2;
    int j = 3;
    long (^myBlock)(void) = ^long(){
        return i*j*10;
    };
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {


    }
    return 0;
}
</code></pre>

<p>定义hello方法是方便我们等下查看编译代码的时候准确定位myBlock的实现。用clang将objected-C 代码编译为C++代码。</p>

<pre><code>控制台命令：clang -rewrite-objc main.m 
</code></pre>

<p>我们打开main.cpp文件，定位到以下代码：</p>

<pre><code class="ObjC">struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};
</code></pre>

<p>这是block基类的定义，所有block都继承于它，拥有它以下那些属性：  <br/>
isa是指向该block的类型的类，也就是我们理解的对象指针；  <br/>
Flags包含了引用计数；  <br/>
Reserved：保留变量,我的理解是表示block内部的变量数；      <br/>
FuncPtr：函数指针，指向具体block实现的函数的调用地址；</p>

<pre><code class="ObjC">struct __hello__block_impl_0 {
  struct __block_impl impl;
  struct __hello__block_desc_0* Desc;
  int i;
  int j;
  __hello__block_impl_0(void *fp, struct __hello__block_desc_0 *desc, int _i, int _j, int flags=0) : i(_i), j(_j) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre>

<p>这是myBlock的定义，它的结构体以hello打头，代表myBlock位于hello函数里，这是block的命名方式。<strong>hello</strong>block_desc_0指的是myBlock的描述。</p>

<pre><code class="ObjC">static long __hello__block_func_0(struct __hello__block_impl_0 *__cself) {
  int i = __cself-&gt;i; // bound by copy
  int j = __cself-&gt;j; // bound by copy

        return i*j*10;
    }
</code></pre>

<p> myBlock内函数的具体实现，注意<strong>bound by copy</strong>，block对外部引用变量做只读拷贝，还有另外的一种情况，在以后讲到关于block引用局部变量与对象的时候会说。</p>

<pre><code class="ObjC">static struct __hello__block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __hello__block_desc_0_DATA = { 0, sizeof(struct __hello__block_impl_0)};
</code></pre>

<p>这是myBlock的具体描述</p>

<pre><code class="ObjC">void hello_(){
    int i = 2;
    int j = 3;
    long (*myBlock)(void) = ((long (*)())&amp;__hello__block_impl_0((void *)__hello__block_func_0, &amp;__hello__block_desc_0_DATA, i, j));
}
</code></pre>

<p>myBlock实例变量的定义</p>

<h2>做下小小总结</h2>

<p>block是对象；  <br/>
编译器会根据block捕获的局部变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数(eg：<strong>hello</strong>block_func_0)。创建block时，实际就是在方法中声明一个struct，并且初始化该struct的成员。而执行block时，就是调用那个单独的C函数，并把该struct指针传递过去；          <br/>
block中包含了被引用的局部变量(由struct持有)，也包含了控制成分的代码块(由函数指针持有)，符合闭包(closure)的概念。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime小笔记（二）]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/13/ios88/"/>
    <updated>2016-05-13T09:23:18+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/13/ios88</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>上篇主要讲Runtime的一些术语描述和定义，Runtime的主要应用是用于消息的传递，今天会结合一些实战例子来讲下OC的消息传递机制。</p>

<h2>普通消息传递</h2>

<p>在OC里，对象调用方法叫作发送消息，对象调用方法在Runtime里被转化为objc_msgSend函数来实现</p>

<pre><code class="ObjC">
[receiver oneMethod];
//transfer to ：
objc_msgSend(receiver, @selector(oneMethod));
</code></pre>

<h3>Runtime会根据类型自动转换为下列某个函数：</h3>

<p><strong>objc_msgSend</strong>：普通的消息都会通过该函数发送；  <br/>
<strong>objc_msgSend_stret</strong>：消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值；  <br/>
<strong>objc_msgSendSuper</strong>：和objc_msgSend类似，这里把消息发送给父类的实例；  <br/>
<strong>objc_msgSendSuper_stret</strong>：和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值；</p>

<h3>objc_msgSend的调用过程</h3>

<p><code>1.</code> 先检查这个selector是否存在，不存在则忽略；   <br/>
<code>2.</code> 接着检查selector的target是否为nil，向nil对象发送任何消息都会被忽略掉；  <br/>
<code>3.</code> 前面两步没问题，则先在isa指针指向的class的cache里面找有没有方法调用记录，如果有，则运行对应的函数，如果没有则在class的methodLists查找方法，没有则通过super_class指针找到父类的类对象结构体，然后从methodLists查找方法，如果仍找不到，则继续通过
super_class向上一级父类结构体中查找，直到根类（NSObject）；  <br/>
<code>4.</code> 如果还是找不到，则进入<strong>消息动态解析</strong>；</p>

<h2>消息动态解析</h2>

<p>动态解析流程图：
<img src="/images/objective-runtime-6.png"></p>

<p>具体解析：  <br/>
<code>1.</code> 通过resolveInstanceMethod，该方法决定是否动态添加方法。如果返回YES，则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回NO，则进入下一步；   <br/>
<code>2.</code> 这一步会步入forwardingTargetForSelector方法，用于指定备选对象响应这个selector，不能指定为self，如果放回某个对象则会调用对象的方法，结束。如果放回nil，则进入第三步；  <br/>
<code>3.</code> 这一步，我们通过methodSignatureForSelector进行方法签名，如果返回nil，则消息无法处理。如果返回methodSignature则进入下一步；  <br/>
<code>4.</code> 这步调用forwardInvocation方法，我们通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象，如果方法方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector，如果没有实现这个方法会crash</p>

<h2>实战</h2>

<h3>通过runtime动态创建类和对象</h3>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;
void sayFunction(id self, SEL _cmd, id some){

    NSLog(@"%@岁的%@说：%@",object_getIvar(self, class_getInstanceVariable([self class], "_age")),object_getIvar(self, class_getInstanceVariable([self class], "_name")),some);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //动态创建类
        Class MyPeople = objc_allocateClassPair([NSObject class], "Person", 0);

        //为类添加成员变量
        class_addIvar(MyPeople, "_name", sizeof(NSString*), log2(sizeof(NSString*)), @encode(NSString*));
        class_addIvar(MyPeople, "_age", sizeof(int),sizeof(int),@encode(int));

        //注册方法（"v@:@"代表返回值+参数列表）
        SEL say = sel_registerName("say:");
        class_addMethod(MyPeople, say, (IMP)sayFunction, "v@:@");

        //注册类
        objc_registerClassPair(MyPeople);

        //创建实例对象
        id peopleInstance = [[MyPeople alloc]init];

        [peopleInstance setValue:@"李明" forKey:@"name"];

        //获取成员变量
        Ivar age = class_getInstanceVariable(MyPeople, "_age");
        object_setIvar(peopleInstance, age, @18);

        //发送消息
        objc_msgSend(peopleInstance,say,@"你好呀");

        //销毁实例对象
        peopleInstance = nil;

        //当类或子类的实例存在，则不能销毁类
        objc_disposeClassPair(MyPeople);
    }
    return 0;
}
</code></pre>

<p><strong>tip：</strong>
默认会出现以下错误：  <br/>
objc_msgSend()报错Too many arguments to function call ,expected 0,have3
直接通过objc_msgSend(self, setter, value)是报错，说参数过多。  <br/>
请这样解决：
Build Setting–> Apple LLVM 7.0 – Preprocessing–> Enable Strict Checking of objc_msgSend Calls 改为 NO</p>

<h3>通过runtime获取类的相关信息(属性、实例变量、方法)</h3>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject{

    NSString* _nationality;

}

@property(nonatomic,copy)NSString* name;
@property(nonatomic,strong)NSNumber* age;

/**
 * 获取所有属性
 **/
-(NSDictionary*)getAllProperties;

/**
 * 获取所有实例变量
 **/
-(NSDictionary*)getAllIvars;


/**
 * 获取所有方法
 **/
-(NSDictionary*)getAllMethods;

@end
</code></pre>

<pre><code class="ObjC">#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

@implementation People


-(NSDictionary *)getAllProperties{
    unsigned int count = 0;
    NSMutableDictionary* result = [@{} mutableCopy];
    objc_property_t* properties = class_copyPropertyList([self class], &amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        const char* propertyName = property_getName(properties[i]);
        NSString* name = [NSString stringWithUTF8String:propertyName];
        id propertyValue = [self valueForKey:name];
        if (propertyValue) {
            result[name] = propertyValue;
        }else{
            result[name] = @"value 不能为 nil";
        }


    }
    free(properties);

    return result;
}

-(NSDictionary *)getAllIvars{
    unsigned int count = 0;
    NSMutableDictionary* result = [@{} mutableCopy];
    Ivar* ivars = class_copyIvarList([self class], &amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        const char* ivarName = ivar_getName(ivars[i]);
        NSString* name = [NSString stringWithUTF8String:ivarName];
        id value = [self valueForKey:name];
        if (value) {
            result[name] = value;
        }else{
            result[name] = @"value 不能为 nil";
        }
    }
    free(ivars);
    return  result;
}

-(NSDictionary*)getAllMethods{
    unsigned int count = 0;
    NSMutableDictionary* result = [@{} mutableCopy];
    Method* methods = class_copyMethodList([self class], &amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        const char* methodName = sel_getName(method_getName(methods[i]));
        NSString* name = [NSString stringWithUTF8String:methodName];
        //获取参数列表
        int args = method_getNumberOfArguments(methods[i]);
        result[name] = [NSString stringWithFormat:@"args count is %d",args-2 ];
    }
    free(methods);
    return result;
}
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "People.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        People* p = [[People alloc]init];
        p.name = @"罗大锤";
        p.age = @(30);
        [p setValue:@"中国" forKey:@"nationality"];
        NSDictionary* properties = [p getAllProperties];
        NSDictionary* ivars = [p getAllIvars];
        NSDictionary* methods = [p getAllMethods];
        NSLog(@"属性为：%@",properties);
        NSLog(@"实例变量：%@",ivars);
        NSLog(@"方法：%@",methods);
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:22:36.298 runtime 之 获取类的相关信息(属性、实例变量、方法)[2783:307932] 属性为：{
    age = 30;
    name = "\U7f57\U5927\U9524";
}
2016-05-13 11:22:36.299 runtime 之 获取类的相关信息(属性、实例变量、方法)[2783:307932] 实例变量：{
    "_age" = 30;
    "_name" = "\U7f57\U5927\U9524";
    "_nationality" = "\U4e2d\U56fd";
}
2016-05-13 11:22:36.299 runtime 之 获取类的相关信息(属性、实例变量、方法)[2783:307932] 方法：{
    ".cxx_destruct" = "args count is 0";
    age = "args count is 0";
    getAllIvars = "args count is 0";
    getAllMethods = "args count is 0";
    getAllProperties = "args count is 0";
    name = "args count is 0";
    "setAge:" = "args count is 1";
    "setName:" = "args count is 1";
}
Program ended with exit code: 0
</code></pre>

<h3>通过Runtime给category添加属性</h3>

<pre><code class="ObjC">
#import "People.h"

typedef void(^CallBackSomething)();

@interface People (testCategory)

@property(nonatomic,copy)NSString* address;
@property(nonatomic,copy)CallBackSomething block;
@end
</code></pre>

<pre><code class="ObjC">#import "People+testCategory.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;


@implementation People (testCategory)

-(void)setAddress:(NSString *)address{
    objc_setAssociatedObject(self, @selector(address), address, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

-(NSString *)address{
    return objc_getAssociatedObject(self, @selector(address));
}

-(void)setBlock:(CallBackSomething)block{
    objc_setAssociatedObject(self, @selector(block), block, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

-(CallBackSomething)block{
    return objc_getAssociatedObject(self, @selector(block));
}

@end
</code></pre>

<h3>利用Runtime给对象归档和解档</h3>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject&lt;NSCoding&gt;{

    NSString* _nationality;

}

@property(nonatomic,copy)NSString* name;
@property(nonatomic,strong)NSNumber* age;
@end
</code></pre>

<pre><code class="ObjC">#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

@implementation People

//归档
-(void)encodeWithCoder:(NSCoder *)aCoder{
    unsigned int count = 0;
    Ivar* ivars = class_copyIvarList([self class],&amp;count);
    for (NSUInteger i = 0; i&lt;count; i++) {
        Ivar ivar = ivars[i];
        const char* name = ivar_getName(ivar);
        NSString* key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [aCoder encodeObject:value forKey:key];
    }
    free(ivars);
}

//解档
-(instancetype)initWithCoder:(NSCoder *)aDecoder{
    if (self = [super init]) {
        unsigned int count = 0;
        Ivar* ivars = class_copyIvarList([self class],&amp;count);
        for (NSUInteger i = 0; i&lt;count; i++) {
            Ivar ivar = ivars[i];
            const char* name = ivar_getName(ivar);
            NSString* key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];
            [self setValue:value forKey:key];
        }
        free(ivars);
    }
    return self;
}

@end
</code></pre>

<h3>利用Runtime实现Model与字典互转</h3>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject

@property(nonatomic,copy)NSString* name;
@property(nonatomic,strong)NSNumber* age;


/**
 * 字典 转 Model
 **/
-(instancetype)initWithDictionary:(NSDictionary*) dict;

/**
 * Model转换成字典
 **/
-(NSDictionary*)covertToDictionary;
@end
</code></pre>

<pre><code class="ObjC">#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

@implementation People




-(instancetype)initWithDictionary:(NSDictionary *)dict{
    if (self = [super init]) {
        for (NSString* key in dict) {
            id val = dict[key];
            SEL setter = [self propertySetterByKey:key];
            if (setter) {
                objc_msgSend(self, setter,val);
            }
        }
    }
    return self;
}

-(NSDictionary *)covertToDictionary{
    unsigned int count = 0;
    objc_property_t* properties = class_copyPropertyList([self class], &amp;count);

    if (count!=0) {
        NSMutableDictionary* result = [@{} mutableCopy];
        for (NSUInteger i = 0; i&lt;count; i++) {
            const char * propertyName = property_getName(properties[i]);
            NSString* name = [NSString stringWithUTF8String:propertyName];

            SEL getter = [self propertyGetterByKey:name];
            if (getter) {
                id value = objc_msgSend(self, getter);
                if (value) {
                    result[name] = value;
                }else{
                    result[name] = @"value 为 nil";
                }
            }
        }
        free(properties);
        return result;
    }
    free(properties);
    return nil;
}

#pragma mark - 生成setter
-(SEL)propertySetterByKey:(NSString*)key{
    //key的首字母大写
    NSString* propertySetterName = [NSString stringWithFormat:@"set%@:",key.capitalizedString];
    SEL setter = NSSelectorFromString(propertySetterName);
    if ([self respondsToSelector:setter]) {
        return setter;
    }
    return nil;
}

-(SEL)propertyGetterByKey:(NSString*)key{
    SEL getter = NSSelectorFromString(key);
    if ([self respondsToSelector:getter]) {
        return getter;
    }
    return nil;
}

@end
</code></pre>

<h3>消息动态解析（一）</h3>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject

@property(nonatomic,copy)NSString* name;

/** m文件不实现方法，通过runtime动态添加方法
 *  通过resolveInstanceMethod：方法决定是否动态添加方法。
    如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No
 **/
-(void)sing;

@end
</code></pre>

<pre><code class="ObjC">
#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;


@implementation People

+(BOOL)resolveInstanceMethod:(SEL)sel{
    if ([NSStringFromSelector(sel) isEqualToString:@"sing"]) {
        class_addMethod([self class], sel, (IMP)otherIMP, "V@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

void otherIMP(id self ,SEL cmd){
    NSLog(@"%@正在唱歌",((People*)self).name);
}

@end
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "People.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        People* p = [[People alloc]init];
        p.name = @"张全蛋";
        [p sing];
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:24:16.905 runtime 之 消息动态解析(一)[2819:311517] 张全蛋正在唱歌
Program ended with exit code: 0
</code></pre>

<h3>消息动态解析（二）</h3>

<p>修改Bird唱歌方法的调用对象</p>

<pre><code class="ObjC">
#import &lt;Foundation/Foundation.h&gt;

@interface Bird : NSObject
@property(nonatomic,copy)NSString* name;
-(void)sing;
@end
</code></pre>

<pre><code class="ObjC">#import "Bird.h"
#import "People.h"
@implementation Bird


//第一步，不动态添加方法
+(BOOL)resolveInstanceMethod:(SEL)sel{
    return NO;
}

//第二步，不指定备选对象响应sselector
-(id)forwardingTargetForSelector:(SEL)aSelector{

    return nil;
}

//第三步，返回方法签名
-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    if ([NSStringFromSelector(aSelector) isEqualToString:@"sing"]) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

//第四部，修改调用对象
-(void)forwardInvocation:(NSInvocation *)anInvocation{
    People* p = [[People alloc]init];
    p.name = @"张铁柱";
    [anInvocation invokeWithTarget:p];
}
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "Bird.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Bird* b = [[Bird alloc]init];
        b.name = @"小鸟";
        [b sing];
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:29:58.335 runtime 之 消息动态解析(二)[2963:322829] 张铁柱正在唱歌
Program ended with exit code: 0
</code></pre>

<h3>消息动态解析（三）</h3>

<p>修改Person唱歌方法的实现</p>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;

@interface People : NSObject
-(void)sing;
@end
</code></pre>

<pre><code class="ObjC">#import "People.h"

@implementation People

//不动态添加方法
+(BOOL)resolveInstanceMethod:(SEL)sel{
    return NO;
}

//不指定备选响应对象
-(id)forwardingTargetForSelector:(SEL)aSelector{
    return nil;
}

//返回方法签名
-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    if ([NSStringFromSelector(aSelector) isEqualToString:@"sing"]) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

//修改调用方法
-(void)forwardInvocation:(NSInvocation *)anInvocation{
    [anInvocation setSelector:@selector(dance)];
    [anInvocation invokeWithTarget:self];
}

//若不实现forwardInvocation，则会调用此方法(可以注释掉forwardInvocation方法来做实验)
-(void)doesNotRecognizeSelector:(SEL)aSelector{
    NSLog(@"消息无法处理:%@",NSStringFromSelector(aSelector));
}

-(void)dance{
    NSLog(@"跳舞中");
}

@end
</code></pre>

<pre><code class="ObjC">#import &lt;Foundation/Foundation.h&gt;
#import "People.h"
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        People* p = [[People alloc]init];
        [p sing];
    }
    return 0;
}
</code></pre>

<p><strong>打印结果：</strong></p>

<pre><code class="ObjC">2016-05-13 11:33:01.871 runtime 之 消息动态解析(三)[3073:329356] 跳舞中
Program ended with exit code: 0
</code></pre>

<p><a href="https://github.com/caixindong/SomeDemoForYou/tree/master/RuntimeDemo">以上demo地址</a></p>

<p>参考文章：  <br/>
<a href="https://www.ianisme.com/ios/2019.html">Objective-C Runtime 1小时入门教程</a>  <br/>
<a href="http://www.jianshu.com/p/1e06bfee99d0">详解Runtime运行时机制</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime小笔记（一）]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/11/ios87/"/>
    <updated>2016-05-11T21:52:03+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/11/ios87</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>之前看过关于runtime的几篇文章，水平各有千秋，现在先汇集各个大牛的总结，以后找个时间将Runtime的<a href="http://opensource.apple.com//source/objc4/">源码</a>啃一遍，再完善自己的笔记</p>

<h2>什么是Runtime</h2>

<p>Objective-C Runtime是一个将C语言转化为面向对象语言的扩展。  <br/>
C++和Objective进行对比：  <br/>
<code>同 ：</code> C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言；  <br/>
<code>异 ：</code> 实现的机制差异不同。C++是基于静态类型，而Objective-C是基于动态运行时类型。也就是说用C++编写的程序编译时就直接编译成了可令机器读懂的机器语言；用Objective-C编写的程序不能直接编译成可令机器读懂的机器语言，而是在程序运行的时候，通过Runtime把程序转为可令机器读懂的机器语言。Runtime是Objective不可缺少的重要一部分；</p>

<h2>一些 Runtime 的术语</h2>

<h3>id 和 Class</h3>

<pre><code class="ObjC">#if !OBJC_TYPES_DEFINED
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;

/// Represents an instance of a class.
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
#endif
</code></pre>

<p>Class是一个指向<strong>==objc_class==</strong>结构体的指针；  <br/>
id是一个指向<strong>==objc_object==</strong>结构体的指针，其中的<strong>==isa==</strong>是一个指<strong>==objc_class==</strong>结构体的指针。  <br/>
换句话说，id就是我们所说的对象，Class就是我们所说的类。</p>

<h4>objc_class的定义</h4>

<pre><code class="ObjC">typedef struct objc_class *Class;
struct objc_class { 
 Class isa                                 OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
 Class super_class                         OBJC2_UNAVAILABLE; 
 const char *name                          OBJC2_UNAVAILABLE; 
 long version                              OBJC2_UNAVAILABLE; 
 long info                                 OBJC2_UNAVAILABLE; 
 long instance_size                        OBJC2_UNAVAILABLE; 
 struct objc_ivar_list *ivars              OBJC2_UNAVAILABLE;
 struct objc_method_list **methodLists     OBJC2_UNAVAILABLE; 
 struct objc_cache *cache                  OBJC2_UNAVAILABLE; 
 struct objc_protocol_list *protocols      OBJC2_UNAVAILABLE; 
#endif
}
/* Use `Class` instead of `struct objc_class *` */
</code></pre>

<p>isa指针：指向的类结构称为metaclass(元类)，其中存放着static类型的成员变量与类方法（“+”开头的方法）；  <br/>
super_class：指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil；  <br/>
name：类名；  <br/>
version：类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取；  <br/>
info：类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；  <br/>
instance_size：该类的实例变量大小（包括从父类继承下来的实例变量）；   <br/>
ivars：该类的成员变量地址列表；    <br/>
methodLists：方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法；  <br/>
cache：缓存最近使用的方法地址，用于提升效率；  <br/>
protocols：存储该类声明遵守的协议的列表；</p>

<p>类与对象的继承层次关系如图：  <br/>
<img src="/images/objective-runtime.png"></p>

<p>所有的metaclass中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。</p>

<h3>SEL</h3>

<p>SEL是方法选择器，作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现</p>

<pre><code class="ObjC">typedef struct objc_selector *SEL;

struct objc_selector {
    char *name;                       OBJC2_UNAVAILABLE;// 方法名
    char *types;                      OBJC2_UNAVAILABLE;// 方法类型
};
</code></pre>

<h3>IMP</h3>

<p>IMP是由编译器生成的一个函数指针，指向方法的实现。当你发起一个消息后，这个函数指针决定了最终执行哪段代码。</p>

<pre><code class="ObjC">typedef id (*IMP)(id, SEL, ...);
</code></pre>

<h3>Method</h3>

<p>Method代表类中的某个方法的类型。</p>

<pre><code class="ObjC">typedef struct objc_method *Method;

struct objc_method {
    SEL method_name                   OBJC2_UNAVAILABLE; // 方法名
    char *method_types                OBJC2_UNAVAILABLE; // 方法类型,存储着方法的参数类型和返回值类型
    IMP method_imp                    OBJC2_UNAVAILABLE; // 方法实现
}
</code></pre>

<h3>Ivar</h3>

<p>Ivar代表类中实例变量的类型</p>

<pre><code class="ObjC">typedef struct objc_ivar *Ivar;

struct objc_ivar {
    char *ivar_name                   OBJC2_UNAVAILABLE; // 变量名
    char *ivar_type                   OBJC2_UNAVAILABLE; // 变量类型
    int ivar_offset                   OBJC2_UNAVAILABLE; // 基地址偏移字节
#ifdef __LP64__
    int space                         OBJC2_UNAVAILABLE; // 占用空间
#endif
}
</code></pre>

<h3>objc_property_t</h3>

<p>objc_property_t是属性,是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下</p>

<pre><code class="ObjC">typedef struct objc_property *objc_property_t;

typedef struct {
    const char *name; // 名称
    const char *value;  // 值（通常是空的）
} objc_property_attribute_t;
</code></pre>

<h3>Cache</h3>

<p>方法地址缓存</p>

<pre><code class="ObjC">typedef struct objc_cache *Cache

struct objc_cache {
    unsigned int mask                   OBJC2_UNAVAILABLE;
    unsigned int occupied               OBJC2_UNAVAILABLE;
    Method buckets[1]                   OBJC2_UNAVAILABLE;
};
</code></pre>

<p><code>mask</code>： 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。  <br/>
<code>occupied</code>： 实际占用cache buckets的总数。  <br/>
<code>buckets</code>： 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。  <br/>
objc_msgSend每调用一次方法后，就会把该方法缓存到cache列表中，下次调用的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。</p>

<h3>Catagory</h3>

<p>这个就是我们平时所说的类别了,它可以动态的为已存在的类添加新的方法。</p>

<pre><code class="ObjC">typedef struct objc_category *Category;

struct objc_category {
    char *category_name                           OBJC2_UNAVAILABLE; // 类别名称
    char *class_name                              OBJC2_UNAVAILABLE; // 类名
    struct objc_method_list *instance_methods     OBJC2_UNAVAILABLE; // 实例方法列表
    struct objc_method_list *class_methods        OBJC2_UNAVAILABLE; // 类方法列表
    struct objc_protocol_list *protocols          OBJC2_UNAVAILABLE; // 协议列表
}
</code></pre>

<p>参考文章：  <br/>
<a href="https://www.ianisme.com/ios/2019.html">Objective-C Runtime 1小时入门教程</a>  <br/>
<a href="http://www.jianshu.com/p/1e06bfee99d0">详解Runtime运行时机制</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAShapeLayer与UIBezierPath]]></title>
    <link href="http://caixindong.github.io/blog/2016/05/07/ios86/"/>
    <updated>2016-05-07T21:06:22+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/05/07/ios86</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><code>1.</code> UIBezierPath： UIBezierPath是在 UIKit 中的一个类，继承于NSObject,可以创建基于矢量的路径.此类是Core Graphics框架关于path的一个OC封装。使用此类可以定义常见的圆形、多边形等形状 。我们使用直线、弧（arc）来创建复杂的曲线形状。每一个直线段或者曲线段的结束的地方是下一个的开始的地方。每一个连接的直线或者曲线段的集合成为subpath。一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths。  <br/>
<code>2.</code> CAShapeLayer： 继承于CALayer。 每个CAShapeLayer对象都代表着将要被渲染到屏幕上的一个任意的形状(shape)。具体的形状由其path(类型为CGPathRef)属性指定。 普通的CALayer是矩形，所以需要frame属性。CAShapeLayer它本身没有形状，它的形状来源于其属性path 。CAShapeLayer有不同于CALayer的属性，它从CALayer继承而来的属性在绘制时是不起作用的。</p>

<h2>具体用法看代码</h2>

<p>仅仅使用UIBezierPath来绘图的话，需要在view的drawRect方法里实现,详细可以看MyView的drawRect方法</p>

<pre><code class="ObjC">//
//  MyView.m
//  CAShapeLayerAndUIBezierPath
//
//  Created by 蔡欣东 on 16/4/21.
//  Copyright © 2016年 蔡欣东. All rights reserved.
//

#import "MyView.h"

@implementation MyView

- (void)drawRect:(CGRect)rect {
    [self simpleDraw];
    [self drawARCPath];
    [self drawTrianglePath];
    [self drawSecondBezierPath];
}

//画圆角矩形
-(void)simpleDraw{
    UIBezierPath* path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, 100, 100) cornerRadius:20];
    path.lineWidth = 5;

    //设置填充颜色
    UIColor* fillColor = [UIColor greenColor];
    [fillColor set];
    [path fill];

    //设置线的颜色，需要在填充颜色之后设置
    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}


//画圆弧
-(void)drawARCPath{
    UIBezierPath* path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(20, 150) radius:100 startAngle:0 endAngle:M_PI*90/180 clockwise:YES];

    //连接处的样式
    path.lineCapStyle = kCGLineCapRound;
    //连接方式
    path.lineJoinStyle = kCGLineJoinRound;
    path.lineWidth = 5;

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}

//画三角形
-(void)drawTrianglePath{
    UIBezierPath* path = [UIBezierPath bezierPath];
    //设置起点
    [path moveToPoint:CGPointMake(20, 300)];
    [path addLineToPoint:CGPointMake(150, 400)];
    [path addLineToPoint:CGPointMake(20, 400)];
    [path closePath];

    path.lineWidth = 5;

    UIColor* fillColor = [UIColor greenColor];
    [fillColor set];
    [path fill];

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];


}

//画二次贝尔曲线
-(void)drawSecondBezierPath{
    UIBezierPath* path = [UIBezierPath bezierPath];
    [path moveToPoint:CGPointMake(200, 150)];
    [path addQuadCurveToPoint:CGPointMake(200, 300) controlPoint:CGPointMake(50, 50)];
    path.lineWidth = 5;

    UIColor* lineColor = [UIColor redColor];
    [lineColor set];
    [path stroke];
}

@end
</code></pre>

<p>用CAShapeLayer和UIBezierPath画图，以及结合CAAnimation实现一个绘图动画</p>

<h2>动画效果：</h2>

<p><img src="/images/gif1.gif"></p>

<pre><code class="ObjC">//
//  ViewController.m
//  CAShapeLayerAndUIBezierPath
//
//  Created by 蔡欣东 on 16/4/21.
//  Copyright © 2016年 蔡欣东. All rights reserved.
//

#import "ViewController.h"
#import "MyView.h"
@interface ViewController (){
    CAShapeLayer *layer;
}

@end


@implementation ViewController


- (void)viewDidLoad {
    [super viewDidLoad];

    //仅仅使用UIBezierPath的话，需要在view的drawRect方法里实现,详细可以看MyView的drawRect方法
//    CGFloat W = [UIScreen mainScreen].bounds.size.width;
//    CGFloat H = [UIScreen mainScreen].bounds.size.height;
//    MyView* myView = [[MyView alloc]initWithFrame:CGRectMake(0, 0, W, H)];
//    myView.backgroundColor = [UIColor whiteColor];
//    [self.view addSubview:myView];




    //CAShapeLayer和UIBezierPath画图

    layer = [CAShapeLayer layer];
    layer.fillColor = [UIColor clearColor].CGColor;
    layer.lineWidth =  20.0f;
    layer.lineCap = kCALineCapRound;
    layer.lineJoin = kCALineJoinRound;
    layer.strokeColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:layer];

    // 创建贝塞尔路径
    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(200, 200) radius:80 startAngle:0 endAngle:M_PI*2 clockwise:NO];


    // 关联layer和贝塞尔路径
    layer.path = path.CGPath;

    // 创建Animation
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
    animation.fromValue = @(0.0);
    animation.toValue = @(1.0);
    layer.autoreverses = NO;
    animation.duration = 3.0;

    // 设置layer的animation
    [layer addAnimation:animation forKey:nil];
    animation.delegate = self;


    int count = 16;
    for (int i = 0; i&lt;count; i++) {
        CAShapeLayer* lineLayer = [CAShapeLayer layer];
        lineLayer.fillColor = [UIColor clearColor].CGColor;
        lineLayer.strokeColor = [UIColor yellowColor].CGColor;
        lineLayer.lineWidth = 15.0f;
        lineLayer.lineCap = kCALineCapRound;
        lineLayer.lineJoin = kCALineCapRound;
        [self.view.layer addSublayer:lineLayer];

        UIBezierPath* path2 = [UIBezierPath bezierPath];
        int x = 200+100*cos(2*M_PI/count*i);
        int y = 200-100*sin(2*M_PI/count*i);
        int len = 50;
        [path2 moveToPoint:CGPointMake(x, y)];
        [path2 addLineToPoint:CGPointMake(x+len*cos(2*M_PI/count*i), y-len*sin(2*M_PI/count*i))];
        lineLayer.path = path2.CGPath;
        [lineLayer addAnimation:animation forKey:nil];
    }

}

//animation结束回调
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
    NSLog(@"yes");
    layer.fillColor = [UIColor redColor].CGColor;
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];

}

@end
</code></pre>

<p>Demo地址：<a href="https://github.com/caixindong/SomeDemoForYou">https://github.com/caixindong/SomeDemoForYou</a></p>
]]></content>
  </entry>
  
</feed>
