<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-16T14:04:20+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS本地推送功能实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/01/11/ios20/"/>
    <updated>2016-01-11T15:49:33+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/01/11/ios20</id>
    <content type="html"><![CDATA[<p>1、首先在AppDelegate注册推送</p>

<pre><code class="objc">    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {


        if ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) {

        //注册推送, iOS 8以上
        UIUserNotificationSettings *settings = [UIUserNotificationSettings

                                                settingsForTypes:(UIUserNotificationTypeBadge |

                                                                  UIUserNotificationTypeSound |

                                                                  UIUserNotificationTypeAlert)

                                                categories:nil];

        [application registerUserNotificationSettings:settings];
        [application registerForRemoteNotifications];

    } else {
        //注册推送, 适配系统版本iOS 8以下的手机
        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge |

        UIRemoteNotificationTypeAlert |

        UIRemoteNotificationTypeSound;

        [application registerForRemoteNotificationTypes:myTypes];

    }


    return YES;
    }
</code></pre>

<p>2、注册成功与否的回调</p>

<pre><code class="objc">    - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken {
            NSLog(@"device token is %@",deviceToken);
    }

    - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error{
            NSLog(@"push fail error is %@",error);
    }
</code></pre>

<p>3、获取本地通知数据回调</p>

<pre><code class="objc">    - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{
            NSLog(@"get notification");
            //获取通知后的操作
    }
</code></pre>

<p>4、发起本地推送</p>

<pre><code class="objc">    -(void)sendLocalNotifation{
        UILocalNotification* notifation = [[UILocalNotification alloc]init];
        //当前时间5秒后
        NSDate* pushDate = [NSDate dateWithTimeIntervalSinceNow:5];
        if (notifation!=nil) {
            //设置推送时间
            notifation.fireDate = pushDate;
            //设置时区
            notifation.timeZone = [NSTimeZone defaultTimeZone];
            //设置重复次数
            notifation.repeatInterval = 0;
            notifation.soundName = UILocalNotificationDefaultSoundName;
            //通知弹窗的文本
            notifation.alertBody = @"推送的文本";
            //设置icon小红点
            notifation.applicationIconBadgeNumber = 1;
            //设置userinfo 方便在之后需要撤销的时候使用
            NSDictionary* info = [NSDictionary dictionaryWithObject:@"通知的名字" forKey:@"key"];
            notifation.userInfo = info;
            //添加推送到UIApplication
            UIApplication* app = [UIApplication sharedApplication];
            [app scheduleLocalNotification:notifation];
        }
    }
</code></pre>

<p>5、解除本地推送</p>

<pre><code class="objc">    -(void)cancleLocalNotifation{
        UIApplication* app = [UIApplication sharedApplication];
        //获取所有本地推送
        NSArray* localArray = [app scheduledLocalNotifications];
        UILocalNotification* notification;
        if (localArray) {
            for(UILocalNotification* noti in localArray){
            NSDictionary* userInfo = noti.userInfo;
            if (userInfo) {
                NSString *keyValue = [userInfo objectForKey:@"key"];
                if ([keyValue isEqualToString:@"通知的名字"]) {
                    notification = noti;
                    [app cancelLocalNotification:notification];
                }
            }
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS图片压缩及上传]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/31/ios19/"/>
    <updated>2015-12-31T22:51:47+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/31/ios19</id>
    <content type="html"><![CDATA[<p>1、在工具类定义压缩图片的方法,传入图片和所要压缩的尺寸</p>

<pre><code class="objc ">    +(UIImage *)imageWithImage:(UIImage *)image scaleToSize :(CGSize )newSize{

    UIGraphicsBeginImageContext(newSize);

    [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];

    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();

    UIGraphicsEndImageContext();

    return newImage;

    }
</code></pre>

<p>2、利用AFNetworking做图片上传功能</p>

<pre><code class="objc">    +(void)POSTToUrl:(NSString *)url WithData:(NSData *)data 
        WithReturnBlock:(ReturnValueBlock)block         
        WithErrorCodeBlock:(ErrorCodeBlock)errorBlock       
        WithFailtureBlock:(FailureBlock)failtureBlock{

        AFHTTPRequestOperationManager* manager = [[AFHTTPRequestOperationManager alloc]init];

        manager.requestSerializer = [AFHTTPRequestSerializer serializer];
        manager.responseSerializer = [AFJSONResponseSerializer serializer];     

        //不设置可能会出现404的bug
        manager.responseSerializer.acceptableContentTypes =     [manager.responseSerializer.acceptableContentTypes   setByAddingObject:@"text/html"];

        [manager POST:url parameters:nil 
        constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
            //以上传的时间为图片名
            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
            formatter.dateFormat = @"yyyyMMddHHmmss";
            NSString *str = [formatter stringFromDate:[NSDate date]];
            NSString *fileName = [NSString stringWithFormat:@"%@.png", str];

            [formData appendPartWithFileData:data 
            name:@"upload" //upload.php处理文件的字段
            fileName:fileName //图片名字 
            mimeType:@"image/png"];

        }success:^(AFHTTPRequestOperation *operation,id responseObject) {
            //上传成功
        }failure:^(AFHTTPRequestOperation *operation,NSError *error) {
            //上传失败
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中遇过的一些小bug（二）]]></title>
    <link href="http://caixindong.github.io/blog/2015/12/18/ios18/"/>
    <updated>2015-12-18T21:12:27+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/12/18/ios18</id>
    <content type="html"><![CDATA[<p>1、block会release，所以在使用的时候记得非空判断，特别在使用AFNetworking block交互的时候</p>

<p>2、有时候在真机测试的时，某些第三方库编译不通过，可能bitcode没关，可以在build setting里面将这个值设为no。苹果文档是这样说的：bitcode是被编译程序的一种中间形式的代码，包含bitcode配置的程序将会在App store上被编译和链接，bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个比较有趣的界面过渡动画]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/19/ios17/"/>
    <updated>2015-11-19T16:35:49+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/19/ios17</id>
    <content type="html"><![CDATA[<p>动画的类型依次为立方，吸走，翻转，水波，翻页，翻页回，打开相机，关闭相机</p>

<pre><code>NSString *Types[]={@"cube",
@"suckEffect",
@"oglFlip",
@"rippleEffect",
@"pageCurl",
@"pageUnCurl",
@"cameraIrisHollowOpen",
@"cameraIrisHollowClose"};
</code></pre>

<p>直接贴代码</p>

<pre><code>CATransition *animation = [CATransition animation];
[animation setDuration:0.8];
//设置动画的类型
[animation setType: @"rippleEffect"];
//设置动画变化快慢得函数
[animation setTimingFunction:[CAMediaTimingFunction functionWithName:
kCAMediaTimingFunctionLinear]];
[self.navigationController.view.layer addAnimation:animation forKey:nil];
[self.navigationController pushViewController:tvc animated:NO];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中遇过的一些小bug（一）]]></title>
    <link href="http://caixindong.github.io/blog/2015/11/19/ios16/"/>
    <updated>2015-11-19T16:20:47+08:00</updated>
    <id>http://caixindong.github.io/blog/2015/11/19/ios16</id>
    <content type="html"><![CDATA[<p>  当我们在使用<code>UITableView</code>的时候或者其他类<code>UIScrollView</code>的UI组件时，我们可能会遇到UITableView顶部留有一段空白区域的情况，那是因为<code>iOS 7</code> viewcontroller新增属性<code>automaticallyAdjustsScrollViewInsets</code>，即是否根据按所在界面的navigationbar与tabbar的高度，自动调整scrollview的 inset。如果我们不想要那段空白，将<code>automaticallyAdjustsScrollViewInsets</code>这个值设为<code>NO</code>就可以解决这个问题了</p>
]]></content>
  </entry>
  
</feed>
