<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 树 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/shu/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-13T14:33:53+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[二叉树的BFS遍历(递归)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/13/ios44/"/>
    <updated>2016-02-13T14:01:23+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/13/ios44</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>BFS,即广度优先遍历，做法就是逐层遍历</p>

<h2>代码实现：</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct treeNode {
    int val;
    int position;
    treeNode* left;
    treeNode* right;
    treeNode(int val,int position){
        this-&gt;val = val;
        this-&gt;position = position;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    }
};

class BinaryTree {
    int max(int x,int y){
        return x&gt;y?x:y;
    }
    /**
    *计算每个结点的深度
    **/
    int depth(treeNode* node){
        if (node==nullptr) {
            return 0;
        }else{
            int leftD = depth(node-&gt;left);
            int rightD = depth(node-&gt;right);
            return max(leftD, rightD)+1;
        }
    }
public:
    treeNode* root = nullptr;

    /**
     *获取深度
     **/
    int depth(){
        return depth(root);
    }


    /**
     * 广度优先遍历
     **/
    void BFSTravel(){
        int dep = depth();
        for (int i=0; i&lt;dep; i++) {
            printLevel(root, i);
        }
    }


    /**
     *打印每一层
     **/
    void printLevel(treeNode* node, int level){
        if (node==nullptr) {
            return;
        }
        if (level==0) {
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
        }else{
            printLevel(node-&gt;left, level-1);
            printLevel(node-&gt;right, level-1);
        }
    }

    };
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的DFS遍历(非递归)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/11/ios41/"/>
    <updated>2016-02-11T13:54:08+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/11/ios41</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>递归是利用函数压栈实现，如果我们要将递归的写法转化为非递归写法，自然需要利用栈来实现。</p>

<h2>二叉树的实现</h2>

<p>代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct treeNode {
    int val;
    int position;
    treeNode* left;
    treeNode* right;
    treeNode(int val,int position){
        this-&gt;val = val;
        this-&gt;position = position;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    }
};


class BinaryTree {

public:
    treeNode* root = nullptr;
    BinartTree(){
        root = nullptr;
    }
    void pre_order();
    void mid_order();
    void back_order()
};
</code></pre>

<h2>前序遍历非递归写法</h2>

<p>代码如下：</p>

<pre><code class="C++">    /**
     *前序遍历
     **/
    void BinaryTree::pre_order(){
        treeNode* currentNode = root;
        std::stack&lt;treeNode*&gt; stack;
        while (currentNode||!stack.empty()) {
            if (currentNode) {
                std::cout&lt;&lt;currentNode-&gt;val&lt;&lt;std::endl;
                stack.push(currentNode);
                currentNode = currentNode-&gt;left;
            }else{
                currentNode = stack.top();
                stack.pop();
                currentNode = currentNode-&gt;right;
            }
        }


    }
</code></pre>

<h2>中序遍历非递归写法</h2>

<p>代码如下：</p>

<pre><code class="C++">    /**
     *中序遍历
     **/
    void BinaryTree::mid_order(){
        treeNode* currentNode = root;
        std::stack&lt;treeNode*&gt; stack;
        while (!stack.empty()||currentNode) {
            if (currentNode) {
                stack.push(currentNode);
                currentNode = currentNode-&gt;left;
            }else{
                currentNode = stack.top();
                stack.pop();
                std::cout&lt;&lt;currentNode-&gt;val&lt;&lt;std::endl;
                currentNode = currentNode-&gt;right;
            }
        }

    }
</code></pre>

<h2>后序遍历非递归写法</h2>

<p>代码如下：</p>

<pre><code class="C++">    /**
     *后序遍历
     **/
    void BinaryTree::back_order(){
        treeNode* currentNode = root;
        treeNode* lastVisitNode = nullptr;
        std::stack&lt;treeNode*&gt; stack;

        while (currentNode) {
            stack.push(currentNode);
            currentNode = currentNode-&gt;left;
        }
        while (!stack.empty()) {
            currentNode = stack.top();
            stack.pop();
            if (currentNode-&gt;right==nullptr||currentNode-&gt;right==lastVisitNode) {
                std::cout&lt;&lt;currentNode-&gt;val&lt;&lt;std::endl;
                lastVisitNode = currentNode;
            }else{
                stack.push(currentNode);
                currentNode = currentNode-&gt;right;
                while (currentNode) {
                    stack.push(currentNode);
                    currentNode = currentNode-&gt;left;
                }
            }
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的DFS遍历(递归)]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/11/ios40/"/>
    <updated>2016-02-11T13:40:04+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/11/ios40</id>
    <content type="html"><![CDATA[<h2>二叉(搜索)树的实现</h2>

<p>代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct treeNode {
    int val;
    int position;
    treeNode* left;
    treeNode* right;
    treeNode(int val,int position){
        this-&gt;val = val;
        this-&gt;position = position;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    }
};


class BinaryTree {
public:
    treeNode* root = nullptr;
    BinaryTree(){
        root = nullptr;
    }
    pre_order(treeNode* node);
    mid_order(treeNode* node);
    back_order(treeNode* node);
};
</code></pre>

<h2>先序遍历</h2>

<p>代码如下：</p>

<pre><code class="C++">
/**
*前序遍历
**/
    void BinaryTree::pre_order(treeNode* node){
        if (node==nullptr) {
            return;
        }else{
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
            pre_order(node-&gt;left);
            pre_order(node-&gt;right);           
        }
    }
</code></pre>

<h2>中序遍历</h2>

<p>代码如下：</p>

<pre><code class="C++">
/**
*中序遍历
**/
    void BinaryTree::mid_order(treeNode* node){
        if (node==nullptr) {
            return;
        }else{
           mid_order(node-&gt;left);
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
            mid_order(node-&gt;right);           
        }
    }
</code></pre>

<h2>后序遍历</h2>

<p>代码如下：</p>

<pre><code class="C++">
/**
*后序遍历
**/
    void BinaryTree::back_order(treeNode* node){
        if (node==nullptr) {
            return;
        }else{           
           back_order(node-&gt;left);
            back_order(node-&gt;right);
            cout&lt;&lt;node-&gt;val&lt;&lt;endl;
        }
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
