<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 链表 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/lian-biao/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-06T12:17:35+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[删除链表的重复元素(二)]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/05/ios76/"/>
    <updated>2016-03-05T21:27:35+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/05/ios76</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>删除链表中的重复元素,例如1->1->1->2->3->3->4->4->5，返回2->5</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;

struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;
            ListNode* pre = newHead;
            ListNode* p = pre-&gt;next;
            ListNode* next = NULL;
            while (p!=NULL&amp;&amp;p-&gt;next!=NULL) {
                next = p-&gt;next;
                if (p-&gt;val==next-&gt;val) {
                    while (next!=NULL&amp;&amp;next-&gt;val==p-&gt;val) {
                        next = next-&gt;next;
                    }
                    pre-&gt;next = next;
                    p = next;
                }else{
                    pre = pre-&gt;next;
                    p =  p-&gt;next;
                }
            }
            return newHead-&gt;next;

        }
    }
};
int main(int argc, const char * argv[]) {
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删除链表的重复元素(一)]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/05/ios75/"/>
    <updated>2016-03-05T21:09:32+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/05/ios75</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>删除链表里的重复元素，例如1->2->2->3->3->4->5->5->6，返回1->2->3->4->5->6</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace::std;
//1,2,3,3,4,5 -&gt; 1,2,3,4,5
  struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else{
            ListNode* pre = head;
            ListNode* p = pre-&gt;next;
            while (p!=NULL) {
                if (pre-&gt;val==p-&gt;val) {
                    pre-&gt;next = p-&gt;next;
                    p = p-&gt;next;
                }else{
                    pre = pre-&gt;next;
                    p = p-&gt;next;
                }
            }
            return head;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删除链表中倒数第n个元素]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/05/ios74/"/>
    <updated>2016-03-05T20:48:54+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/05/ios74</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>删除链表中倒数第n个元素，例如1->2->3->4->5->6,n=2,返回1->2->3->4->6</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if (head==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;
            ListNode* pre = newHead;
            ListNode* p = newHead;
            for (int i=0; i&lt;n; i++) {
                p = p-&gt;next;
            }
            while (p-&gt;next!=NULL) {
                pre = pre-&gt;next;
                p = p-&gt;next;
            }
            pre-&gt;next = pre-&gt;next-&gt;next;
            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删除链表元素]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/05/ios73/"/>
    <updated>2016-03-05T20:20:46+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/05/ios73</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>删除链表中值为val的结点，例如：1->2->3->4->5->NULL,val = 4,返回1->2->3->5->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace::std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;
            ListNode* pre = newHead;
            ListNode* p = newHead-&gt;next;
            while (p!=NULL) {
                if (p-&gt;val == val) {
                    pre-&gt;next = p-&gt;next;
                    p = p-&gt;next;

                }else{
                    pre = pre-&gt;next;
                    p = p-&gt;next;
                }
            }
            return newHead-&gt;next;
        }
    }
};

int main(int argc, const char * argv[]) {

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻转链表中的一部分]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios72/"/>
    <updated>2016-03-04T22:23:26+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios72</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>翻转链表的第m到第n部分，例如：1->2->3->4->5->NULL,m=2,n=4,返回1->4->3->2->5->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace::std;


struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:


    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else if (m==n){
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            newHead-&gt;next = head;

            //first为第m-1个结点
            ListNode* first = newHead;
            for (int i=1; i&lt;m; i++) {
                first = first-&gt;next;
            }


            ListNode* pre = first-&gt;next;
            ListNode* p = pre-&gt;next;
            ListNode* next = NULL;

            //top为第m个结点，也是翻转部分翻转后的尾结点
            ListNode* top = pre;
            for (int i =m; i&lt;n; i++) {
                next = p-&gt;next;
                p-&gt;next = pre;
                pre = p;
                p = next;
            }
            //这时候p为第n+1个结点，pre为翻转部分翻转后的头结点

            top-&gt;next = p;
            first-&gt;next = pre;

            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
