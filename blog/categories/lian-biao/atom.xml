<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 链表 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/lian-biao/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-03-04T21:30:43+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[旋转链表]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios70/"/>
    <updated>2016-03-04T21:18:17+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios70</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个链表1->2->3->4->5->NULL和一个k=2，返回4->5->1->2->3->NULL</p>

<h2>代码实现</h2>

<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    int length(ListNode* head){
        int count = 0;
        ListNode* p = head;
        while (p!=NULL) {
            count++;
            p = p-&gt;next;
        }
        return count;
    }
    ListNode* rotateRight(ListNode* head, int k) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else if(k==0){
            return head;
        }else{
            int n = length(head);
            //如果k大于链表长度则取余
            k = k%n;
            if (k==0) {
                return head;
            }

            //关键步骤
            ListNode* p = head;
            for (int i =0; i&lt;n-k-1; i++) {
                p = p-&gt;next;
            }

            //取得新链表的头和尾
            ListNode* newEnd = p;
            ListNode* newHead = p-&gt;next;

            while (p-&gt;next!=NULL) {
                p = p-&gt;next;
            }
            ListNode* touch = p;
            touch-&gt;next = head;
            newEnd-&gt;next = NULL;
            return newHead;
        }
    }
};
int main(int argc, const char * argv[]) {

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表成对交换问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/03/04/ios69/"/>
    <updated>2016-03-04T20:58:34+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/03/04/ios69</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个链表1->2->3->4,你会返回2->1->4->3</p>

<h2>代码实现</h2>

<pre><code class="C++">
#include &lt;iostream&gt;
using namespace std;
struct ListNode {
         int val;
         ListNode *next;
         ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head==NULL||head-&gt;next==NULL) {
            return head;
        }else{
            ListNode* newHead = new ListNode(0);
            ListNode* pre = head;
            ListNode* p = pre-&gt;next;
            ListNode* next = NULL;
            ListNode* nh = newHead;
            while (p!=NULL) {
                next = p-&gt;next;
                p-&gt;next = pre;
                pre-&gt;next = next;
                nh-&gt;next = p;
                nh = pre;
                if (next==NULL) {
                    break;
                }
                pre = next;
                p = pre-&gt;next;

            }
            return newHead-&gt;next;
        }
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &lt;&lt; "Hello, World!\n";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
