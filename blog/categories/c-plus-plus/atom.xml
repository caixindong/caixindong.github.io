<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-19T16:02:06+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++优先队列(priority_queue)简析和使用]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/16/ios52/"/>
    <updated>2016-02-16T15:07:30+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/16/ios52</id>
    <content type="html"><![CDATA[<h2>基本操作</h2>

<p>跟队列的基本操作一样，也包含在queue这个头文件。  <br/>
<code>1.</code> empty() 如果队列为空返回真  <br/>
<code>2.</code> pop() 删除对顶元素  <br/>
<code>3.</code> push() 加入一个元素  <br/>
<code>4.</code> size() 返回优先队列中拥有的元素个数  <br/>
<code>5.</code> top() 返回优先队列对顶元素   <br/>
注意：默认优先队列先出队的元素为优先级最高的元素，在默认的int型中先出队的是最大的元素。标准库默认使用元素类型的 &lt; 操作符来确定它们之间的优先级关系</p>

<h2>实现方式</h2>

<p><code>1.</code> 基本数据类型的优先队列</p>

<h4>默认是从大到小</h4>

<pre><code class="C++">    int a[] = {4,7,3,8};
    priority_queue&lt;int&gt; intQ;
    for (int i=0; i&lt;4; i++) {
        intQ.push(a[i]);
    }
    while (!intQ.empty()) {
        cout&lt;&lt;intQ.top()&lt;&lt;" ";
        intQ.pop();
    }
    cout&lt;&lt;endl;
</code></pre>

<p>输出：8 7 4 3</p>

<h4>从小到大</h4>

<pre><code class="C++">    int a[] = {4,7,3,8};

    //priority_queue另一种实现方式
    //第一个参数是数据类型
    //第二个参数是容器类型，默认用vector
    //第三个参数是比较函数类型，默认是less&lt;&gt;,这里可以传入仿函数
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; intQ;
    for (int i=0; i&lt;4; i++) {
        intQ.push(a[i]);
    }
    while (!intQ.empty()) {
        cout&lt;&lt;intQ.top()&lt;&lt;" ";
        intQ.pop();
    }
    cout&lt;&lt;endl;
</code></pre>

<p>输出：3 4 7 8</p>

<p><code>2.</code> 自定义数据类型的优先队列</p>

<h4>在自定义的结构体内重载&lt;运算符</h4>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;
struct Node {
    int val;

    Node(int v)
    :val(v)
    {

    }
    //在结构体内重载&lt;运算符
    bool operator&lt;(const Node &amp;a)const{
        return val&gt;a.val;//val小的优先级高
    }
};
int main(int argc, const char * argv[]) {
  priority_queue&lt;Node&gt; q;
   Node n1(3);
    Node n2(4);
    Node n3(1);

    q.push(n1);
    q.push(n2);
    q.push(n3);

    while (!q.empty()) {
        cout&lt;&lt;q.top().val&lt;&lt;" ";
        q.pop();
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>输出： 1 3 4</p>

<h4>在结构体外重载&lt;操作符</h4>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;
struct Node {
    int val;

    Node(int v)
    :val(v)
    {

    }
};

//重载&lt;操作符
bool operator&lt;(Node a,Node b){
    return a.val &gt; b.val ;
}

int main(int argc, const char * argv[]) {
  priority_queue&lt;Node&gt; q;

    Node n1(3);
    Node n2(4);
    Node n3(1);

    q.push(n1);
    q.push(n2);
    q.push(n3);

    while (!q.empty()) {
        cout&lt;&lt;q.top().val&lt;&lt;" ";
        q.pop();
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>输出：1 3 4</p>

<h4>自定义比较函数</h4>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;
struct Node {
    int val;

    Node(int v)
    :val(v)
    {

    }
};

//仿函数
struct Compare {
     //重载()操作符
    bool operator()(Node a,Node b){
        return a.val &gt; b.val;//val小的优先级高
    }
};

int main(int argc, const char * argv[]) {
    priority_queue&lt;Node,vector&lt;Node&gt;,Compare&gt; q;
    Node n1(3);
    Node n2(4);
    Node n3(1);

    q.push(n1);
    q.push(n2);
    q.push(n3);

    while (!q.empty()) {
        cout&lt;&lt;q.top().val&lt;&lt;" ";
        q.pop();
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>输出：1 3 4</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析C++仿函数]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/16/ios51/"/>
    <updated>2016-02-16T13:28:30+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/16/ios51</id>
    <content type="html"><![CDATA[<h2>何为仿函数</h2>

<p>仿函数这个词经常出现在C++的模板库(STL)里，就自己浅陋的理解，仿函数就是能够实现跟函数一样的功能的东西，通常以结构体或类的形式呈现出来。实现的关键就是重载()这个操作符。</p>

<h2>为什么要用仿函数</h2>

<p>我们知道，函数可以作为参数来传递，我们知道可以用函数指针来实现。而仿函数是另一种方式来实现这样的功能。STL模板库中，大量使用这种技巧。</p>

<h2>代码举例说明</h2>

<pre><code class="C++">
/**
*我们实现对结构体Node对象的比较
**/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
using namespace std;

/**
*结构体Node
**/
struct Node {
    int val;
    Node(int v):val(v){

    }
};

/**
*基于二元操作符的仿函数实现
**/
struct Compare:binary_function&lt;Node*, Node*, bool&gt; {
    /**
    * 重载（）操作符
    **/
    bool operator()(Node &amp;a,Node &amp;b){
        return a.val&lt;b.val;
    }
};

int main(int argc, const char * argv[]) {
    Node n1(2);
    Node n2(3);
    cout&lt;&lt;Compare()(n2,n1)&lt;&lt;endl;
    return 0;
}
</code></pre>

<h2>在STL中使用举例</h2>

<pre><code class="C++">/**
* for_each函数实现的源码就用到了仿函数，Functor就是一个仿函数，它作为for_each的一个参数
**/

template &lt; typename Iterator, typename Functor &gt;   
void for_each( Iterator begin, Iterator end, Fucntor func )   
{   
for( ; begin!=end; begin++ )   
func( *begin );   
} 


/**
*使用for_each打印vector所有元素
**/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
using namespace std;

struct Print :unary_function&lt;int,void&gt;{
    void operator()(int i){
        cout&lt;&lt;i&lt;&lt;endl;
    }
};

int main(int argc, const char * argv[]) {
   vector&lt;int&gt; ve = {1,2,3};
   for_each(ve.begin(), ve.end(), Print());
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Split()函数的实现]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/08/ios39/"/>
    <updated>2016-02-08T19:32:26+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/08/ios39</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>java标准库提供split()函数用于字符型切割，但是C++的标准库并没有提供相应功能的方法，但是不用怕，今天我提供两种方法来实现我们自己的split()函数。</p>

<h2>方法一</h2>

<p>利用C++标准库提供s.find_first_of()函数和substr()函数的来解决。  <br/>
代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
/**
* s 指待分割的字符串
* delim 指分割符
* ret 用于存储分割结果的容器
**/

void split01(const string s,const string delim,vector&lt;string &gt;* ret)
{   
    //记录每次分割的起始位置
    size_t last = 0;
    //记录匹配delim这个字符的下标
    size_t index=s.find_first_of(delim,last);
    //当=-1时表示查找不到
    while (index!=-1)
    {       
        ret-&gt;push_back(s.substr(last,index-last));
        //记录下一次分割的起始位置
        last=index+1;
        index=s.find_first_of(delim,last);
    }
    //若最后一个分割符后面还有元素
    if (s.length()-last&gt;0) 
    {
        ret-&gt;push_back(s.substr(last));
    }
}
</code></pre>

<h2>方法二</h2>

<p>利用C++库提供的strtok()函数来解决。  <br/>
函数说明：char * strtok(char <em>s, const char </em>delim)，参数s 指向欲分割的字符串，参数delim 则为分割字符串，当strtok()在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符。还有一个用于多线程的strtok_r()。  <br/>
代码如下：</p>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

void split02(const string mystr,const char* deli,vector&lt;string&gt;* list){
    const char* str = mystr.c_str();
    char buffer[mystr.length()];
    //从mystr拷贝（sizeof(buffer)+1）-1个字符到buffer中
    snprintf(buffer, sizeof(buffer)+1,str);
    char* gg;
    char* p = strtok_r(buffer, deli,&amp;gg);
    list-&gt;clear();
    while (p!=NULL) {
        list-&gt;push_back(p);
        //往后的调用则将参数s 设置成NULL。每次调用成功则返回下一个分割后的字符串指针，设为NULL则默认指向这个指针
        p = strtok_r(NULL, deli, &amp;gg);
    }
}
</code></pre>

<h2>附录:C++中string与char*和const char*互转的方法</h2>

<pre><code class="C++">    //string 转 const char*
    string s1 = "abc";
    const char* c1 = s1.c_str();

    //const char* 转 string
    string s2(c1);

    //string 转 char*
    char* c2;
    c2 = new char[s1.length()+1];
    strcpy(c2, s1.c_str());

    //char* 转 string
    char* c3 = "abc";
    string s3(c3);

    //const char* 转为 char*
    const char* c4 = "123";
    char* c5 = new char[100];
    strcpy(c5, c4);
</code></pre>
]]></content>
  </entry>
  
</feed>
