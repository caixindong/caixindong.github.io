<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 栈内存与堆内存 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/zhan-nei-cun-yu-dui-nei-cun/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-06T11:18:22+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[内存栈与内存堆的区别]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/06/ios21/"/>
    <updated>2016-02-06T10:47:06+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/06/ios21</id>
    <content type="html"><![CDATA[<h2>内存栈</h2>

<p>又称为栈内存，它有以下特点：  <br/>
<code>1.</code> 函数压栈和弹栈符合后进先出的原则；  <br/>
<code>2.</code> 无论是变量还是函数，栈内存都是由高地址向低地址拓展，它是一块连续的内存区域；  <br/>
<code>3.</code> 栈内存的分配在运行前（编译）完成，运行时回收，且回收的素速度很快；  <br/>
<code>4.</code> 栈内存是由系统自动分配的；</p>

<h2>内存堆</h2>

<p>又称为堆内存，它有一下特点：  <br/>
<code>1.</code> 他是用静态链表来存储内存的地址；  <br/>
<code>2.</code> 堆内存是由低地址向高地址拓展，它是一块不连续的内存区域；  <br/>
<code>3.</code> 内存块有两种状态：已使用和闲置，分配时，将内存块标志为已使用，回收时，将内存块标志为闲置；  <br/>
<code>4.</code> 分配时，它的时间复杂度为O(n)，因为它需要遍历链表寻找闲置的内存块；  <br/>
<code>5.</code> 内存回收的方式有两种，一种是手动回收(C,C++),一种是GC线程自动回收(Java)；  <br/>
<code>6.</code> 标志清除算法是最基本的内存回收算法；  <br/>
<code>7.</code> 堆内存需要程序员自己申请，并指明大小；</p>
]]></content>
  </entry>
  
</feed>
