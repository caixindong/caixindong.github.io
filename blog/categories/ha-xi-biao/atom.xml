<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 哈希表 | Cool Guy]]></title>
  <link href="http://caixindong.github.io/blog/categories/ha-xi-biao/atom.xml" rel="self"/>
  <link href="http://caixindong.github.io/"/>
  <updated>2016-02-22T22:19:07+08:00</updated>
  <id>http://caixindong.github.io/</id>
  <author>
    <name><![CDATA[Xindong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2sum问题]]></title>
    <link href="http://caixindong.github.io/blog/2016/02/22/ios57/"/>
    <updated>2016-02-22T21:20:53+08:00</updated>
    <id>http://caixindong.github.io/blog/2016/02/22/ios57</id>
    <content type="html"><![CDATA[<h2>要求</h2>

<p>给定一个数组和一个目标数，在数组里查找两个数，这两个数之和等于目标数，返回这两个数的下标。  <br/>
例如 nums = [2,7,11,15],target = 9  <br/>
      return [0,1]</p>

<h2>做法</h2>

<p>遍历数组，利用hash表存储这个数组，键为数组元素，值为数组下标。遍历过程中，如果hash表内存在(target-当前元素),则找到sum为target的两个数。这种做法的时间复杂度为O(n)。</p>

<h2>代码实现</h2>

<pre><code class="C++">class Solution {
public:
     vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; result;
        unordered_map&lt;int, int&gt; hash_map;
        for (int i=0; i&lt;nums.size(); i++) {
            if (hash_map.count(nums[i])==0) {
                hash_map.insert(unordered_map&lt;int, int&gt;::value_type(nums[i],i));

            }
            if (hash_map.count(target-nums[i])==1) {
                int index = hash_map.find(target-nums[i])-&gt;second;
                if (i&lt;index) {
                    result.push_back(i);
                    result.push_back(index);
                }else if(i&gt;index){
                    result.push_back(index);
                    result.push_back(i);
                }
            }
        }
        return result;
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
